{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst eslintScope = require(\"eslint-scope\");\nconst Referencer = require(\"eslint-scope/lib/referencer\");\nconst {\n  SyncBailHook\n} = require(\"tapable\");\nconst {\n  CachedSource,\n  ConcatSource,\n  ReplaceSource\n} = require(\"webpack-sources\");\nconst ConcatenationScope = require(\"../ConcatenationScope\");\nconst {\n  UsageState\n} = require(\"../ExportsInfo\");\nconst Module = require(\"../Module\");\nconst {\n  JS_TYPES\n} = require(\"../ModuleSourceTypesConstants\");\nconst {\n  JAVASCRIPT_MODULE_TYPE_ESM\n} = require(\"../ModuleTypeConstants\");\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst Template = require(\"../Template\");\nconst HarmonyImportDependency = require(\"../dependencies/HarmonyImportDependency\");\nconst JavascriptParser = require(\"../javascript/JavascriptParser\");\nconst {\n  equals\n} = require(\"../util/ArrayHelpers\");\nconst LazySet = require(\"../util/LazySet\");\nconst {\n  concatComparators\n} = require(\"../util/comparators\");\nconst {\n  RESERVED_NAMES,\n  findNewName,\n  addScopeSymbols,\n  getAllReferences,\n  getPathInAst,\n  getUsedNamesInScopeInfo\n} = require(\"../util/concatenate\");\nconst createHash = require(\"../util/createHash\");\nconst {\n  makePathsRelative\n} = require(\"../util/identifier\");\nconst makeSerializable = require(\"../util/makeSerializable\");\nconst propertyAccess = require(\"../util/propertyAccess\");\nconst {\n  propertyName\n} = require(\"../util/propertyName\");\nconst {\n  filterRuntime,\n  intersectRuntime,\n  mergeRuntimeCondition,\n  mergeRuntimeConditionNonFalse,\n  runtimeConditionToString,\n  subtractRuntimeCondition\n} = require(\"../util/runtime\");\n\n/** @typedef {import(\"eslint-scope\").Reference} Reference */\n/** @typedef {import(\"eslint-scope\").Scope} Scope */\n/** @typedef {import(\"eslint-scope\").Variable} Variable */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../../declarations/WebpackOptions\").WebpackOptionsNormalized} WebpackOptions */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../CodeGenerationResults\")} CodeGenerationResults */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../Dependency\").UpdateHashContext} UpdateHashContext */\n/** @typedef {import(\"../DependencyTemplate\").DependencyTemplateContext} DependencyTemplateContext */\n/** @typedef {import(\"../DependencyTemplates\")} DependencyTemplates */\n/** @typedef {import(\"../ExportsInfo\").ExportInfo} ExportInfo */\n/** @typedef {import(\"../Module\").BuildInfo} BuildInfo */\n/** @typedef {import(\"../Module\").BuildMeta} BuildMeta */\n/** @typedef {import(\"../Module\").CodeGenerationContext} CodeGenerationContext */\n/** @typedef {import(\"../Module\").CodeGenerationResult} CodeGenerationResult */\n/** @typedef {import(\"../Module\").LibIdentOptions} LibIdentOptions */\n/** @typedef {import(\"../Module\").ReadOnlyRuntimeRequirements} ReadOnlyRuntimeRequirements */\n/** @typedef {import(\"../Module\").RuntimeRequirements} RuntimeRequirements */\n/** @typedef {import(\"../Module\").SourceTypes} SourceTypes */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n/** @typedef {import(\"../ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"../ModuleParseError\")} ModuleParseError */\n/** @typedef {import(\"../RequestShortener\")} RequestShortener */\n/** @typedef {import(\"../ResolverFactory\").ResolverWithOptions} ResolverWithOptions */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"../WebpackError\")} WebpackError */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").ChunkRenderContext} ChunkRenderContext */\n/** @typedef {import(\"../javascript/JavascriptParser\").Program} Program */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n/** @typedef {import(\"../serialization/ObjectMiddleware\").ObjectDeserializerContext} ObjectDeserializerContext */\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @typedef {typeof import(\"../util/Hash\")} HashConstructor */\n/** @typedef {import(\"../util/concatenate\").UsedNames} UsedNames */\n/** @typedef {import(\"../util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @template T\n * @typedef {import(\"../InitFragment\")<T>} InitFragment\n */\n\n/**\n * @template T\n * @typedef {import(\"../util/comparators\").Comparator<T>} Comparator\n */\n\n// fix eslint-scope to support class properties correctly\n// cspell:word Referencer\nconst ReferencerClass = /** @type {any} */Referencer;\nif (!ReferencerClass.prototype.PropertyDefinition) {\n  ReferencerClass.prototype.PropertyDefinition = ReferencerClass.prototype.Property;\n}\n\n/**\n * @typedef {object} ReexportInfo\n * @property {Module} module\n * @property {string[]} export\n */\n\n/** @typedef {RawBinding | SymbolBinding} Binding */\n\n/**\n * @typedef {object} RawBinding\n * @property {ModuleInfo} info\n * @property {string} rawName\n * @property {string=} comment\n * @property {string[]} ids\n * @property {string[]} exportName\n */\n\n/**\n * @typedef {object} SymbolBinding\n * @property {ConcatenatedModuleInfo} info\n * @property {string} name\n * @property {string=} comment\n * @property {string[]} ids\n * @property {string[]} exportName\n */\n\n/** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo } ModuleInfo */\n/** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo | ReferenceToModuleInfo } ModuleInfoOrReference */\n\n/**\n * @typedef {object} ConcatenatedModuleInfo\n * @property {\"concatenated\"} type\n * @property {Module} module\n * @property {number} index\n * @property {Program | undefined} ast\n * @property {Source | undefined} internalSource\n * @property {ReplaceSource | undefined} source\n * @property {InitFragment<ChunkRenderContext>[]=} chunkInitFragments\n * @property {ReadOnlyRuntimeRequirements | undefined} runtimeRequirements\n * @property {Scope | undefined} globalScope\n * @property {Scope | undefined} moduleScope\n * @property {Map<string, string>} internalNames\n * @property {Map<string, string> | undefined} exportMap\n * @property {Map<string, string> | undefined} rawExportMap\n * @property {string=} namespaceExportSymbol\n * @property {string | undefined} namespaceObjectName\n * @property {boolean} interopNamespaceObjectUsed\n * @property {string | undefined} interopNamespaceObjectName\n * @property {boolean} interopNamespaceObject2Used\n * @property {string | undefined} interopNamespaceObject2Name\n * @property {boolean} interopDefaultAccessUsed\n * @property {string | undefined} interopDefaultAccessName\n */\n\n/**\n * @typedef {object} ExternalModuleInfo\n * @property {\"external\"} type\n * @property {Module} module\n * @property {RuntimeSpec | boolean} runtimeCondition\n * @property {number} index\n * @property {string | undefined} name\n * @property {boolean} interopNamespaceObjectUsed\n * @property {string | undefined} interopNamespaceObjectName\n * @property {boolean} interopNamespaceObject2Used\n * @property {string | undefined} interopNamespaceObject2Name\n * @property {boolean} interopDefaultAccessUsed\n * @property {string | undefined} interopDefaultAccessName\n */\n\n/**\n * @typedef {object} ReferenceToModuleInfo\n * @property {\"reference\"} type\n * @property {RuntimeSpec | boolean} runtimeCondition\n * @property {ModuleInfo} target\n */\n\n/**\n * @template T\n * @param {string} property property\n * @param {function(T[keyof T], T[keyof T]): 0 | 1 | -1} comparator comparator\n * @returns {Comparator<T>} comparator\n */\n\nconst createComparator = (property, comparator) => (a, b) => comparator(a[(/** @type {keyof T} */property)], b[(/** @type {keyof T} */property)]);\n\n/**\n * @param {number} a a\n * @param {number} b b\n * @returns {0 | 1 | -1} result\n */\nconst compareNumbers = (a, b) => {\n  if (Number.isNaN(a)) {\n    if (!Number.isNaN(b)) {\n      return 1;\n    }\n  } else {\n    if (Number.isNaN(b)) {\n      return -1;\n    }\n    if (a !== b) {\n      return a < b ? -1 : 1;\n    }\n  }\n  return 0;\n};\nconst bySourceOrder = createComparator(\"sourceOrder\", compareNumbers);\nconst byRangeStart = createComparator(\"rangeStart\", compareNumbers);\n\n/**\n * @param {Iterable<string>} iterable iterable object\n * @returns {string} joined iterable object\n */\nconst joinIterableWithComma = iterable => {\n  // This is more performant than Array.from().join(\", \")\n  // as it doesn't create an array\n  let str = \"\";\n  let first = true;\n  for (const item of iterable) {\n    if (first) {\n      first = false;\n    } else {\n      str += \", \";\n    }\n    str += item;\n  }\n  return str;\n};\n\n/**\n * @typedef {object} ConcatenationEntry\n * @property {\"concatenated\" | \"external\"} type\n * @property {Module} module\n * @property {RuntimeSpec | boolean} runtimeCondition\n */\n\n/**\n * @param {ModuleGraph} moduleGraph the module graph\n * @param {ModuleInfo} info module info\n * @param {string[]} exportName exportName\n * @param {Map<Module, ModuleInfo>} moduleToInfoMap moduleToInfoMap\n * @param {RuntimeSpec} runtime for which runtime\n * @param {RequestShortener} requestShortener the request shortener\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {Set<ConcatenatedModuleInfo>} neededNamespaceObjects modules for which a namespace object should be generated\n * @param {boolean} asCall asCall\n * @param {boolean | undefined} strictHarmonyModule strictHarmonyModule\n * @param {boolean | undefined} asiSafe asiSafe\n * @param {Set<ExportInfo>} alreadyVisited alreadyVisited\n * @returns {Binding} the final variable\n */\nconst getFinalBinding = (moduleGraph, info, exportName, moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, asCall, strictHarmonyModule, asiSafe, alreadyVisited = new Set()) => {\n  const exportsType = info.module.getExportsType(moduleGraph, strictHarmonyModule);\n  if (exportName.length === 0) {\n    switch (exportsType) {\n      case \"default-only\":\n        info.interopNamespaceObject2Used = true;\n        return {\n          info,\n          rawName: (/** @type {string} */info.interopNamespaceObject2Name),\n          ids: exportName,\n          exportName\n        };\n      case \"default-with-named\":\n        info.interopNamespaceObjectUsed = true;\n        return {\n          info,\n          rawName: (/** @type {string} */info.interopNamespaceObjectName),\n          ids: exportName,\n          exportName\n        };\n      case \"namespace\":\n      case \"dynamic\":\n        break;\n      default:\n        throw new Error(`Unexpected exportsType ${exportsType}`);\n    }\n  } else {\n    switch (exportsType) {\n      case \"namespace\":\n        break;\n      case \"default-with-named\":\n        switch (exportName[0]) {\n          case \"default\":\n            exportName = exportName.slice(1);\n            break;\n          case \"__esModule\":\n            return {\n              info,\n              rawName: \"/* __esModule */true\",\n              ids: exportName.slice(1),\n              exportName\n            };\n        }\n        break;\n      case \"default-only\":\n        {\n          const exportId = exportName[0];\n          if (exportId === \"__esModule\") {\n            return {\n              info,\n              rawName: \"/* __esModule */true\",\n              ids: exportName.slice(1),\n              exportName\n            };\n          }\n          exportName = exportName.slice(1);\n          if (exportId !== \"default\") {\n            return {\n              info,\n              rawName: \"/* non-default import from default-exporting module */undefined\",\n              ids: exportName,\n              exportName\n            };\n          }\n          break;\n        }\n      case \"dynamic\":\n        switch (exportName[0]) {\n          case \"default\":\n            {\n              exportName = exportName.slice(1);\n              info.interopDefaultAccessUsed = true;\n              const defaultExport = asCall ? `${info.interopDefaultAccessName}()` : asiSafe ? `(${info.interopDefaultAccessName}())` : asiSafe === false ? `;(${info.interopDefaultAccessName}())` : `${info.interopDefaultAccessName}.a`;\n              return {\n                info,\n                rawName: defaultExport,\n                ids: exportName,\n                exportName\n              };\n            }\n          case \"__esModule\":\n            return {\n              info,\n              rawName: \"/* __esModule */true\",\n              ids: exportName.slice(1),\n              exportName\n            };\n        }\n        break;\n      default:\n        throw new Error(`Unexpected exportsType ${exportsType}`);\n    }\n  }\n  if (exportName.length === 0) {\n    switch (info.type) {\n      case \"concatenated\":\n        neededNamespaceObjects.add(info);\n        return {\n          info,\n          rawName: (/** @type {NonNullable<ConcatenatedModuleInfo[\"namespaceObjectName\"]>} */\n          info.namespaceObjectName),\n          ids: exportName,\n          exportName\n        };\n      case \"external\":\n        return {\n          info,\n          rawName: (/** @type {NonNullable<ExternalModuleInfo[\"name\"]>} */\n          info.name),\n          ids: exportName,\n          exportName\n        };\n    }\n  }\n  const exportsInfo = moduleGraph.getExportsInfo(info.module);\n  const exportInfo = exportsInfo.getExportInfo(exportName[0]);\n  if (alreadyVisited.has(exportInfo)) {\n    return {\n      info,\n      rawName: \"/* circular reexport */ Object(function x() { x() }())\",\n      ids: [],\n      exportName\n    };\n  }\n  alreadyVisited.add(exportInfo);\n  switch (info.type) {\n    case \"concatenated\":\n      {\n        const exportId = exportName[0];\n        if (exportInfo.provided === false) {\n          // It's not provided, but it could be on the prototype\n          neededNamespaceObjects.add(info);\n          return {\n            info,\n            rawName: (/** @type {string} */info.namespaceObjectName),\n            ids: exportName,\n            exportName\n          };\n        }\n        const directExport = info.exportMap && info.exportMap.get(exportId);\n        if (directExport) {\n          const usedName = /** @type {string[]} */\n          exportsInfo.getUsedName(exportName, runtime);\n          if (!usedName) {\n            return {\n              info,\n              rawName: \"/* unused export */ undefined\",\n              ids: exportName.slice(1),\n              exportName\n            };\n          }\n          return {\n            info,\n            name: directExport,\n            ids: usedName.slice(1),\n            exportName\n          };\n        }\n        const rawExport = info.rawExportMap && info.rawExportMap.get(exportId);\n        if (rawExport) {\n          return {\n            info,\n            rawName: rawExport,\n            ids: exportName.slice(1),\n            exportName\n          };\n        }\n        const reexport = exportInfo.findTarget(moduleGraph, module => moduleToInfoMap.has(module));\n        if (reexport === false) {\n          throw new Error(`Target module of reexport from '${info.module.readableIdentifier(requestShortener)}' is not part of the concatenation (export '${exportId}')\\nModules in the concatenation:\\n${Array.from(moduleToInfoMap, ([m, info]) => ` * ${info.type} ${m.readableIdentifier(requestShortener)}`).join(\"\\n\")}`);\n        }\n        if (reexport) {\n          const refInfo = moduleToInfoMap.get(reexport.module);\n          return getFinalBinding(moduleGraph, /** @type {ModuleInfo} */refInfo, reexport.export ? [...reexport.export, ...exportName.slice(1)] : exportName.slice(1), moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, asCall, /** @type {BuildMeta} */\n          info.module.buildMeta.strictHarmonyModule, asiSafe, alreadyVisited);\n        }\n        if (info.namespaceExportSymbol) {\n          const usedName = /** @type {string[]} */\n          exportsInfo.getUsedName(exportName, runtime);\n          return {\n            info,\n            rawName: (/** @type {string} */info.namespaceObjectName),\n            ids: usedName,\n            exportName\n          };\n        }\n        throw new Error(`Cannot get final name for export '${exportName.join(\".\")}' of ${info.module.readableIdentifier(requestShortener)}`);\n      }\n    case \"external\":\n      {\n        const used = /** @type {string[]} */\n        exportsInfo.getUsedName(exportName, runtime);\n        if (!used) {\n          return {\n            info,\n            rawName: \"/* unused export */ undefined\",\n            ids: exportName.slice(1),\n            exportName\n          };\n        }\n        const comment = equals(used, exportName) ? \"\" : Template.toNormalComment(`${exportName.join(\".\")}`);\n        return {\n          info,\n          rawName: info.name + comment,\n          ids: used,\n          exportName\n        };\n      }\n  }\n};\n\n/**\n * @param {ModuleGraph} moduleGraph the module graph\n * @param {ModuleInfo} info module info\n * @param {string[]} exportName exportName\n * @param {Map<Module, ModuleInfo>} moduleToInfoMap moduleToInfoMap\n * @param {RuntimeSpec} runtime for which runtime\n * @param {RequestShortener} requestShortener the request shortener\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {Set<ConcatenatedModuleInfo>} neededNamespaceObjects modules for which a namespace object should be generated\n * @param {boolean} asCall asCall\n * @param {boolean | undefined} callContext callContext\n * @param {boolean | undefined} strictHarmonyModule strictHarmonyModule\n * @param {boolean | undefined} asiSafe asiSafe\n * @returns {string} the final name\n */\nconst getFinalName = (moduleGraph, info, exportName, moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, asCall, callContext, strictHarmonyModule, asiSafe) => {\n  const binding = getFinalBinding(moduleGraph, info, exportName, moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, asCall, strictHarmonyModule, asiSafe);\n  {\n    const {\n      ids,\n      comment\n    } = binding;\n    let reference;\n    let isPropertyAccess;\n    if (\"rawName\" in binding) {\n      reference = `${binding.rawName}${comment || \"\"}${propertyAccess(ids)}`;\n      isPropertyAccess = ids.length > 0;\n    } else {\n      const {\n        info,\n        name: exportId\n      } = binding;\n      const name = info.internalNames.get(exportId);\n      if (!name) {\n        throw new Error(`The export \"${exportId}\" in \"${info.module.readableIdentifier(requestShortener)}\" has no internal name (existing names: ${Array.from(info.internalNames, ([name, symbol]) => `${name}: ${symbol}`).join(\", \") || \"none\"})`);\n      }\n      reference = `${name}${comment || \"\"}${propertyAccess(ids)}`;\n      isPropertyAccess = ids.length > 1;\n    }\n    if (isPropertyAccess && asCall && callContext === false) {\n      return asiSafe ? `(0,${reference})` : asiSafe === false ? `;(0,${reference})` : `/*#__PURE__*/Object(${reference})`;\n    }\n    return reference;\n  }\n};\n\n/**\n * @typedef {object} ConcatenateModuleHooks\n * @property {SyncBailHook<[Record<string, string>], boolean | void>} exportsDefinitions\n */\n\n/** @type {WeakMap<Compilation, ConcatenateModuleHooks>} */\nconst compilationHooksMap = new WeakMap();\nclass ConcatenatedModule extends Module {\n  /**\n   * @param {Module} rootModule the root module of the concatenation\n   * @param {Set<Module>} modules all modules in the concatenation (including the root module)\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {Compilation} compilation the compilation\n   * @param {object=} associatedObjectForCache object for caching\n   * @param {string | HashConstructor=} hashFunction hash function to use\n   * @returns {ConcatenatedModule} the module\n   */\n  static create(rootModule, modules, runtime, compilation, associatedObjectForCache, hashFunction = \"md4\") {\n    const identifier = ConcatenatedModule._createIdentifier(rootModule, modules, associatedObjectForCache, hashFunction);\n    return new ConcatenatedModule({\n      identifier,\n      rootModule,\n      modules,\n      runtime,\n      compilation\n    });\n  }\n\n  /**\n   * @param {Compilation} compilation the compilation\n   * @returns {ConcatenateModuleHooks} the attached hooks\n   */\n  static getCompilationHooks(compilation) {\n    let hooks = compilationHooksMap.get(compilation);\n    if (hooks === undefined) {\n      hooks = {\n        exportsDefinitions: new SyncBailHook([\"definitions\"])\n      };\n      compilationHooksMap.set(compilation, hooks);\n    }\n    return hooks;\n  }\n\n  /**\n   * @param {object} options options\n   * @param {string} options.identifier the identifier of the module\n   * @param {Module} options.rootModule the root module of the concatenation\n   * @param {RuntimeSpec} options.runtime the selected runtime\n   * @param {Set<Module>} options.modules all concatenated modules\n   * @param {Compilation} options.compilation the compilation\n   */\n  constructor({\n    identifier,\n    rootModule,\n    modules,\n    runtime,\n    compilation\n  }) {\n    super(JAVASCRIPT_MODULE_TYPE_ESM, null, rootModule && rootModule.layer);\n\n    // Info from Factory\n    /** @type {string} */\n    this._identifier = identifier;\n    /** @type {Module} */\n    this.rootModule = rootModule;\n    /** @type {Set<Module>} */\n    this._modules = modules;\n    this._runtime = runtime;\n    this.factoryMeta = rootModule && rootModule.factoryMeta;\n    /** @type {Compilation | undefined} */\n    this.compilation = compilation;\n  }\n\n  /**\n   * Assuming this module is in the cache. Update the (cached) module with\n   * the fresh module from the factory. Usually updates internal references\n   * and properties.\n   * @param {Module} module fresh module\n   * @returns {void}\n   */\n  updateCacheModule(module) {\n    throw new Error(\"Must not be called\");\n  }\n\n  /**\n   * @returns {SourceTypes} types available (do not mutate)\n   */\n  getSourceTypes() {\n    return JS_TYPES;\n  }\n  get modules() {\n    return Array.from(this._modules);\n  }\n\n  /**\n   * @returns {string} a unique identifier of the module\n   */\n  identifier() {\n    return this._identifier;\n  }\n\n  /**\n   * @param {RequestShortener} requestShortener the request shortener\n   * @returns {string} a user readable identifier of the module\n   */\n  readableIdentifier(requestShortener) {\n    return `${this.rootModule.readableIdentifier(requestShortener)} + ${this._modules.size - 1} modules`;\n  }\n\n  /**\n   * @param {LibIdentOptions} options options\n   * @returns {string | null} an identifier for library inclusion\n   */\n  libIdent(options) {\n    return this.rootModule.libIdent(options);\n  }\n\n  /**\n   * @returns {string | null} absolute path which should be used for condition matching (usually the resource path)\n   */\n  nameForCondition() {\n    return this.rootModule.nameForCondition();\n  }\n\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @returns {ConnectionState} how this module should be connected to referencing modules when consumed for side-effects only\n   */\n  getSideEffectsConnectionState(moduleGraph) {\n    return this.rootModule.getSideEffectsConnectionState(moduleGraph);\n  }\n\n  /**\n   * @param {WebpackOptions} options webpack options\n   * @param {Compilation} compilation the compilation\n   * @param {ResolverWithOptions} resolver the resolver\n   * @param {InputFileSystem} fs the file system\n   * @param {function(WebpackError=): void} callback callback function\n   * @returns {void}\n   */\n  build(options, compilation, resolver, fs, callback) {\n    const {\n      rootModule\n    } = this;\n    const {\n      moduleArgument,\n      exportsArgument\n    } = /** @type {BuildInfo} */\n    rootModule.buildInfo;\n    this.buildInfo = {\n      strict: true,\n      cacheable: true,\n      moduleArgument,\n      exportsArgument,\n      fileDependencies: new LazySet(),\n      contextDependencies: new LazySet(),\n      missingDependencies: new LazySet(),\n      topLevelDeclarations: new Set(),\n      assets: undefined\n    };\n    this.buildMeta = rootModule.buildMeta;\n    this.clearDependenciesAndBlocks();\n    this.clearWarningsAndErrors();\n    for (const m of this._modules) {\n      // populate cacheable\n      if (!(/** @type {BuildInfo} */m.buildInfo.cacheable)) {\n        this.buildInfo.cacheable = false;\n      }\n\n      // populate dependencies\n      for (const d of m.dependencies.filter(dep => !(dep instanceof HarmonyImportDependency) || !this._modules.has(/** @type {Module} */compilation.moduleGraph.getModule(dep)))) {\n        this.dependencies.push(d);\n      }\n      // populate blocks\n      for (const d of m.blocks) {\n        this.blocks.push(d);\n      }\n\n      // populate warnings\n      const warnings = m.getWarnings();\n      if (warnings !== undefined) {\n        for (const warning of warnings) {\n          this.addWarning(warning);\n        }\n      }\n\n      // populate errors\n      const errors = m.getErrors();\n      if (errors !== undefined) {\n        for (const error of errors) {\n          this.addError(error);\n        }\n      }\n      const {\n        assets,\n        assetsInfo,\n        topLevelDeclarations\n      } = /** @type {BuildInfo} */m.buildInfo;\n\n      // populate topLevelDeclarations\n      if (topLevelDeclarations) {\n        const topLevelDeclarations = this.buildInfo.topLevelDeclarations;\n        if (topLevelDeclarations !== undefined) {\n          for (const decl of topLevelDeclarations) {\n            topLevelDeclarations.add(decl);\n          }\n        }\n      } else {\n        this.buildInfo.topLevelDeclarations = undefined;\n      }\n\n      // populate assets\n      if (assets) {\n        if (this.buildInfo.assets === undefined) {\n          this.buildInfo.assets = Object.create(null);\n        }\n        Object.assign(/** @type {NonNullable<BuildInfo[\"assets\"]>} */\n\n        /** @type {BuildInfo} */\n        this.buildInfo.assets, assets);\n      }\n      if (assetsInfo) {\n        if (this.buildInfo.assetsInfo === undefined) {\n          this.buildInfo.assetsInfo = new Map();\n        }\n        for (const [key, value] of assetsInfo) {\n          this.buildInfo.assetsInfo.set(key, value);\n        }\n      }\n    }\n    callback();\n  }\n\n  /**\n   * @param {string=} type the source type for which the size should be estimated\n   * @returns {number} the estimated size of the module (must be non-zero)\n   */\n  size(type) {\n    // Guess size from embedded modules\n    let size = 0;\n    for (const module of this._modules) {\n      size += module.size(type);\n    }\n    return size;\n  }\n\n  /**\n   * @private\n   * @param {Module} rootModule the root of the concatenation\n   * @param {Set<Module>} modulesSet a set of modules which should be concatenated\n   * @param {RuntimeSpec} runtime for this runtime\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @returns {ConcatenationEntry[]} concatenation list\n   */\n  _createConcatenationList(rootModule, modulesSet, runtime, moduleGraph) {\n    /** @type {ConcatenationEntry[]} */\n    const list = [];\n    /** @type {Map<Module, RuntimeSpec | true>} */\n    const existingEntries = new Map();\n\n    /**\n     * @param {Module} module a module\n     * @returns {Iterable<{ connection: ModuleGraphConnection, runtimeCondition: RuntimeSpec | true }>} imported modules in order\n     */\n    const getConcatenatedImports = module => {\n      const connections = Array.from(moduleGraph.getOutgoingConnections(module));\n      if (module === rootModule) {\n        for (const c of moduleGraph.getOutgoingConnections(this)) connections.push(c);\n      }\n      /**\n       * @type {Array<{ connection: ModuleGraphConnection, sourceOrder: number, rangeStart: number }>}\n       */\n      const references = connections.filter(connection => {\n        if (!(connection.dependency instanceof HarmonyImportDependency)) return false;\n        return connection && connection.resolvedOriginModule === module && connection.module && connection.isTargetActive(runtime);\n      }).map(connection => {\n        const dep = /** @type {HarmonyImportDependency} */\n        connection.dependency;\n        return {\n          connection,\n          sourceOrder: dep.sourceOrder,\n          rangeStart: dep.range && dep.range[0]\n        };\n      });\n      /**\n       * bySourceOrder\n       * @example\n       * import a from \"a\"; // sourceOrder=1\n       * import b from \"b\"; // sourceOrder=2\n       *\n       * byRangeStart\n       * @example\n       * import {a, b} from \"a\"; // sourceOrder=1\n       * a.a(); // first range\n       * b.b(); // second range\n       *\n       * If there is no reexport, we have the same source.\n       * If there is reexport, but module has side effects, this will lead to reexport module only.\n       * If there is side-effects-free reexport, we can get simple deterministic result with range start comparison.\n       */\n      references.sort(concatComparators(bySourceOrder, byRangeStart));\n      /** @type {Map<Module, { connection: ModuleGraphConnection, runtimeCondition: RuntimeSpec | true }>} */\n      const referencesMap = new Map();\n      for (const {\n        connection\n      } of references) {\n        const runtimeCondition = filterRuntime(runtime, r => connection.isTargetActive(r));\n        if (runtimeCondition === false) continue;\n        const module = connection.module;\n        const entry = referencesMap.get(module);\n        if (entry === undefined) {\n          referencesMap.set(module, {\n            connection,\n            runtimeCondition\n          });\n          continue;\n        }\n        entry.runtimeCondition = mergeRuntimeConditionNonFalse(entry.runtimeCondition, runtimeCondition, runtime);\n      }\n      return referencesMap.values();\n    };\n\n    /**\n     * @param {ModuleGraphConnection} connection graph connection\n     * @param {RuntimeSpec | true} runtimeCondition runtime condition\n     * @returns {void}\n     */\n    const enterModule = (connection, runtimeCondition) => {\n      const module = connection.module;\n      if (!module) return;\n      const existingEntry = existingEntries.get(module);\n      if (existingEntry === true) {\n        return;\n      }\n      if (modulesSet.has(module)) {\n        existingEntries.set(module, true);\n        if (runtimeCondition !== true) {\n          throw new Error(`Cannot runtime-conditional concatenate a module (${module.identifier()} in ${this.rootModule.identifier()}, ${runtimeConditionToString(runtimeCondition)}). This should not happen.`);\n        }\n        const imports = getConcatenatedImports(module);\n        for (const {\n          connection,\n          runtimeCondition\n        } of imports) enterModule(connection, runtimeCondition);\n        list.push({\n          type: \"concatenated\",\n          module: connection.module,\n          runtimeCondition\n        });\n      } else {\n        if (existingEntry !== undefined) {\n          const reducedRuntimeCondition = subtractRuntimeCondition(runtimeCondition, existingEntry, runtime);\n          if (reducedRuntimeCondition === false) return;\n          runtimeCondition = reducedRuntimeCondition;\n          existingEntries.set(connection.module, mergeRuntimeConditionNonFalse(existingEntry, runtimeCondition, runtime));\n        } else {\n          existingEntries.set(connection.module, runtimeCondition);\n        }\n        if (list.length > 0) {\n          const lastItem = list[list.length - 1];\n          if (lastItem.type === \"external\" && lastItem.module === connection.module) {\n            lastItem.runtimeCondition = mergeRuntimeCondition(lastItem.runtimeCondition, runtimeCondition, runtime);\n            return;\n          }\n        }\n        list.push({\n          type: \"external\",\n          get module() {\n            // We need to use a getter here, because the module in the dependency\n            // could be replaced by some other process (i. e. also replaced with a\n            // concatenated module)\n            return connection.module;\n          },\n          runtimeCondition\n        });\n      }\n    };\n    existingEntries.set(rootModule, true);\n    const imports = getConcatenatedImports(rootModule);\n    for (const {\n      connection,\n      runtimeCondition\n    } of imports) enterModule(connection, runtimeCondition);\n    list.push({\n      type: \"concatenated\",\n      module: rootModule,\n      runtimeCondition: true\n    });\n    return list;\n  }\n\n  /**\n   * @param {Module} rootModule the root module of the concatenation\n   * @param {Set<Module>} modules all modules in the concatenation (including the root module)\n   * @param {object=} associatedObjectForCache object for caching\n   * @param {string | HashConstructor=} hashFunction hash function to use\n   * @returns {string} the identifier\n   */\n  static _createIdentifier(rootModule, modules, associatedObjectForCache, hashFunction = \"md4\") {\n    const cachedMakePathsRelative = makePathsRelative.bindContextCache(/** @type {string} */rootModule.context, associatedObjectForCache);\n    const identifiers = [];\n    for (const module of modules) {\n      identifiers.push(cachedMakePathsRelative(module.identifier()));\n    }\n    identifiers.sort();\n    const hash = createHash(hashFunction);\n    hash.update(identifiers.join(\" \"));\n    return `${rootModule.identifier()}|${hash.digest(\"hex\")}`;\n  }\n\n  /**\n   * @param {LazySet<string>} fileDependencies set where file dependencies are added to\n   * @param {LazySet<string>} contextDependencies set where context dependencies are added to\n   * @param {LazySet<string>} missingDependencies set where missing dependencies are added to\n   * @param {LazySet<string>} buildDependencies set where build dependencies are added to\n   */\n  addCacheDependencies(fileDependencies, contextDependencies, missingDependencies, buildDependencies) {\n    for (const module of this._modules) {\n      module.addCacheDependencies(fileDependencies, contextDependencies, missingDependencies, buildDependencies);\n    }\n  }\n\n  /**\n   * @param {CodeGenerationContext} context context for code generation\n   * @returns {CodeGenerationResult} result\n   */\n  codeGeneration({\n    dependencyTemplates,\n    runtimeTemplate,\n    moduleGraph,\n    chunkGraph,\n    runtime: generationRuntime,\n    codeGenerationResults\n  }) {\n    /** @type {RuntimeRequirements} */\n    const runtimeRequirements = new Set();\n    const runtime = intersectRuntime(generationRuntime, this._runtime);\n    const requestShortener = runtimeTemplate.requestShortener;\n    // Meta info for each module\n    const [modulesWithInfo, moduleToInfoMap] = this._getModulesWithInfo(moduleGraph, runtime);\n\n    // Set with modules that need a generated namespace object\n    /** @type {Set<ConcatenatedModuleInfo>} */\n    const neededNamespaceObjects = new Set();\n\n    // Generate source code and analyse scopes\n    // Prepare a ReplaceSource for the final source\n    for (const info of moduleToInfoMap.values()) {\n      this._analyseModule(moduleToInfoMap, info, dependencyTemplates, runtimeTemplate, moduleGraph, chunkGraph, runtime, /** @type {CodeGenerationResults} */\n      codeGenerationResults);\n    }\n\n    // List of all used names to avoid conflicts\n    const allUsedNames = new Set(RESERVED_NAMES);\n    // Updated Top level declarations are created by renaming\n    const topLevelDeclarations = new Set();\n\n    // List of additional names in scope for module references\n    /** @type {Map<string, { usedNames: UsedNames, alreadyCheckedScopes: Set<TODO> }>} */\n    const usedNamesInScopeInfo = new Map();\n    /**\n     * @param {string} module module identifier\n     * @param {string} id export id\n     * @returns {{ usedNames: UsedNames, alreadyCheckedScopes: Set<TODO> }} info\n     */\n\n    // Set of already checked scopes\n    const ignoredScopes = new Set();\n\n    // get all global names\n    for (const info of modulesWithInfo) {\n      if (info.type === \"concatenated\") {\n        // ignore symbols from moduleScope\n        if (info.moduleScope) {\n          ignoredScopes.add(info.moduleScope);\n        }\n\n        // The super class expression in class scopes behaves weird\n        // We get ranges of all super class expressions to make\n        // renaming to work correctly\n        const superClassCache = new WeakMap();\n        /**\n         * @param {Scope} scope scope\n         * @returns {TODO} result\n         */\n        const getSuperClassExpressions = scope => {\n          const cacheEntry = superClassCache.get(scope);\n          if (cacheEntry !== undefined) return cacheEntry;\n          const superClassExpressions = [];\n          for (const childScope of scope.childScopes) {\n            if (childScope.type !== \"class\") continue;\n            const block = childScope.block;\n            if ((block.type === \"ClassDeclaration\" || block.type === \"ClassExpression\") && block.superClass) {\n              superClassExpressions.push({\n                range: block.superClass.range,\n                variables: childScope.variables\n              });\n            }\n          }\n          superClassCache.set(scope, superClassExpressions);\n          return superClassExpressions;\n        };\n\n        // add global symbols\n        if (info.globalScope) {\n          for (const reference of info.globalScope.through) {\n            const name = reference.identifier.name;\n            if (ConcatenationScope.isModuleReference(name)) {\n              const match = ConcatenationScope.matchModuleReference(name);\n              if (!match) continue;\n              const referencedInfo = modulesWithInfo[match.index];\n              if (referencedInfo.type === \"reference\") throw new Error(\"Module reference can't point to a reference\");\n              const binding = getFinalBinding(moduleGraph, referencedInfo, match.ids, moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, false, /** @type {BuildMeta} */\n              info.module.buildMeta.strictHarmonyModule, true);\n              if (!binding.ids) continue;\n              const {\n                usedNames,\n                alreadyCheckedScopes\n              } = getUsedNamesInScopeInfo(usedNamesInScopeInfo, binding.info.module.identifier(), \"name\" in binding ? binding.name : \"\");\n              for (const expr of getSuperClassExpressions(reference.from)) {\n                if (expr.range[0] <= /** @type {Range} */reference.identifier.range[0] && expr.range[1] >= /** @type {Range} */reference.identifier.range[1]) {\n                  for (const variable of expr.variables) {\n                    usedNames.add(variable.name);\n                  }\n                }\n              }\n              addScopeSymbols(reference.from, usedNames, alreadyCheckedScopes, ignoredScopes);\n            } else {\n              allUsedNames.add(name);\n            }\n          }\n        }\n      }\n    }\n\n    // generate names for symbols\n    for (const info of moduleToInfoMap.values()) {\n      const {\n        usedNames: namespaceObjectUsedNames\n      } = getUsedNamesInScopeInfo(usedNamesInScopeInfo, info.module.identifier(), \"\");\n      switch (info.type) {\n        case \"concatenated\":\n          {\n            const variables = /** @type {Scope} */info.moduleScope.variables;\n            for (const variable of variables) {\n              const name = variable.name;\n              const {\n                usedNames,\n                alreadyCheckedScopes\n              } = getUsedNamesInScopeInfo(usedNamesInScopeInfo, info.module.identifier(), name);\n              if (allUsedNames.has(name) || usedNames.has(name)) {\n                const references = getAllReferences(variable);\n                for (const ref of references) {\n                  addScopeSymbols(ref.from, usedNames, alreadyCheckedScopes, ignoredScopes);\n                }\n                const newName = findNewName(name, allUsedNames, usedNames, info.module.readableIdentifier(requestShortener));\n                allUsedNames.add(newName);\n                info.internalNames.set(name, newName);\n                topLevelDeclarations.add(newName);\n                const source = /** @type {ReplaceSource} */info.source;\n                const allIdentifiers = new Set(references.map(r => r.identifier).concat(variable.identifiers));\n                for (const identifier of allIdentifiers) {\n                  const r = /** @type {Range} */identifier.range;\n                  const path = getPathInAst(/** @type {NonNullable<ConcatenatedModuleInfo[\"ast\"]>} */\n                  info.ast, identifier);\n                  if (path && path.length > 1) {\n                    const maybeProperty = path[1].type === \"AssignmentPattern\" && path[1].left === path[0] ? path[2] : path[1];\n                    if (maybeProperty.type === \"Property\" && maybeProperty.shorthand) {\n                      source.insert(r[1], `: ${newName}`);\n                      continue;\n                    }\n                  }\n                  source.replace(r[0], r[1] - 1, newName);\n                }\n              } else {\n                allUsedNames.add(name);\n                info.internalNames.set(name, name);\n                topLevelDeclarations.add(name);\n              }\n            }\n            let namespaceObjectName;\n            if (info.namespaceExportSymbol) {\n              namespaceObjectName = info.internalNames.get(info.namespaceExportSymbol);\n            } else {\n              namespaceObjectName = findNewName(\"namespaceObject\", allUsedNames, namespaceObjectUsedNames, info.module.readableIdentifier(requestShortener));\n              allUsedNames.add(namespaceObjectName);\n            }\n            info.namespaceObjectName = /** @type {string} */\n            namespaceObjectName;\n            topLevelDeclarations.add(namespaceObjectName);\n            break;\n          }\n        case \"external\":\n          {\n            const externalName = findNewName(\"\", allUsedNames, namespaceObjectUsedNames, info.module.readableIdentifier(requestShortener));\n            allUsedNames.add(externalName);\n            info.name = externalName;\n            topLevelDeclarations.add(externalName);\n            break;\n          }\n      }\n      const buildMeta = /** @type {BuildMeta} */info.module.buildMeta;\n      if (buildMeta.exportsType !== \"namespace\") {\n        const externalNameInterop = findNewName(\"namespaceObject\", allUsedNames, namespaceObjectUsedNames, info.module.readableIdentifier(requestShortener));\n        allUsedNames.add(externalNameInterop);\n        info.interopNamespaceObjectName = externalNameInterop;\n        topLevelDeclarations.add(externalNameInterop);\n      }\n      if (buildMeta.exportsType === \"default\" && buildMeta.defaultObject !== \"redirect\") {\n        const externalNameInterop = findNewName(\"namespaceObject2\", allUsedNames, namespaceObjectUsedNames, info.module.readableIdentifier(requestShortener));\n        allUsedNames.add(externalNameInterop);\n        info.interopNamespaceObject2Name = externalNameInterop;\n        topLevelDeclarations.add(externalNameInterop);\n      }\n      if (buildMeta.exportsType === \"dynamic\" || !buildMeta.exportsType) {\n        const externalNameInterop = findNewName(\"default\", allUsedNames, namespaceObjectUsedNames, info.module.readableIdentifier(requestShortener));\n        allUsedNames.add(externalNameInterop);\n        info.interopDefaultAccessName = externalNameInterop;\n        topLevelDeclarations.add(externalNameInterop);\n      }\n    }\n\n    // Find and replace references to modules\n    for (const info of moduleToInfoMap.values()) {\n      if (info.type === \"concatenated\") {\n        const globalScope = /** @type {Scope} */info.globalScope;\n        for (const reference of globalScope.through) {\n          const name = reference.identifier.name;\n          const match = ConcatenationScope.matchModuleReference(name);\n          if (match) {\n            const referencedInfo = modulesWithInfo[match.index];\n            if (referencedInfo.type === \"reference\") throw new Error(\"Module reference can't point to a reference\");\n            const finalName = getFinalName(moduleGraph, referencedInfo, match.ids, moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, match.call, !match.directImport, /** @type {BuildMeta} */\n            info.module.buildMeta.strictHarmonyModule, match.asiSafe);\n            const r = /** @type {Range} */reference.identifier.range;\n            const source = /** @type {ReplaceSource} */info.source;\n            // range is extended by 2 chars to cover the appended \"._\"\n            source.replace(r[0], r[1] + 1, finalName);\n          }\n        }\n      }\n    }\n\n    // Map with all root exposed used exports\n    /** @type {Map<string, function(RequestShortener): string>} */\n    const exportsMap = new Map();\n\n    // Set with all root exposed unused exports\n    /** @type {Set<string>} */\n    const unusedExports = new Set();\n    const rootInfo = /** @type {ConcatenatedModuleInfo} */\n    moduleToInfoMap.get(this.rootModule);\n    const strictHarmonyModule = /** @type {BuildMeta} */\n    rootInfo.module.buildMeta.strictHarmonyModule;\n    const exportsInfo = moduleGraph.getExportsInfo(rootInfo.module);\n    /** @type {Record<string, string>} */\n    const exportsFinalName = {};\n    for (const exportInfo of exportsInfo.orderedExports) {\n      const name = exportInfo.name;\n      if (exportInfo.provided === false) continue;\n      const used = exportInfo.getUsedName(undefined, runtime);\n      if (!used) {\n        unusedExports.add(name);\n        continue;\n      }\n      exportsMap.set(used, requestShortener => {\n        try {\n          const finalName = getFinalName(moduleGraph, rootInfo, [name], moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, false, false, strictHarmonyModule, true);\n          exportsFinalName[used] = finalName;\n          return `/* ${exportInfo.isReexport() ? \"reexport\" : \"binding\"} */ ${finalName}`;\n        } catch (err) {\n          /** @type {Error} */\n          err.message += `\\nwhile generating the root export '${name}' (used name: '${used}')`;\n          throw err;\n        }\n      });\n    }\n    const result = new ConcatSource();\n\n    // add harmony compatibility flag (must be first because of possible circular dependencies)\n    let shouldAddHarmonyFlag = false;\n    if (moduleGraph.getExportsInfo(this).otherExportsInfo.getUsed(runtime) !== UsageState.Unused) {\n      shouldAddHarmonyFlag = true;\n    }\n\n    // define exports\n    if (exportsMap.size > 0) {\n      const {\n        exportsDefinitions\n      } = ConcatenatedModule.getCompilationHooks(/** @type {Compilation} */this.compilation);\n      const definitions = [];\n      for (const [key, value] of exportsMap) {\n        definitions.push(`\\n  ${propertyName(key)}: ${runtimeTemplate.returningFunction(value(requestShortener))}`);\n      }\n      const shouldSkipRenderDefinitions = exportsDefinitions.call(exportsFinalName);\n      if (!shouldSkipRenderDefinitions) {\n        runtimeRequirements.add(RuntimeGlobals.exports);\n        runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);\n        if (shouldAddHarmonyFlag) {\n          result.add(\"// ESM COMPAT FLAG\\n\");\n          result.add(runtimeTemplate.defineEsModuleFlagStatement({\n            exportsArgument: this.exportsArgument,\n            runtimeRequirements\n          }));\n        }\n        result.add(\"\\n// EXPORTS\\n\");\n        result.add(`${RuntimeGlobals.definePropertyGetters}(${this.exportsArgument}, {${definitions.join(\",\")}\\n});\\n`);\n      } else {\n        /** @type {BuildMeta} */\n        this.buildMeta.exportsFinalName = exportsFinalName;\n      }\n    }\n\n    // list unused exports\n    if (unusedExports.size > 0) {\n      result.add(`\\n// UNUSED EXPORTS: ${joinIterableWithComma(unusedExports)}\\n`);\n    }\n\n    // generate namespace objects\n    const namespaceObjectSources = new Map();\n    for (const info of neededNamespaceObjects) {\n      if (info.namespaceExportSymbol) continue;\n      const nsObj = [];\n      const exportsInfo = moduleGraph.getExportsInfo(info.module);\n      for (const exportInfo of exportsInfo.orderedExports) {\n        if (exportInfo.provided === false) continue;\n        const usedName = exportInfo.getUsedName(undefined, runtime);\n        if (usedName) {\n          const finalName = getFinalName(moduleGraph, info, [exportInfo.name], moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, false, undefined, /** @type {BuildMeta} */\n          info.module.buildMeta.strictHarmonyModule, true);\n          nsObj.push(`\\n  ${propertyName(usedName)}: ${runtimeTemplate.returningFunction(finalName)}`);\n        }\n      }\n      const name = info.namespaceObjectName;\n      const defineGetters = nsObj.length > 0 ? `${RuntimeGlobals.definePropertyGetters}(${name}, {${nsObj.join(\",\")}\\n});\\n` : \"\";\n      if (nsObj.length > 0) runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);\n      namespaceObjectSources.set(info, `\n// NAMESPACE OBJECT: ${info.module.readableIdentifier(requestShortener)}\nvar ${name} = {};\n${RuntimeGlobals.makeNamespaceObject}(${name});\n${defineGetters}`);\n      runtimeRequirements.add(RuntimeGlobals.makeNamespaceObject);\n    }\n\n    // define required namespace objects (must be before evaluation modules)\n    for (const info of modulesWithInfo) {\n      if (info.type === \"concatenated\") {\n        const source = namespaceObjectSources.get(info);\n        if (!source) continue;\n        result.add(source);\n      }\n    }\n    const chunkInitFragments = [];\n\n    // evaluate modules in order\n    for (const rawInfo of modulesWithInfo) {\n      let name;\n      let isConditional = false;\n      const info = rawInfo.type === \"reference\" ? rawInfo.target : rawInfo;\n      switch (info.type) {\n        case \"concatenated\":\n          {\n            result.add(`\\n;// ${info.module.readableIdentifier(requestShortener)}\\n`);\n            result.add(/** @type {ReplaceSource} */info.source);\n            if (info.chunkInitFragments) {\n              for (const f of info.chunkInitFragments) chunkInitFragments.push(f);\n            }\n            if (info.runtimeRequirements) {\n              for (const r of info.runtimeRequirements) {\n                runtimeRequirements.add(r);\n              }\n            }\n            name = info.namespaceObjectName;\n            break;\n          }\n        case \"external\":\n          {\n            result.add(`\\n// EXTERNAL MODULE: ${info.module.readableIdentifier(requestShortener)}\\n`);\n            runtimeRequirements.add(RuntimeGlobals.require);\n            const {\n              runtimeCondition\n            } = /** @type {ExternalModuleInfo | ReferenceToModuleInfo} */rawInfo;\n            const condition = runtimeTemplate.runtimeConditionExpression({\n              chunkGraph,\n              runtimeCondition,\n              runtime,\n              runtimeRequirements\n            });\n            if (condition !== \"true\") {\n              isConditional = true;\n              result.add(`if (${condition}) {\\n`);\n            }\n            result.add(`var ${info.name} = ${RuntimeGlobals.require}(${JSON.stringify(chunkGraph.getModuleId(info.module))});`);\n            name = info.name;\n            break;\n          }\n        default:\n          // @ts-expect-error never is expected here\n          throw new Error(`Unsupported concatenation entry type ${info.type}`);\n      }\n      if (info.interopNamespaceObjectUsed) {\n        runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject);\n        result.add(`\\nvar ${info.interopNamespaceObjectName} = /*#__PURE__*/${RuntimeGlobals.createFakeNamespaceObject}(${name}, 2);`);\n      }\n      if (info.interopNamespaceObject2Used) {\n        runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject);\n        result.add(`\\nvar ${info.interopNamespaceObject2Name} = /*#__PURE__*/${RuntimeGlobals.createFakeNamespaceObject}(${name});`);\n      }\n      if (info.interopDefaultAccessUsed) {\n        runtimeRequirements.add(RuntimeGlobals.compatGetDefaultExport);\n        result.add(`\\nvar ${info.interopDefaultAccessName} = /*#__PURE__*/${RuntimeGlobals.compatGetDefaultExport}(${name});`);\n      }\n      if (isConditional) {\n        result.add(\"\\n}\");\n      }\n    }\n    const data = new Map();\n    if (chunkInitFragments.length > 0) data.set(\"chunkInitFragments\", chunkInitFragments);\n    data.set(\"topLevelDeclarations\", topLevelDeclarations);\n\n    /** @type {CodeGenerationResult} */\n    const resultEntry = {\n      sources: new Map([[\"javascript\", new CachedSource(result)]]),\n      data,\n      runtimeRequirements\n    };\n    return resultEntry;\n  }\n\n  /**\n   * @param {Map<Module, ModuleInfo>} modulesMap modulesMap\n   * @param {ModuleInfo} info info\n   * @param {DependencyTemplates} dependencyTemplates dependencyTemplates\n   * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate\n   * @param {ModuleGraph} moduleGraph moduleGraph\n   * @param {ChunkGraph} chunkGraph chunkGraph\n   * @param {RuntimeSpec} runtime runtime\n   * @param {CodeGenerationResults} codeGenerationResults codeGenerationResults\n   */\n  _analyseModule(modulesMap, info, dependencyTemplates, runtimeTemplate, moduleGraph, chunkGraph, runtime, codeGenerationResults) {\n    if (info.type === \"concatenated\") {\n      const m = info.module;\n      try {\n        // Create a concatenation scope to track and capture information\n        const concatenationScope = new ConcatenationScope(modulesMap, info);\n\n        // TODO cache codeGeneration results\n        const codeGenResult = m.codeGeneration({\n          dependencyTemplates,\n          runtimeTemplate,\n          moduleGraph,\n          chunkGraph,\n          runtime,\n          concatenationScope,\n          codeGenerationResults,\n          sourceTypes: JS_TYPES\n        });\n        const source = /** @type {Source} */\n        codeGenResult.sources.get(\"javascript\");\n        const data = codeGenResult.data;\n        const chunkInitFragments = data && data.get(\"chunkInitFragments\");\n        const code = source.source().toString();\n        let ast;\n        try {\n          ast = JavascriptParser._parse(code, {\n            sourceType: \"module\"\n          });\n        } catch (_err) {\n          const err = /** @type {TODO} */_err;\n          if (err.loc && typeof err.loc === \"object\" && typeof err.loc.line === \"number\") {\n            const lineNumber = err.loc.line;\n            const lines = code.split(\"\\n\");\n            err.message += `\\n| ${lines.slice(Math.max(0, lineNumber - 3), lineNumber + 2).join(\"\\n| \")}`;\n          }\n          throw err;\n        }\n        const scopeManager = eslintScope.analyze(ast, {\n          ecmaVersion: 6,\n          sourceType: \"module\",\n          optimistic: true,\n          ignoreEval: true,\n          impliedStrict: true\n        });\n        const globalScope = /** @type {Scope} */scopeManager.acquire(ast);\n        const moduleScope = globalScope.childScopes[0];\n        const resultSource = new ReplaceSource(source);\n        info.runtimeRequirements = /** @type {ReadOnlyRuntimeRequirements} */\n        codeGenResult.runtimeRequirements;\n        info.ast = ast;\n        info.internalSource = source;\n        info.source = resultSource;\n        info.chunkInitFragments = chunkInitFragments;\n        info.globalScope = globalScope;\n        info.moduleScope = moduleScope;\n      } catch (err) {\n        /** @type {Error} */\n        err.message += `\\nwhile analyzing module ${m.identifier()} for concatenation`;\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {[ModuleInfoOrReference[], Map<Module, ModuleInfo>]} module info items\n   */\n  _getModulesWithInfo(moduleGraph, runtime) {\n    const orderedConcatenationList = this._createConcatenationList(this.rootModule, this._modules, runtime, moduleGraph);\n    /** @type {Map<Module, ModuleInfo>} */\n    const map = new Map();\n    const list = orderedConcatenationList.map((info, index) => {\n      let item = map.get(info.module);\n      if (item === undefined) {\n        switch (info.type) {\n          case \"concatenated\":\n            item = {\n              type: \"concatenated\",\n              module: info.module,\n              index,\n              ast: undefined,\n              internalSource: undefined,\n              runtimeRequirements: undefined,\n              source: undefined,\n              globalScope: undefined,\n              moduleScope: undefined,\n              internalNames: new Map(),\n              exportMap: undefined,\n              rawExportMap: undefined,\n              namespaceExportSymbol: undefined,\n              namespaceObjectName: undefined,\n              interopNamespaceObjectUsed: false,\n              interopNamespaceObjectName: undefined,\n              interopNamespaceObject2Used: false,\n              interopNamespaceObject2Name: undefined,\n              interopDefaultAccessUsed: false,\n              interopDefaultAccessName: undefined\n            };\n            break;\n          case \"external\":\n            item = {\n              type: \"external\",\n              module: info.module,\n              runtimeCondition: info.runtimeCondition,\n              index,\n              name: undefined,\n              interopNamespaceObjectUsed: false,\n              interopNamespaceObjectName: undefined,\n              interopNamespaceObject2Used: false,\n              interopNamespaceObject2Name: undefined,\n              interopDefaultAccessUsed: false,\n              interopDefaultAccessName: undefined\n            };\n            break;\n          default:\n            throw new Error(`Unsupported concatenation entry type ${info.type}`);\n        }\n        map.set(/** @type {ModuleInfo} */item.module, /** @type {ModuleInfo} */item);\n        return /** @type {ModuleInfo} */item;\n      }\n      /** @type {ReferenceToModuleInfo} */\n      const ref = {\n        type: \"reference\",\n        runtimeCondition: info.runtimeCondition,\n        target: item\n      };\n      return ref;\n    });\n    return [list, map];\n  }\n\n  /**\n   * @param {Hash} hash the hash used to track dependencies\n   * @param {UpdateHashContext} context context\n   * @returns {void}\n   */\n  updateHash(hash, context) {\n    const {\n      chunkGraph,\n      runtime\n    } = context;\n    for (const info of this._createConcatenationList(this.rootModule, this._modules, intersectRuntime(runtime, this._runtime), chunkGraph.moduleGraph)) {\n      switch (info.type) {\n        case \"concatenated\":\n          info.module.updateHash(hash, context);\n          break;\n        case \"external\":\n          hash.update(`${chunkGraph.getModuleId(info.module)}`);\n          // TODO runtimeCondition\n          break;\n      }\n    }\n    super.updateHash(hash, context);\n  }\n\n  /**\n   * @param {ObjectDeserializerContext} context context\n   * @returns {ConcatenatedModule} ConcatenatedModule\n   */\n  static deserialize(context) {\n    const obj = new ConcatenatedModule({\n      identifier: (/** @type {EXPECTED_ANY} */undefined),\n      rootModule: (/** @type {EXPECTED_ANY} */undefined),\n      modules: (/** @type {EXPECTED_ANY} */undefined),\n      runtime: undefined,\n      compilation: (/** @type {EXPECTED_ANY} */undefined)\n    });\n    obj.deserialize(context);\n    return obj;\n  }\n}\nmakeSerializable(ConcatenatedModule, \"webpack/lib/optimize/ConcatenatedModule\");\nmodule.exports = ConcatenatedModule;","map":{"version":3,"names":["eslintScope","require","Referencer","SyncBailHook","CachedSource","ConcatSource","ReplaceSource","ConcatenationScope","UsageState","Module","JS_TYPES","JAVASCRIPT_MODULE_TYPE_ESM","RuntimeGlobals","Template","HarmonyImportDependency","JavascriptParser","equals","LazySet","concatComparators","RESERVED_NAMES","findNewName","addScopeSymbols","getAllReferences","getPathInAst","getUsedNamesInScopeInfo","createHash","makePathsRelative","makeSerializable","propertyAccess","propertyName","filterRuntime","intersectRuntime","mergeRuntimeCondition","mergeRuntimeConditionNonFalse","runtimeConditionToString","subtractRuntimeCondition","ReferencerClass","prototype","PropertyDefinition","Property","createComparator","property","comparator","a","b","compareNumbers","Number","isNaN","bySourceOrder","byRangeStart","joinIterableWithComma","iterable","str","first","item","getFinalBinding","moduleGraph","info","exportName","moduleToInfoMap","runtime","requestShortener","runtimeTemplate","neededNamespaceObjects","asCall","strictHarmonyModule","asiSafe","alreadyVisited","Set","exportsType","module","getExportsType","length","interopNamespaceObject2Used","rawName","interopNamespaceObject2Name","ids","interopNamespaceObjectUsed","interopNamespaceObjectName","Error","slice","exportId","interopDefaultAccessUsed","defaultExport","interopDefaultAccessName","type","add","namespaceObjectName","name","exportsInfo","getExportsInfo","exportInfo","getExportInfo","has","provided","directExport","exportMap","get","usedName","getUsedName","rawExport","rawExportMap","reexport","findTarget","readableIdentifier","Array","from","m","join","refInfo","export","buildMeta","namespaceExportSymbol","used","comment","toNormalComment","getFinalName","callContext","binding","reference","isPropertyAccess","internalNames","symbol","compilationHooksMap","WeakMap","ConcatenatedModule","create","rootModule","modules","compilation","associatedObjectForCache","hashFunction","identifier","_createIdentifier","getCompilationHooks","hooks","undefined","exportsDefinitions","set","constructor","layer","_identifier","_modules","_runtime","factoryMeta","updateCacheModule","getSourceTypes","size","libIdent","options","nameForCondition","getSideEffectsConnectionState","build","resolver","fs","callback","moduleArgument","exportsArgument","buildInfo","strict","cacheable","fileDependencies","contextDependencies","missingDependencies","topLevelDeclarations","assets","clearDependenciesAndBlocks","clearWarningsAndErrors","d","dependencies","filter","dep","getModule","push","blocks","warnings","getWarnings","warning","addWarning","errors","getErrors","error","addError","assetsInfo","decl","Object","assign","Map","key","value","_createConcatenationList","modulesSet","list","existingEntries","getConcatenatedImports","connections","getOutgoingConnections","c","references","connection","dependency","resolvedOriginModule","isTargetActive","map","sourceOrder","rangeStart","range","sort","referencesMap","runtimeCondition","r","entry","values","enterModule","existingEntry","imports","reducedRuntimeCondition","lastItem","cachedMakePathsRelative","bindContextCache","context","identifiers","hash","update","digest","addCacheDependencies","buildDependencies","codeGeneration","dependencyTemplates","chunkGraph","generationRuntime","codeGenerationResults","runtimeRequirements","modulesWithInfo","_getModulesWithInfo","_analyseModule","allUsedNames","usedNamesInScopeInfo","ignoredScopes","moduleScope","superClassCache","getSuperClassExpressions","scope","cacheEntry","superClassExpressions","childScope","childScopes","block","superClass","variables","globalScope","through","isModuleReference","match","matchModuleReference","referencedInfo","index","usedNames","alreadyCheckedScopes","expr","variable","namespaceObjectUsedNames","ref","newName","source","allIdentifiers","concat","path","ast","maybeProperty","left","shorthand","insert","replace","externalName","externalNameInterop","defaultObject","finalName","call","directImport","exportsMap","unusedExports","rootInfo","exportsFinalName","orderedExports","isReexport","err","message","result","shouldAddHarmonyFlag","otherExportsInfo","getUsed","Unused","definitions","returningFunction","shouldSkipRenderDefinitions","exports","definePropertyGetters","defineEsModuleFlagStatement","namespaceObjectSources","nsObj","defineGetters","makeNamespaceObject","chunkInitFragments","rawInfo","isConditional","target","f","condition","runtimeConditionExpression","JSON","stringify","getModuleId","createFakeNamespaceObject","compatGetDefaultExport","data","resultEntry","sources","modulesMap","concatenationScope","codeGenResult","sourceTypes","code","toString","_parse","sourceType","_err","loc","line","lineNumber","lines","split","Math","max","scopeManager","analyze","ecmaVersion","optimistic","ignoreEval","impliedStrict","acquire","resultSource","internalSource","orderedConcatenationList","updateHash","deserialize","obj"],"sources":["/home/wickliff/Desktop/dev-waki/portfolio2/node_modules/webpack/lib/optimize/ConcatenatedModule.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst eslintScope = require(\"eslint-scope\");\nconst Referencer = require(\"eslint-scope/lib/referencer\");\nconst { SyncBailHook } = require(\"tapable\");\nconst {\n\tCachedSource,\n\tConcatSource,\n\tReplaceSource\n} = require(\"webpack-sources\");\nconst ConcatenationScope = require(\"../ConcatenationScope\");\nconst { UsageState } = require(\"../ExportsInfo\");\nconst Module = require(\"../Module\");\nconst { JS_TYPES } = require(\"../ModuleSourceTypesConstants\");\nconst { JAVASCRIPT_MODULE_TYPE_ESM } = require(\"../ModuleTypeConstants\");\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst Template = require(\"../Template\");\nconst HarmonyImportDependency = require(\"../dependencies/HarmonyImportDependency\");\nconst JavascriptParser = require(\"../javascript/JavascriptParser\");\nconst { equals } = require(\"../util/ArrayHelpers\");\nconst LazySet = require(\"../util/LazySet\");\nconst { concatComparators } = require(\"../util/comparators\");\nconst {\n\tRESERVED_NAMES,\n\tfindNewName,\n\taddScopeSymbols,\n\tgetAllReferences,\n\tgetPathInAst,\n\tgetUsedNamesInScopeInfo\n} = require(\"../util/concatenate\");\nconst createHash = require(\"../util/createHash\");\nconst { makePathsRelative } = require(\"../util/identifier\");\nconst makeSerializable = require(\"../util/makeSerializable\");\nconst propertyAccess = require(\"../util/propertyAccess\");\nconst { propertyName } = require(\"../util/propertyName\");\nconst {\n\tfilterRuntime,\n\tintersectRuntime,\n\tmergeRuntimeCondition,\n\tmergeRuntimeConditionNonFalse,\n\truntimeConditionToString,\n\tsubtractRuntimeCondition\n} = require(\"../util/runtime\");\n\n/** @typedef {import(\"eslint-scope\").Reference} Reference */\n/** @typedef {import(\"eslint-scope\").Scope} Scope */\n/** @typedef {import(\"eslint-scope\").Variable} Variable */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../../declarations/WebpackOptions\").WebpackOptionsNormalized} WebpackOptions */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../CodeGenerationResults\")} CodeGenerationResults */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../Dependency\").UpdateHashContext} UpdateHashContext */\n/** @typedef {import(\"../DependencyTemplate\").DependencyTemplateContext} DependencyTemplateContext */\n/** @typedef {import(\"../DependencyTemplates\")} DependencyTemplates */\n/** @typedef {import(\"../ExportsInfo\").ExportInfo} ExportInfo */\n/** @typedef {import(\"../Module\").BuildInfo} BuildInfo */\n/** @typedef {import(\"../Module\").BuildMeta} BuildMeta */\n/** @typedef {import(\"../Module\").CodeGenerationContext} CodeGenerationContext */\n/** @typedef {import(\"../Module\").CodeGenerationResult} CodeGenerationResult */\n/** @typedef {import(\"../Module\").LibIdentOptions} LibIdentOptions */\n/** @typedef {import(\"../Module\").ReadOnlyRuntimeRequirements} ReadOnlyRuntimeRequirements */\n/** @typedef {import(\"../Module\").RuntimeRequirements} RuntimeRequirements */\n/** @typedef {import(\"../Module\").SourceTypes} SourceTypes */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n/** @typedef {import(\"../ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"../ModuleParseError\")} ModuleParseError */\n/** @typedef {import(\"../RequestShortener\")} RequestShortener */\n/** @typedef {import(\"../ResolverFactory\").ResolverWithOptions} ResolverWithOptions */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"../WebpackError\")} WebpackError */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").ChunkRenderContext} ChunkRenderContext */\n/** @typedef {import(\"../javascript/JavascriptParser\").Program} Program */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n/** @typedef {import(\"../serialization/ObjectMiddleware\").ObjectDeserializerContext} ObjectDeserializerContext */\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @typedef {typeof import(\"../util/Hash\")} HashConstructor */\n/** @typedef {import(\"../util/concatenate\").UsedNames} UsedNames */\n/** @typedef {import(\"../util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @template T\n * @typedef {import(\"../InitFragment\")<T>} InitFragment\n */\n\n/**\n * @template T\n * @typedef {import(\"../util/comparators\").Comparator<T>} Comparator\n */\n\n// fix eslint-scope to support class properties correctly\n// cspell:word Referencer\nconst ReferencerClass = /** @type {any} */ (Referencer);\nif (!ReferencerClass.prototype.PropertyDefinition) {\n\tReferencerClass.prototype.PropertyDefinition =\n\t\tReferencerClass.prototype.Property;\n}\n\n/**\n * @typedef {object} ReexportInfo\n * @property {Module} module\n * @property {string[]} export\n */\n\n/** @typedef {RawBinding | SymbolBinding} Binding */\n\n/**\n * @typedef {object} RawBinding\n * @property {ModuleInfo} info\n * @property {string} rawName\n * @property {string=} comment\n * @property {string[]} ids\n * @property {string[]} exportName\n */\n\n/**\n * @typedef {object} SymbolBinding\n * @property {ConcatenatedModuleInfo} info\n * @property {string} name\n * @property {string=} comment\n * @property {string[]} ids\n * @property {string[]} exportName\n */\n\n/** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo } ModuleInfo */\n/** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo | ReferenceToModuleInfo } ModuleInfoOrReference */\n\n/**\n * @typedef {object} ConcatenatedModuleInfo\n * @property {\"concatenated\"} type\n * @property {Module} module\n * @property {number} index\n * @property {Program | undefined} ast\n * @property {Source | undefined} internalSource\n * @property {ReplaceSource | undefined} source\n * @property {InitFragment<ChunkRenderContext>[]=} chunkInitFragments\n * @property {ReadOnlyRuntimeRequirements | undefined} runtimeRequirements\n * @property {Scope | undefined} globalScope\n * @property {Scope | undefined} moduleScope\n * @property {Map<string, string>} internalNames\n * @property {Map<string, string> | undefined} exportMap\n * @property {Map<string, string> | undefined} rawExportMap\n * @property {string=} namespaceExportSymbol\n * @property {string | undefined} namespaceObjectName\n * @property {boolean} interopNamespaceObjectUsed\n * @property {string | undefined} interopNamespaceObjectName\n * @property {boolean} interopNamespaceObject2Used\n * @property {string | undefined} interopNamespaceObject2Name\n * @property {boolean} interopDefaultAccessUsed\n * @property {string | undefined} interopDefaultAccessName\n */\n\n/**\n * @typedef {object} ExternalModuleInfo\n * @property {\"external\"} type\n * @property {Module} module\n * @property {RuntimeSpec | boolean} runtimeCondition\n * @property {number} index\n * @property {string | undefined} name\n * @property {boolean} interopNamespaceObjectUsed\n * @property {string | undefined} interopNamespaceObjectName\n * @property {boolean} interopNamespaceObject2Used\n * @property {string | undefined} interopNamespaceObject2Name\n * @property {boolean} interopDefaultAccessUsed\n * @property {string | undefined} interopDefaultAccessName\n */\n\n/**\n * @typedef {object} ReferenceToModuleInfo\n * @property {\"reference\"} type\n * @property {RuntimeSpec | boolean} runtimeCondition\n * @property {ModuleInfo} target\n */\n\n/**\n * @template T\n * @param {string} property property\n * @param {function(T[keyof T], T[keyof T]): 0 | 1 | -1} comparator comparator\n * @returns {Comparator<T>} comparator\n */\n\nconst createComparator = (property, comparator) => (a, b) =>\n\tcomparator(\n\t\ta[/** @type {keyof T} */ (property)],\n\t\tb[/** @type {keyof T} */ (property)]\n\t);\n\n/**\n * @param {number} a a\n * @param {number} b b\n * @returns {0 | 1 | -1} result\n */\nconst compareNumbers = (a, b) => {\n\tif (Number.isNaN(a)) {\n\t\tif (!Number.isNaN(b)) {\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tif (Number.isNaN(b)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (a !== b) {\n\t\t\treturn a < b ? -1 : 1;\n\t\t}\n\t}\n\treturn 0;\n};\nconst bySourceOrder = createComparator(\"sourceOrder\", compareNumbers);\nconst byRangeStart = createComparator(\"rangeStart\", compareNumbers);\n\n/**\n * @param {Iterable<string>} iterable iterable object\n * @returns {string} joined iterable object\n */\nconst joinIterableWithComma = iterable => {\n\t// This is more performant than Array.from().join(\", \")\n\t// as it doesn't create an array\n\tlet str = \"\";\n\tlet first = true;\n\tfor (const item of iterable) {\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t} else {\n\t\t\tstr += \", \";\n\t\t}\n\t\tstr += item;\n\t}\n\treturn str;\n};\n\n/**\n * @typedef {object} ConcatenationEntry\n * @property {\"concatenated\" | \"external\"} type\n * @property {Module} module\n * @property {RuntimeSpec | boolean} runtimeCondition\n */\n\n/**\n * @param {ModuleGraph} moduleGraph the module graph\n * @param {ModuleInfo} info module info\n * @param {string[]} exportName exportName\n * @param {Map<Module, ModuleInfo>} moduleToInfoMap moduleToInfoMap\n * @param {RuntimeSpec} runtime for which runtime\n * @param {RequestShortener} requestShortener the request shortener\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {Set<ConcatenatedModuleInfo>} neededNamespaceObjects modules for which a namespace object should be generated\n * @param {boolean} asCall asCall\n * @param {boolean | undefined} strictHarmonyModule strictHarmonyModule\n * @param {boolean | undefined} asiSafe asiSafe\n * @param {Set<ExportInfo>} alreadyVisited alreadyVisited\n * @returns {Binding} the final variable\n */\nconst getFinalBinding = (\n\tmoduleGraph,\n\tinfo,\n\texportName,\n\tmoduleToInfoMap,\n\truntime,\n\trequestShortener,\n\truntimeTemplate,\n\tneededNamespaceObjects,\n\tasCall,\n\tstrictHarmonyModule,\n\tasiSafe,\n\talreadyVisited = new Set()\n) => {\n\tconst exportsType = info.module.getExportsType(\n\t\tmoduleGraph,\n\t\tstrictHarmonyModule\n\t);\n\tif (exportName.length === 0) {\n\t\tswitch (exportsType) {\n\t\t\tcase \"default-only\":\n\t\t\t\tinfo.interopNamespaceObject2Used = true;\n\t\t\t\treturn {\n\t\t\t\t\tinfo,\n\t\t\t\t\trawName: /** @type {string} */ (info.interopNamespaceObject2Name),\n\t\t\t\t\tids: exportName,\n\t\t\t\t\texportName\n\t\t\t\t};\n\t\t\tcase \"default-with-named\":\n\t\t\t\tinfo.interopNamespaceObjectUsed = true;\n\t\t\t\treturn {\n\t\t\t\t\tinfo,\n\t\t\t\t\trawName: /** @type {string} */ (info.interopNamespaceObjectName),\n\t\t\t\t\tids: exportName,\n\t\t\t\t\texportName\n\t\t\t\t};\n\t\t\tcase \"namespace\":\n\t\t\tcase \"dynamic\":\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected exportsType ${exportsType}`);\n\t\t}\n\t} else {\n\t\tswitch (exportsType) {\n\t\t\tcase \"namespace\":\n\t\t\t\tbreak;\n\t\t\tcase \"default-with-named\":\n\t\t\t\tswitch (exportName[0]) {\n\t\t\t\t\tcase \"default\":\n\t\t\t\t\t\texportName = exportName.slice(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"__esModule\":\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\trawName: \"/* __esModule */true\",\n\t\t\t\t\t\t\tids: exportName.slice(1),\n\t\t\t\t\t\t\texportName\n\t\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"default-only\": {\n\t\t\t\tconst exportId = exportName[0];\n\t\t\t\tif (exportId === \"__esModule\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\trawName: \"/* __esModule */true\",\n\t\t\t\t\t\tids: exportName.slice(1),\n\t\t\t\t\t\texportName\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\texportName = exportName.slice(1);\n\t\t\t\tif (exportId !== \"default\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\trawName:\n\t\t\t\t\t\t\t\"/* non-default import from default-exporting module */undefined\",\n\t\t\t\t\t\tids: exportName,\n\t\t\t\t\t\texportName\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"dynamic\":\n\t\t\t\tswitch (exportName[0]) {\n\t\t\t\t\tcase \"default\": {\n\t\t\t\t\t\texportName = exportName.slice(1);\n\t\t\t\t\t\tinfo.interopDefaultAccessUsed = true;\n\t\t\t\t\t\tconst defaultExport = asCall\n\t\t\t\t\t\t\t? `${info.interopDefaultAccessName}()`\n\t\t\t\t\t\t\t: asiSafe\n\t\t\t\t\t\t\t\t? `(${info.interopDefaultAccessName}())`\n\t\t\t\t\t\t\t\t: asiSafe === false\n\t\t\t\t\t\t\t\t\t? `;(${info.interopDefaultAccessName}())`\n\t\t\t\t\t\t\t\t\t: `${info.interopDefaultAccessName}.a`;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\trawName: defaultExport,\n\t\t\t\t\t\t\tids: exportName,\n\t\t\t\t\t\t\texportName\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tcase \"__esModule\":\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\trawName: \"/* __esModule */true\",\n\t\t\t\t\t\t\tids: exportName.slice(1),\n\t\t\t\t\t\t\texportName\n\t\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected exportsType ${exportsType}`);\n\t\t}\n\t}\n\tif (exportName.length === 0) {\n\t\tswitch (info.type) {\n\t\t\tcase \"concatenated\":\n\t\t\t\tneededNamespaceObjects.add(info);\n\t\t\t\treturn {\n\t\t\t\t\tinfo,\n\t\t\t\t\trawName:\n\t\t\t\t\t\t/** @type {NonNullable<ConcatenatedModuleInfo[\"namespaceObjectName\"]>} */\n\t\t\t\t\t\t(info.namespaceObjectName),\n\t\t\t\t\tids: exportName,\n\t\t\t\t\texportName\n\t\t\t\t};\n\t\t\tcase \"external\":\n\t\t\t\treturn {\n\t\t\t\t\tinfo,\n\t\t\t\t\trawName:\n\t\t\t\t\t\t/** @type {NonNullable<ExternalModuleInfo[\"name\"]>} */\n\t\t\t\t\t\t(info.name),\n\t\t\t\t\tids: exportName,\n\t\t\t\t\texportName\n\t\t\t\t};\n\t\t}\n\t}\n\tconst exportsInfo = moduleGraph.getExportsInfo(info.module);\n\tconst exportInfo = exportsInfo.getExportInfo(exportName[0]);\n\tif (alreadyVisited.has(exportInfo)) {\n\t\treturn {\n\t\t\tinfo,\n\t\t\trawName: \"/* circular reexport */ Object(function x() { x() }())\",\n\t\t\tids: [],\n\t\t\texportName\n\t\t};\n\t}\n\talreadyVisited.add(exportInfo);\n\tswitch (info.type) {\n\t\tcase \"concatenated\": {\n\t\t\tconst exportId = exportName[0];\n\t\t\tif (exportInfo.provided === false) {\n\t\t\t\t// It's not provided, but it could be on the prototype\n\t\t\t\tneededNamespaceObjects.add(info);\n\t\t\t\treturn {\n\t\t\t\t\tinfo,\n\t\t\t\t\trawName: /** @type {string} */ (info.namespaceObjectName),\n\t\t\t\t\tids: exportName,\n\t\t\t\t\texportName\n\t\t\t\t};\n\t\t\t}\n\t\t\tconst directExport = info.exportMap && info.exportMap.get(exportId);\n\t\t\tif (directExport) {\n\t\t\t\tconst usedName = /** @type {string[]} */ (\n\t\t\t\t\texportsInfo.getUsedName(exportName, runtime)\n\t\t\t\t);\n\t\t\t\tif (!usedName) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\trawName: \"/* unused export */ undefined\",\n\t\t\t\t\t\tids: exportName.slice(1),\n\t\t\t\t\t\texportName\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tinfo,\n\t\t\t\t\tname: directExport,\n\t\t\t\t\tids: usedName.slice(1),\n\t\t\t\t\texportName\n\t\t\t\t};\n\t\t\t}\n\t\t\tconst rawExport = info.rawExportMap && info.rawExportMap.get(exportId);\n\t\t\tif (rawExport) {\n\t\t\t\treturn {\n\t\t\t\t\tinfo,\n\t\t\t\t\trawName: rawExport,\n\t\t\t\t\tids: exportName.slice(1),\n\t\t\t\t\texportName\n\t\t\t\t};\n\t\t\t}\n\t\t\tconst reexport = exportInfo.findTarget(moduleGraph, module =>\n\t\t\t\tmoduleToInfoMap.has(module)\n\t\t\t);\n\t\t\tif (reexport === false) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Target module of reexport from '${info.module.readableIdentifier(\n\t\t\t\t\t\trequestShortener\n\t\t\t\t\t)}' is not part of the concatenation (export '${exportId}')\\nModules in the concatenation:\\n${Array.from(\n\t\t\t\t\t\tmoduleToInfoMap,\n\t\t\t\t\t\t([m, info]) =>\n\t\t\t\t\t\t\t` * ${info.type} ${m.readableIdentifier(requestShortener)}`\n\t\t\t\t\t).join(\"\\n\")}`\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (reexport) {\n\t\t\t\tconst refInfo = moduleToInfoMap.get(reexport.module);\n\t\t\t\treturn getFinalBinding(\n\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t/** @type {ModuleInfo} */ (refInfo),\n\t\t\t\t\treexport.export\n\t\t\t\t\t\t? [...reexport.export, ...exportName.slice(1)]\n\t\t\t\t\t\t: exportName.slice(1),\n\t\t\t\t\tmoduleToInfoMap,\n\t\t\t\t\truntime,\n\t\t\t\t\trequestShortener,\n\t\t\t\t\truntimeTemplate,\n\t\t\t\t\tneededNamespaceObjects,\n\t\t\t\t\tasCall,\n\t\t\t\t\t/** @type {BuildMeta} */\n\t\t\t\t\t(info.module.buildMeta).strictHarmonyModule,\n\t\t\t\t\tasiSafe,\n\t\t\t\t\talreadyVisited\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (info.namespaceExportSymbol) {\n\t\t\t\tconst usedName = /** @type {string[]} */ (\n\t\t\t\t\texportsInfo.getUsedName(exportName, runtime)\n\t\t\t\t);\n\t\t\t\treturn {\n\t\t\t\t\tinfo,\n\t\t\t\t\trawName: /** @type {string} */ (info.namespaceObjectName),\n\t\t\t\t\tids: usedName,\n\t\t\t\t\texportName\n\t\t\t\t};\n\t\t\t}\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot get final name for export '${exportName.join(\n\t\t\t\t\t\".\"\n\t\t\t\t)}' of ${info.module.readableIdentifier(requestShortener)}`\n\t\t\t);\n\t\t}\n\n\t\tcase \"external\": {\n\t\t\tconst used = /** @type {string[]} */ (\n\t\t\t\texportsInfo.getUsedName(exportName, runtime)\n\t\t\t);\n\t\t\tif (!used) {\n\t\t\t\treturn {\n\t\t\t\t\tinfo,\n\t\t\t\t\trawName: \"/* unused export */ undefined\",\n\t\t\t\t\tids: exportName.slice(1),\n\t\t\t\t\texportName\n\t\t\t\t};\n\t\t\t}\n\t\t\tconst comment = equals(used, exportName)\n\t\t\t\t? \"\"\n\t\t\t\t: Template.toNormalComment(`${exportName.join(\".\")}`);\n\t\t\treturn { info, rawName: info.name + comment, ids: used, exportName };\n\t\t}\n\t}\n};\n\n/**\n * @param {ModuleGraph} moduleGraph the module graph\n * @param {ModuleInfo} info module info\n * @param {string[]} exportName exportName\n * @param {Map<Module, ModuleInfo>} moduleToInfoMap moduleToInfoMap\n * @param {RuntimeSpec} runtime for which runtime\n * @param {RequestShortener} requestShortener the request shortener\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {Set<ConcatenatedModuleInfo>} neededNamespaceObjects modules for which a namespace object should be generated\n * @param {boolean} asCall asCall\n * @param {boolean | undefined} callContext callContext\n * @param {boolean | undefined} strictHarmonyModule strictHarmonyModule\n * @param {boolean | undefined} asiSafe asiSafe\n * @returns {string} the final name\n */\nconst getFinalName = (\n\tmoduleGraph,\n\tinfo,\n\texportName,\n\tmoduleToInfoMap,\n\truntime,\n\trequestShortener,\n\truntimeTemplate,\n\tneededNamespaceObjects,\n\tasCall,\n\tcallContext,\n\tstrictHarmonyModule,\n\tasiSafe\n) => {\n\tconst binding = getFinalBinding(\n\t\tmoduleGraph,\n\t\tinfo,\n\t\texportName,\n\t\tmoduleToInfoMap,\n\t\truntime,\n\t\trequestShortener,\n\t\truntimeTemplate,\n\t\tneededNamespaceObjects,\n\t\tasCall,\n\t\tstrictHarmonyModule,\n\t\tasiSafe\n\t);\n\t{\n\t\tconst { ids, comment } = binding;\n\t\tlet reference;\n\t\tlet isPropertyAccess;\n\t\tif (\"rawName\" in binding) {\n\t\t\treference = `${binding.rawName}${comment || \"\"}${propertyAccess(ids)}`;\n\t\t\tisPropertyAccess = ids.length > 0;\n\t\t} else {\n\t\t\tconst { info, name: exportId } = binding;\n\t\t\tconst name = info.internalNames.get(exportId);\n\t\t\tif (!name) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`The export \"${exportId}\" in \"${info.module.readableIdentifier(\n\t\t\t\t\t\trequestShortener\n\t\t\t\t\t)}\" has no internal name (existing names: ${\n\t\t\t\t\t\tArray.from(\n\t\t\t\t\t\t\tinfo.internalNames,\n\t\t\t\t\t\t\t([name, symbol]) => `${name}: ${symbol}`\n\t\t\t\t\t\t).join(\", \") || \"none\"\n\t\t\t\t\t})`\n\t\t\t\t);\n\t\t\t}\n\t\t\treference = `${name}${comment || \"\"}${propertyAccess(ids)}`;\n\t\t\tisPropertyAccess = ids.length > 1;\n\t\t}\n\t\tif (isPropertyAccess && asCall && callContext === false) {\n\t\t\treturn asiSafe\n\t\t\t\t? `(0,${reference})`\n\t\t\t\t: asiSafe === false\n\t\t\t\t\t? `;(0,${reference})`\n\t\t\t\t\t: `/*#__PURE__*/Object(${reference})`;\n\t\t}\n\t\treturn reference;\n\t}\n};\n\n/**\n * @typedef {object} ConcatenateModuleHooks\n * @property {SyncBailHook<[Record<string, string>], boolean | void>} exportsDefinitions\n */\n\n/** @type {WeakMap<Compilation, ConcatenateModuleHooks>} */\nconst compilationHooksMap = new WeakMap();\n\nclass ConcatenatedModule extends Module {\n\t/**\n\t * @param {Module} rootModule the root module of the concatenation\n\t * @param {Set<Module>} modules all modules in the concatenation (including the root module)\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {Compilation} compilation the compilation\n\t * @param {object=} associatedObjectForCache object for caching\n\t * @param {string | HashConstructor=} hashFunction hash function to use\n\t * @returns {ConcatenatedModule} the module\n\t */\n\tstatic create(\n\t\trootModule,\n\t\tmodules,\n\t\truntime,\n\t\tcompilation,\n\t\tassociatedObjectForCache,\n\t\thashFunction = \"md4\"\n\t) {\n\t\tconst identifier = ConcatenatedModule._createIdentifier(\n\t\t\trootModule,\n\t\t\tmodules,\n\t\t\tassociatedObjectForCache,\n\t\t\thashFunction\n\t\t);\n\t\treturn new ConcatenatedModule({\n\t\t\tidentifier,\n\t\t\trootModule,\n\t\t\tmodules,\n\t\t\truntime,\n\t\t\tcompilation\n\t\t});\n\t}\n\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @returns {ConcatenateModuleHooks} the attached hooks\n\t */\n\tstatic getCompilationHooks(compilation) {\n\t\tlet hooks = compilationHooksMap.get(compilation);\n\t\tif (hooks === undefined) {\n\t\t\thooks = {\n\t\t\t\texportsDefinitions: new SyncBailHook([\"definitions\"])\n\t\t\t};\n\t\t\tcompilationHooksMap.set(compilation, hooks);\n\t\t}\n\t\treturn hooks;\n\t}\n\n\t/**\n\t * @param {object} options options\n\t * @param {string} options.identifier the identifier of the module\n\t * @param {Module} options.rootModule the root module of the concatenation\n\t * @param {RuntimeSpec} options.runtime the selected runtime\n\t * @param {Set<Module>} options.modules all concatenated modules\n\t * @param {Compilation} options.compilation the compilation\n\t */\n\tconstructor({ identifier, rootModule, modules, runtime, compilation }) {\n\t\tsuper(JAVASCRIPT_MODULE_TYPE_ESM, null, rootModule && rootModule.layer);\n\n\t\t// Info from Factory\n\t\t/** @type {string} */\n\t\tthis._identifier = identifier;\n\t\t/** @type {Module} */\n\t\tthis.rootModule = rootModule;\n\t\t/** @type {Set<Module>} */\n\t\tthis._modules = modules;\n\t\tthis._runtime = runtime;\n\t\tthis.factoryMeta = rootModule && rootModule.factoryMeta;\n\t\t/** @type {Compilation | undefined} */\n\t\tthis.compilation = compilation;\n\t}\n\n\t/**\n\t * Assuming this module is in the cache. Update the (cached) module with\n\t * the fresh module from the factory. Usually updates internal references\n\t * and properties.\n\t * @param {Module} module fresh module\n\t * @returns {void}\n\t */\n\tupdateCacheModule(module) {\n\t\tthrow new Error(\"Must not be called\");\n\t}\n\n\t/**\n\t * @returns {SourceTypes} types available (do not mutate)\n\t */\n\tgetSourceTypes() {\n\t\treturn JS_TYPES;\n\t}\n\n\tget modules() {\n\t\treturn Array.from(this._modules);\n\t}\n\n\t/**\n\t * @returns {string} a unique identifier of the module\n\t */\n\tidentifier() {\n\t\treturn this._identifier;\n\t}\n\n\t/**\n\t * @param {RequestShortener} requestShortener the request shortener\n\t * @returns {string} a user readable identifier of the module\n\t */\n\treadableIdentifier(requestShortener) {\n\t\treturn `${this.rootModule.readableIdentifier(\n\t\t\trequestShortener\n\t\t)} + ${this._modules.size - 1} modules`;\n\t}\n\n\t/**\n\t * @param {LibIdentOptions} options options\n\t * @returns {string | null} an identifier for library inclusion\n\t */\n\tlibIdent(options) {\n\t\treturn this.rootModule.libIdent(options);\n\t}\n\n\t/**\n\t * @returns {string | null} absolute path which should be used for condition matching (usually the resource path)\n\t */\n\tnameForCondition() {\n\t\treturn this.rootModule.nameForCondition();\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @returns {ConnectionState} how this module should be connected to referencing modules when consumed for side-effects only\n\t */\n\tgetSideEffectsConnectionState(moduleGraph) {\n\t\treturn this.rootModule.getSideEffectsConnectionState(moduleGraph);\n\t}\n\n\t/**\n\t * @param {WebpackOptions} options webpack options\n\t * @param {Compilation} compilation the compilation\n\t * @param {ResolverWithOptions} resolver the resolver\n\t * @param {InputFileSystem} fs the file system\n\t * @param {function(WebpackError=): void} callback callback function\n\t * @returns {void}\n\t */\n\tbuild(options, compilation, resolver, fs, callback) {\n\t\tconst { rootModule } = this;\n\t\tconst { moduleArgument, exportsArgument } =\n\t\t\t/** @type {BuildInfo} */\n\t\t\t(rootModule.buildInfo);\n\t\tthis.buildInfo = {\n\t\t\tstrict: true,\n\t\t\tcacheable: true,\n\t\t\tmoduleArgument,\n\t\t\texportsArgument,\n\t\t\tfileDependencies: new LazySet(),\n\t\t\tcontextDependencies: new LazySet(),\n\t\t\tmissingDependencies: new LazySet(),\n\t\t\ttopLevelDeclarations: new Set(),\n\t\t\tassets: undefined\n\t\t};\n\t\tthis.buildMeta = rootModule.buildMeta;\n\t\tthis.clearDependenciesAndBlocks();\n\t\tthis.clearWarningsAndErrors();\n\n\t\tfor (const m of this._modules) {\n\t\t\t// populate cacheable\n\t\t\tif (!(/** @type {BuildInfo} */ (m.buildInfo).cacheable)) {\n\t\t\t\tthis.buildInfo.cacheable = false;\n\t\t\t}\n\n\t\t\t// populate dependencies\n\t\t\tfor (const d of m.dependencies.filter(\n\t\t\t\tdep =>\n\t\t\t\t\t!(dep instanceof HarmonyImportDependency) ||\n\t\t\t\t\t!this._modules.has(\n\t\t\t\t\t\t/** @type {Module} */ (compilation.moduleGraph.getModule(dep))\n\t\t\t\t\t)\n\t\t\t)) {\n\t\t\t\tthis.dependencies.push(d);\n\t\t\t}\n\t\t\t// populate blocks\n\t\t\tfor (const d of m.blocks) {\n\t\t\t\tthis.blocks.push(d);\n\t\t\t}\n\n\t\t\t// populate warnings\n\t\t\tconst warnings = m.getWarnings();\n\t\t\tif (warnings !== undefined) {\n\t\t\t\tfor (const warning of warnings) {\n\t\t\t\t\tthis.addWarning(warning);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// populate errors\n\t\t\tconst errors = m.getErrors();\n\t\t\tif (errors !== undefined) {\n\t\t\t\tfor (const error of errors) {\n\t\t\t\t\tthis.addError(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst { assets, assetsInfo, topLevelDeclarations } =\n\t\t\t\t/** @type {BuildInfo} */ (m.buildInfo);\n\n\t\t\t// populate topLevelDeclarations\n\t\t\tif (topLevelDeclarations) {\n\t\t\t\tconst topLevelDeclarations = this.buildInfo.topLevelDeclarations;\n\t\t\t\tif (topLevelDeclarations !== undefined) {\n\t\t\t\t\tfor (const decl of topLevelDeclarations) {\n\t\t\t\t\t\ttopLevelDeclarations.add(decl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.buildInfo.topLevelDeclarations = undefined;\n\t\t\t}\n\n\t\t\t// populate assets\n\t\t\tif (assets) {\n\t\t\t\tif (this.buildInfo.assets === undefined) {\n\t\t\t\t\tthis.buildInfo.assets = Object.create(null);\n\t\t\t\t}\n\t\t\t\tObject.assign(\n\t\t\t\t\t/** @type {NonNullable<BuildInfo[\"assets\"]>} */\n\t\t\t\t\t(\n\t\t\t\t\t\t/** @type {BuildInfo} */\n\t\t\t\t\t\t(this.buildInfo).assets\n\t\t\t\t\t),\n\t\t\t\t\tassets\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (assetsInfo) {\n\t\t\t\tif (this.buildInfo.assetsInfo === undefined) {\n\t\t\t\t\tthis.buildInfo.assetsInfo = new Map();\n\t\t\t\t}\n\t\t\t\tfor (const [key, value] of assetsInfo) {\n\t\t\t\t\tthis.buildInfo.assetsInfo.set(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcallback();\n\t}\n\n\t/**\n\t * @param {string=} type the source type for which the size should be estimated\n\t * @returns {number} the estimated size of the module (must be non-zero)\n\t */\n\tsize(type) {\n\t\t// Guess size from embedded modules\n\t\tlet size = 0;\n\t\tfor (const module of this._modules) {\n\t\t\tsize += module.size(type);\n\t\t}\n\t\treturn size;\n\t}\n\n\t/**\n\t * @private\n\t * @param {Module} rootModule the root of the concatenation\n\t * @param {Set<Module>} modulesSet a set of modules which should be concatenated\n\t * @param {RuntimeSpec} runtime for this runtime\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @returns {ConcatenationEntry[]} concatenation list\n\t */\n\t_createConcatenationList(rootModule, modulesSet, runtime, moduleGraph) {\n\t\t/** @type {ConcatenationEntry[]} */\n\t\tconst list = [];\n\t\t/** @type {Map<Module, RuntimeSpec | true>} */\n\t\tconst existingEntries = new Map();\n\n\t\t/**\n\t\t * @param {Module} module a module\n\t\t * @returns {Iterable<{ connection: ModuleGraphConnection, runtimeCondition: RuntimeSpec | true }>} imported modules in order\n\t\t */\n\t\tconst getConcatenatedImports = module => {\n\t\t\tconst connections = Array.from(\n\t\t\t\tmoduleGraph.getOutgoingConnections(module)\n\t\t\t);\n\t\t\tif (module === rootModule) {\n\t\t\t\tfor (const c of moduleGraph.getOutgoingConnections(this))\n\t\t\t\t\tconnections.push(c);\n\t\t\t}\n\t\t\t/**\n\t\t\t * @type {Array<{ connection: ModuleGraphConnection, sourceOrder: number, rangeStart: number }>}\n\t\t\t */\n\t\t\tconst references = connections\n\t\t\t\t.filter(connection => {\n\t\t\t\t\tif (!(connection.dependency instanceof HarmonyImportDependency))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\treturn (\n\t\t\t\t\t\tconnection &&\n\t\t\t\t\t\tconnection.resolvedOriginModule === module &&\n\t\t\t\t\t\tconnection.module &&\n\t\t\t\t\t\tconnection.isTargetActive(runtime)\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t\t.map(connection => {\n\t\t\t\t\tconst dep = /** @type {HarmonyImportDependency} */ (\n\t\t\t\t\t\tconnection.dependency\n\t\t\t\t\t);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tconnection,\n\t\t\t\t\t\tsourceOrder: dep.sourceOrder,\n\t\t\t\t\t\trangeStart: dep.range && dep.range[0]\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t/**\n\t\t\t * bySourceOrder\n\t\t\t * @example\n\t\t\t * import a from \"a\"; // sourceOrder=1\n\t\t\t * import b from \"b\"; // sourceOrder=2\n\t\t\t *\n\t\t\t * byRangeStart\n\t\t\t * @example\n\t\t\t * import {a, b} from \"a\"; // sourceOrder=1\n\t\t\t * a.a(); // first range\n\t\t\t * b.b(); // second range\n\t\t\t *\n\t\t\t * If there is no reexport, we have the same source.\n\t\t\t * If there is reexport, but module has side effects, this will lead to reexport module only.\n\t\t\t * If there is side-effects-free reexport, we can get simple deterministic result with range start comparison.\n\t\t\t */\n\t\t\treferences.sort(concatComparators(bySourceOrder, byRangeStart));\n\t\t\t/** @type {Map<Module, { connection: ModuleGraphConnection, runtimeCondition: RuntimeSpec | true }>} */\n\t\t\tconst referencesMap = new Map();\n\t\t\tfor (const { connection } of references) {\n\t\t\t\tconst runtimeCondition = filterRuntime(runtime, r =>\n\t\t\t\t\tconnection.isTargetActive(r)\n\t\t\t\t);\n\t\t\t\tif (runtimeCondition === false) continue;\n\t\t\t\tconst module = connection.module;\n\t\t\t\tconst entry = referencesMap.get(module);\n\t\t\t\tif (entry === undefined) {\n\t\t\t\t\treferencesMap.set(module, { connection, runtimeCondition });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tentry.runtimeCondition = mergeRuntimeConditionNonFalse(\n\t\t\t\t\tentry.runtimeCondition,\n\t\t\t\t\truntimeCondition,\n\t\t\t\t\truntime\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn referencesMap.values();\n\t\t};\n\n\t\t/**\n\t\t * @param {ModuleGraphConnection} connection graph connection\n\t\t * @param {RuntimeSpec | true} runtimeCondition runtime condition\n\t\t * @returns {void}\n\t\t */\n\t\tconst enterModule = (connection, runtimeCondition) => {\n\t\t\tconst module = connection.module;\n\t\t\tif (!module) return;\n\t\t\tconst existingEntry = existingEntries.get(module);\n\t\t\tif (existingEntry === true) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (modulesSet.has(module)) {\n\t\t\t\texistingEntries.set(module, true);\n\t\t\t\tif (runtimeCondition !== true) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot runtime-conditional concatenate a module (${module.identifier()} in ${this.rootModule.identifier()}, ${runtimeConditionToString(\n\t\t\t\t\t\t\truntimeCondition\n\t\t\t\t\t\t)}). This should not happen.`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst imports = getConcatenatedImports(module);\n\t\t\t\tfor (const { connection, runtimeCondition } of imports)\n\t\t\t\t\tenterModule(connection, runtimeCondition);\n\t\t\t\tlist.push({\n\t\t\t\t\ttype: \"concatenated\",\n\t\t\t\t\tmodule: connection.module,\n\t\t\t\t\truntimeCondition\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (existingEntry !== undefined) {\n\t\t\t\t\tconst reducedRuntimeCondition = subtractRuntimeCondition(\n\t\t\t\t\t\truntimeCondition,\n\t\t\t\t\t\texistingEntry,\n\t\t\t\t\t\truntime\n\t\t\t\t\t);\n\t\t\t\t\tif (reducedRuntimeCondition === false) return;\n\t\t\t\t\truntimeCondition = reducedRuntimeCondition;\n\t\t\t\t\texistingEntries.set(\n\t\t\t\t\t\tconnection.module,\n\t\t\t\t\t\tmergeRuntimeConditionNonFalse(\n\t\t\t\t\t\t\texistingEntry,\n\t\t\t\t\t\t\truntimeCondition,\n\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\texistingEntries.set(connection.module, runtimeCondition);\n\t\t\t\t}\n\t\t\t\tif (list.length > 0) {\n\t\t\t\t\tconst lastItem = list[list.length - 1];\n\t\t\t\t\tif (\n\t\t\t\t\t\tlastItem.type === \"external\" &&\n\t\t\t\t\t\tlastItem.module === connection.module\n\t\t\t\t\t) {\n\t\t\t\t\t\tlastItem.runtimeCondition = mergeRuntimeCondition(\n\t\t\t\t\t\t\tlastItem.runtimeCondition,\n\t\t\t\t\t\t\truntimeCondition,\n\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.push({\n\t\t\t\t\ttype: \"external\",\n\t\t\t\t\tget module() {\n\t\t\t\t\t\t// We need to use a getter here, because the module in the dependency\n\t\t\t\t\t\t// could be replaced by some other process (i. e. also replaced with a\n\t\t\t\t\t\t// concatenated module)\n\t\t\t\t\t\treturn connection.module;\n\t\t\t\t\t},\n\t\t\t\t\truntimeCondition\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\texistingEntries.set(rootModule, true);\n\t\tconst imports = getConcatenatedImports(rootModule);\n\t\tfor (const { connection, runtimeCondition } of imports)\n\t\t\tenterModule(connection, runtimeCondition);\n\t\tlist.push({\n\t\t\ttype: \"concatenated\",\n\t\t\tmodule: rootModule,\n\t\t\truntimeCondition: true\n\t\t});\n\n\t\treturn list;\n\t}\n\n\t/**\n\t * @param {Module} rootModule the root module of the concatenation\n\t * @param {Set<Module>} modules all modules in the concatenation (including the root module)\n\t * @param {object=} associatedObjectForCache object for caching\n\t * @param {string | HashConstructor=} hashFunction hash function to use\n\t * @returns {string} the identifier\n\t */\n\tstatic _createIdentifier(\n\t\trootModule,\n\t\tmodules,\n\t\tassociatedObjectForCache,\n\t\thashFunction = \"md4\"\n\t) {\n\t\tconst cachedMakePathsRelative = makePathsRelative.bindContextCache(\n\t\t\t/** @type {string} */ (rootModule.context),\n\t\t\tassociatedObjectForCache\n\t\t);\n\t\tconst identifiers = [];\n\t\tfor (const module of modules) {\n\t\t\tidentifiers.push(cachedMakePathsRelative(module.identifier()));\n\t\t}\n\t\tidentifiers.sort();\n\t\tconst hash = createHash(hashFunction);\n\t\thash.update(identifiers.join(\" \"));\n\t\treturn `${rootModule.identifier()}|${hash.digest(\"hex\")}`;\n\t}\n\n\t/**\n\t * @param {LazySet<string>} fileDependencies set where file dependencies are added to\n\t * @param {LazySet<string>} contextDependencies set where context dependencies are added to\n\t * @param {LazySet<string>} missingDependencies set where missing dependencies are added to\n\t * @param {LazySet<string>} buildDependencies set where build dependencies are added to\n\t */\n\taddCacheDependencies(\n\t\tfileDependencies,\n\t\tcontextDependencies,\n\t\tmissingDependencies,\n\t\tbuildDependencies\n\t) {\n\t\tfor (const module of this._modules) {\n\t\t\tmodule.addCacheDependencies(\n\t\t\t\tfileDependencies,\n\t\t\t\tcontextDependencies,\n\t\t\t\tmissingDependencies,\n\t\t\t\tbuildDependencies\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @param {CodeGenerationContext} context context for code generation\n\t * @returns {CodeGenerationResult} result\n\t */\n\tcodeGeneration({\n\t\tdependencyTemplates,\n\t\truntimeTemplate,\n\t\tmoduleGraph,\n\t\tchunkGraph,\n\t\truntime: generationRuntime,\n\t\tcodeGenerationResults\n\t}) {\n\t\t/** @type {RuntimeRequirements} */\n\t\tconst runtimeRequirements = new Set();\n\t\tconst runtime = intersectRuntime(generationRuntime, this._runtime);\n\n\t\tconst requestShortener = runtimeTemplate.requestShortener;\n\t\t// Meta info for each module\n\t\tconst [modulesWithInfo, moduleToInfoMap] = this._getModulesWithInfo(\n\t\t\tmoduleGraph,\n\t\t\truntime\n\t\t);\n\n\t\t// Set with modules that need a generated namespace object\n\t\t/** @type {Set<ConcatenatedModuleInfo>} */\n\t\tconst neededNamespaceObjects = new Set();\n\n\t\t// Generate source code and analyse scopes\n\t\t// Prepare a ReplaceSource for the final source\n\t\tfor (const info of moduleToInfoMap.values()) {\n\t\t\tthis._analyseModule(\n\t\t\t\tmoduleToInfoMap,\n\t\t\t\tinfo,\n\t\t\t\tdependencyTemplates,\n\t\t\t\truntimeTemplate,\n\t\t\t\tmoduleGraph,\n\t\t\t\tchunkGraph,\n\t\t\t\truntime,\n\t\t\t\t/** @type {CodeGenerationResults} */\n\t\t\t\t(codeGenerationResults)\n\t\t\t);\n\t\t}\n\n\t\t// List of all used names to avoid conflicts\n\t\tconst allUsedNames = new Set(RESERVED_NAMES);\n\t\t// Updated Top level declarations are created by renaming\n\t\tconst topLevelDeclarations = new Set();\n\n\t\t// List of additional names in scope for module references\n\t\t/** @type {Map<string, { usedNames: UsedNames, alreadyCheckedScopes: Set<TODO> }>} */\n\t\tconst usedNamesInScopeInfo = new Map();\n\t\t/**\n\t\t * @param {string} module module identifier\n\t\t * @param {string} id export id\n\t\t * @returns {{ usedNames: UsedNames, alreadyCheckedScopes: Set<TODO> }} info\n\t\t */\n\n\t\t// Set of already checked scopes\n\t\tconst ignoredScopes = new Set();\n\n\t\t// get all global names\n\t\tfor (const info of modulesWithInfo) {\n\t\t\tif (info.type === \"concatenated\") {\n\t\t\t\t// ignore symbols from moduleScope\n\t\t\t\tif (info.moduleScope) {\n\t\t\t\t\tignoredScopes.add(info.moduleScope);\n\t\t\t\t}\n\n\t\t\t\t// The super class expression in class scopes behaves weird\n\t\t\t\t// We get ranges of all super class expressions to make\n\t\t\t\t// renaming to work correctly\n\t\t\t\tconst superClassCache = new WeakMap();\n\t\t\t\t/**\n\t\t\t\t * @param {Scope} scope scope\n\t\t\t\t * @returns {TODO} result\n\t\t\t\t */\n\t\t\t\tconst getSuperClassExpressions = scope => {\n\t\t\t\t\tconst cacheEntry = superClassCache.get(scope);\n\t\t\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\t\t\tconst superClassExpressions = [];\n\t\t\t\t\tfor (const childScope of scope.childScopes) {\n\t\t\t\t\t\tif (childScope.type !== \"class\") continue;\n\t\t\t\t\t\tconst block = childScope.block;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t(block.type === \"ClassDeclaration\" ||\n\t\t\t\t\t\t\t\tblock.type === \"ClassExpression\") &&\n\t\t\t\t\t\t\tblock.superClass\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tsuperClassExpressions.push({\n\t\t\t\t\t\t\t\trange: block.superClass.range,\n\t\t\t\t\t\t\t\tvariables: childScope.variables\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsuperClassCache.set(scope, superClassExpressions);\n\t\t\t\t\treturn superClassExpressions;\n\t\t\t\t};\n\n\t\t\t\t// add global symbols\n\t\t\t\tif (info.globalScope) {\n\t\t\t\t\tfor (const reference of info.globalScope.through) {\n\t\t\t\t\t\tconst name = reference.identifier.name;\n\t\t\t\t\t\tif (ConcatenationScope.isModuleReference(name)) {\n\t\t\t\t\t\t\tconst match = ConcatenationScope.matchModuleReference(name);\n\t\t\t\t\t\t\tif (!match) continue;\n\t\t\t\t\t\t\tconst referencedInfo = modulesWithInfo[match.index];\n\t\t\t\t\t\t\tif (referencedInfo.type === \"reference\")\n\t\t\t\t\t\t\t\tthrow new Error(\"Module reference can't point to a reference\");\n\t\t\t\t\t\t\tconst binding = getFinalBinding(\n\t\t\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\t\t\treferencedInfo,\n\t\t\t\t\t\t\t\tmatch.ids,\n\t\t\t\t\t\t\t\tmoduleToInfoMap,\n\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\trequestShortener,\n\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\tneededNamespaceObjects,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t/** @type {BuildMeta} */\n\t\t\t\t\t\t\t\t(info.module.buildMeta).strictHarmonyModule,\n\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (!binding.ids) continue;\n\t\t\t\t\t\t\tconst { usedNames, alreadyCheckedScopes } =\n\t\t\t\t\t\t\t\tgetUsedNamesInScopeInfo(\n\t\t\t\t\t\t\t\t\tusedNamesInScopeInfo,\n\t\t\t\t\t\t\t\t\tbinding.info.module.identifier(),\n\t\t\t\t\t\t\t\t\t\"name\" in binding ? binding.name : \"\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tfor (const expr of getSuperClassExpressions(reference.from)) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\texpr.range[0] <=\n\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (reference.identifier.range)[0] &&\n\t\t\t\t\t\t\t\t\texpr.range[1] >=\n\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (reference.identifier.range)[1]\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tfor (const variable of expr.variables) {\n\t\t\t\t\t\t\t\t\t\tusedNames.add(variable.name);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\taddScopeSymbols(\n\t\t\t\t\t\t\t\treference.from,\n\t\t\t\t\t\t\t\tusedNames,\n\t\t\t\t\t\t\t\talreadyCheckedScopes,\n\t\t\t\t\t\t\t\tignoredScopes\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tallUsedNames.add(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// generate names for symbols\n\t\tfor (const info of moduleToInfoMap.values()) {\n\t\t\tconst { usedNames: namespaceObjectUsedNames } = getUsedNamesInScopeInfo(\n\t\t\t\tusedNamesInScopeInfo,\n\t\t\t\tinfo.module.identifier(),\n\t\t\t\t\"\"\n\t\t\t);\n\t\t\tswitch (info.type) {\n\t\t\t\tcase \"concatenated\": {\n\t\t\t\t\tconst variables = /** @type {Scope} */ (info.moduleScope).variables;\n\t\t\t\t\tfor (const variable of variables) {\n\t\t\t\t\t\tconst name = variable.name;\n\t\t\t\t\t\tconst { usedNames, alreadyCheckedScopes } = getUsedNamesInScopeInfo(\n\t\t\t\t\t\t\tusedNamesInScopeInfo,\n\t\t\t\t\t\t\tinfo.module.identifier(),\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (allUsedNames.has(name) || usedNames.has(name)) {\n\t\t\t\t\t\t\tconst references = getAllReferences(variable);\n\t\t\t\t\t\t\tfor (const ref of references) {\n\t\t\t\t\t\t\t\taddScopeSymbols(\n\t\t\t\t\t\t\t\t\tref.from,\n\t\t\t\t\t\t\t\t\tusedNames,\n\t\t\t\t\t\t\t\t\talreadyCheckedScopes,\n\t\t\t\t\t\t\t\t\tignoredScopes\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst newName = findNewName(\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tallUsedNames,\n\t\t\t\t\t\t\t\tusedNames,\n\t\t\t\t\t\t\t\tinfo.module.readableIdentifier(requestShortener)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tallUsedNames.add(newName);\n\t\t\t\t\t\t\tinfo.internalNames.set(name, newName);\n\t\t\t\t\t\t\ttopLevelDeclarations.add(newName);\n\t\t\t\t\t\t\tconst source = /** @type {ReplaceSource} */ (info.source);\n\t\t\t\t\t\t\tconst allIdentifiers = new Set(\n\t\t\t\t\t\t\t\treferences.map(r => r.identifier).concat(variable.identifiers)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tfor (const identifier of allIdentifiers) {\n\t\t\t\t\t\t\t\tconst r = /** @type {Range} */ (identifier.range);\n\t\t\t\t\t\t\t\tconst path = getPathInAst(\n\t\t\t\t\t\t\t\t\t/** @type {NonNullable<ConcatenatedModuleInfo[\"ast\"]>} */\n\t\t\t\t\t\t\t\t\t(info.ast),\n\t\t\t\t\t\t\t\t\tidentifier\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (path && path.length > 1) {\n\t\t\t\t\t\t\t\t\tconst maybeProperty =\n\t\t\t\t\t\t\t\t\t\tpath[1].type === \"AssignmentPattern\" &&\n\t\t\t\t\t\t\t\t\t\tpath[1].left === path[0]\n\t\t\t\t\t\t\t\t\t\t\t? path[2]\n\t\t\t\t\t\t\t\t\t\t\t: path[1];\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tmaybeProperty.type === \"Property\" &&\n\t\t\t\t\t\t\t\t\t\tmaybeProperty.shorthand\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tsource.insert(r[1], `: ${newName}`);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsource.replace(r[0], r[1] - 1, newName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tallUsedNames.add(name);\n\t\t\t\t\t\t\tinfo.internalNames.set(name, name);\n\t\t\t\t\t\t\ttopLevelDeclarations.add(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet namespaceObjectName;\n\t\t\t\t\tif (info.namespaceExportSymbol) {\n\t\t\t\t\t\tnamespaceObjectName = info.internalNames.get(\n\t\t\t\t\t\t\tinfo.namespaceExportSymbol\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnamespaceObjectName = findNewName(\n\t\t\t\t\t\t\t\"namespaceObject\",\n\t\t\t\t\t\t\tallUsedNames,\n\t\t\t\t\t\t\tnamespaceObjectUsedNames,\n\t\t\t\t\t\t\tinfo.module.readableIdentifier(requestShortener)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tallUsedNames.add(namespaceObjectName);\n\t\t\t\t\t}\n\t\t\t\t\tinfo.namespaceObjectName =\n\t\t\t\t\t\t/** @type {string} */\n\t\t\t\t\t\t(namespaceObjectName);\n\t\t\t\t\ttopLevelDeclarations.add(namespaceObjectName);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"external\": {\n\t\t\t\t\tconst externalName = findNewName(\n\t\t\t\t\t\t\"\",\n\t\t\t\t\t\tallUsedNames,\n\t\t\t\t\t\tnamespaceObjectUsedNames,\n\t\t\t\t\t\tinfo.module.readableIdentifier(requestShortener)\n\t\t\t\t\t);\n\t\t\t\t\tallUsedNames.add(externalName);\n\t\t\t\t\tinfo.name = externalName;\n\t\t\t\t\ttopLevelDeclarations.add(externalName);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst buildMeta = /** @type {BuildMeta} */ (info.module.buildMeta);\n\t\t\tif (buildMeta.exportsType !== \"namespace\") {\n\t\t\t\tconst externalNameInterop = findNewName(\n\t\t\t\t\t\"namespaceObject\",\n\t\t\t\t\tallUsedNames,\n\t\t\t\t\tnamespaceObjectUsedNames,\n\t\t\t\t\tinfo.module.readableIdentifier(requestShortener)\n\t\t\t\t);\n\t\t\t\tallUsedNames.add(externalNameInterop);\n\t\t\t\tinfo.interopNamespaceObjectName = externalNameInterop;\n\t\t\t\ttopLevelDeclarations.add(externalNameInterop);\n\t\t\t}\n\t\t\tif (\n\t\t\t\tbuildMeta.exportsType === \"default\" &&\n\t\t\t\tbuildMeta.defaultObject !== \"redirect\"\n\t\t\t) {\n\t\t\t\tconst externalNameInterop = findNewName(\n\t\t\t\t\t\"namespaceObject2\",\n\t\t\t\t\tallUsedNames,\n\t\t\t\t\tnamespaceObjectUsedNames,\n\t\t\t\t\tinfo.module.readableIdentifier(requestShortener)\n\t\t\t\t);\n\t\t\t\tallUsedNames.add(externalNameInterop);\n\t\t\t\tinfo.interopNamespaceObject2Name = externalNameInterop;\n\t\t\t\ttopLevelDeclarations.add(externalNameInterop);\n\t\t\t}\n\t\t\tif (buildMeta.exportsType === \"dynamic\" || !buildMeta.exportsType) {\n\t\t\t\tconst externalNameInterop = findNewName(\n\t\t\t\t\t\"default\",\n\t\t\t\t\tallUsedNames,\n\t\t\t\t\tnamespaceObjectUsedNames,\n\t\t\t\t\tinfo.module.readableIdentifier(requestShortener)\n\t\t\t\t);\n\t\t\t\tallUsedNames.add(externalNameInterop);\n\t\t\t\tinfo.interopDefaultAccessName = externalNameInterop;\n\t\t\t\ttopLevelDeclarations.add(externalNameInterop);\n\t\t\t}\n\t\t}\n\n\t\t// Find and replace references to modules\n\t\tfor (const info of moduleToInfoMap.values()) {\n\t\t\tif (info.type === \"concatenated\") {\n\t\t\t\tconst globalScope = /** @type {Scope} */ (info.globalScope);\n\t\t\t\tfor (const reference of globalScope.through) {\n\t\t\t\t\tconst name = reference.identifier.name;\n\t\t\t\t\tconst match = ConcatenationScope.matchModuleReference(name);\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tconst referencedInfo = modulesWithInfo[match.index];\n\t\t\t\t\t\tif (referencedInfo.type === \"reference\")\n\t\t\t\t\t\t\tthrow new Error(\"Module reference can't point to a reference\");\n\t\t\t\t\t\tconst finalName = getFinalName(\n\t\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\t\treferencedInfo,\n\t\t\t\t\t\t\tmatch.ids,\n\t\t\t\t\t\t\tmoduleToInfoMap,\n\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\trequestShortener,\n\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\tneededNamespaceObjects,\n\t\t\t\t\t\t\tmatch.call,\n\t\t\t\t\t\t\t!match.directImport,\n\t\t\t\t\t\t\t/** @type {BuildMeta} */\n\t\t\t\t\t\t\t(info.module.buildMeta).strictHarmonyModule,\n\t\t\t\t\t\t\tmatch.asiSafe\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst r = /** @type {Range} */ (reference.identifier.range);\n\t\t\t\t\t\tconst source = /** @type {ReplaceSource} */ (info.source);\n\t\t\t\t\t\t// range is extended by 2 chars to cover the appended \"._\"\n\t\t\t\t\t\tsource.replace(r[0], r[1] + 1, finalName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Map with all root exposed used exports\n\t\t/** @type {Map<string, function(RequestShortener): string>} */\n\t\tconst exportsMap = new Map();\n\n\t\t// Set with all root exposed unused exports\n\t\t/** @type {Set<string>} */\n\t\tconst unusedExports = new Set();\n\n\t\tconst rootInfo = /** @type {ConcatenatedModuleInfo} */ (\n\t\t\tmoduleToInfoMap.get(this.rootModule)\n\t\t);\n\t\tconst strictHarmonyModule =\n\t\t\t/** @type {BuildMeta} */\n\t\t\t(rootInfo.module.buildMeta).strictHarmonyModule;\n\t\tconst exportsInfo = moduleGraph.getExportsInfo(rootInfo.module);\n\t\t/** @type {Record<string, string>} */\n\t\tconst exportsFinalName = {};\n\t\tfor (const exportInfo of exportsInfo.orderedExports) {\n\t\t\tconst name = exportInfo.name;\n\t\t\tif (exportInfo.provided === false) continue;\n\t\t\tconst used = exportInfo.getUsedName(undefined, runtime);\n\t\t\tif (!used) {\n\t\t\t\tunusedExports.add(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\texportsMap.set(used, requestShortener => {\n\t\t\t\ttry {\n\t\t\t\t\tconst finalName = getFinalName(\n\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\trootInfo,\n\t\t\t\t\t\t[name],\n\t\t\t\t\t\tmoduleToInfoMap,\n\t\t\t\t\t\truntime,\n\t\t\t\t\t\trequestShortener,\n\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\tneededNamespaceObjects,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tstrictHarmonyModule,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t);\n\t\t\t\t\texportsFinalName[used] = finalName;\n\t\t\t\t\treturn `/* ${\n\t\t\t\t\t\texportInfo.isReexport() ? \"reexport\" : \"binding\"\n\t\t\t\t\t} */ ${finalName}`;\n\t\t\t\t} catch (err) {\n\t\t\t\t\t/** @type {Error} */\n\t\t\t\t\t(err).message +=\n\t\t\t\t\t\t`\\nwhile generating the root export '${name}' (used name: '${used}')`;\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tconst result = new ConcatSource();\n\n\t\t// add harmony compatibility flag (must be first because of possible circular dependencies)\n\t\tlet shouldAddHarmonyFlag = false;\n\t\tif (\n\t\t\tmoduleGraph.getExportsInfo(this).otherExportsInfo.getUsed(runtime) !==\n\t\t\tUsageState.Unused\n\t\t) {\n\t\t\tshouldAddHarmonyFlag = true;\n\t\t}\n\n\t\t// define exports\n\t\tif (exportsMap.size > 0) {\n\t\t\tconst { exportsDefinitions } = ConcatenatedModule.getCompilationHooks(\n\t\t\t\t/** @type {Compilation} */ (this.compilation)\n\t\t\t);\n\n\t\t\tconst definitions = [];\n\t\t\tfor (const [key, value] of exportsMap) {\n\t\t\t\tdefinitions.push(\n\t\t\t\t\t`\\n  ${propertyName(key)}: ${runtimeTemplate.returningFunction(\n\t\t\t\t\t\tvalue(requestShortener)\n\t\t\t\t\t)}`\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst shouldSkipRenderDefinitions =\n\t\t\t\texportsDefinitions.call(exportsFinalName);\n\n\t\t\tif (!shouldSkipRenderDefinitions) {\n\t\t\t\truntimeRequirements.add(RuntimeGlobals.exports);\n\t\t\t\truntimeRequirements.add(RuntimeGlobals.definePropertyGetters);\n\n\t\t\t\tif (shouldAddHarmonyFlag) {\n\t\t\t\t\tresult.add(\"// ESM COMPAT FLAG\\n\");\n\t\t\t\t\tresult.add(\n\t\t\t\t\t\truntimeTemplate.defineEsModuleFlagStatement({\n\t\t\t\t\t\t\texportsArgument: this.exportsArgument,\n\t\t\t\t\t\t\truntimeRequirements\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tresult.add(\"\\n// EXPORTS\\n\");\n\t\t\t\tresult.add(\n\t\t\t\t\t`${RuntimeGlobals.definePropertyGetters}(${\n\t\t\t\t\t\tthis.exportsArgument\n\t\t\t\t\t}, {${definitions.join(\",\")}\\n});\\n`\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t/** @type {BuildMeta} */\n\t\t\t\t(this.buildMeta).exportsFinalName = exportsFinalName;\n\t\t\t}\n\t\t}\n\n\t\t// list unused exports\n\t\tif (unusedExports.size > 0) {\n\t\t\tresult.add(\n\t\t\t\t`\\n// UNUSED EXPORTS: ${joinIterableWithComma(unusedExports)}\\n`\n\t\t\t);\n\t\t}\n\n\t\t// generate namespace objects\n\t\tconst namespaceObjectSources = new Map();\n\t\tfor (const info of neededNamespaceObjects) {\n\t\t\tif (info.namespaceExportSymbol) continue;\n\t\t\tconst nsObj = [];\n\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(info.module);\n\t\t\tfor (const exportInfo of exportsInfo.orderedExports) {\n\t\t\t\tif (exportInfo.provided === false) continue;\n\t\t\t\tconst usedName = exportInfo.getUsedName(undefined, runtime);\n\t\t\t\tif (usedName) {\n\t\t\t\t\tconst finalName = getFinalName(\n\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t[exportInfo.name],\n\t\t\t\t\t\tmoduleToInfoMap,\n\t\t\t\t\t\truntime,\n\t\t\t\t\t\trequestShortener,\n\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\tneededNamespaceObjects,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t/** @type {BuildMeta} */\n\t\t\t\t\t\t(info.module.buildMeta).strictHarmonyModule,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t);\n\t\t\t\t\tnsObj.push(\n\t\t\t\t\t\t`\\n  ${propertyName(usedName)}: ${runtimeTemplate.returningFunction(\n\t\t\t\t\t\t\tfinalName\n\t\t\t\t\t\t)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst name = info.namespaceObjectName;\n\t\t\tconst defineGetters =\n\t\t\t\tnsObj.length > 0\n\t\t\t\t\t? `${RuntimeGlobals.definePropertyGetters}(${name}, {${nsObj.join(\n\t\t\t\t\t\t\t\",\"\n\t\t\t\t\t\t)}\\n});\\n`\n\t\t\t\t\t: \"\";\n\t\t\tif (nsObj.length > 0)\n\t\t\t\truntimeRequirements.add(RuntimeGlobals.definePropertyGetters);\n\t\t\tnamespaceObjectSources.set(\n\t\t\t\tinfo,\n\t\t\t\t`\n// NAMESPACE OBJECT: ${info.module.readableIdentifier(requestShortener)}\nvar ${name} = {};\n${RuntimeGlobals.makeNamespaceObject}(${name});\n${defineGetters}`\n\t\t\t);\n\t\t\truntimeRequirements.add(RuntimeGlobals.makeNamespaceObject);\n\t\t}\n\n\t\t// define required namespace objects (must be before evaluation modules)\n\t\tfor (const info of modulesWithInfo) {\n\t\t\tif (info.type === \"concatenated\") {\n\t\t\t\tconst source = namespaceObjectSources.get(info);\n\t\t\t\tif (!source) continue;\n\t\t\t\tresult.add(source);\n\t\t\t}\n\t\t}\n\n\t\tconst chunkInitFragments = [];\n\n\t\t// evaluate modules in order\n\t\tfor (const rawInfo of modulesWithInfo) {\n\t\t\tlet name;\n\t\t\tlet isConditional = false;\n\t\t\tconst info = rawInfo.type === \"reference\" ? rawInfo.target : rawInfo;\n\t\t\tswitch (info.type) {\n\t\t\t\tcase \"concatenated\": {\n\t\t\t\t\tresult.add(\n\t\t\t\t\t\t`\\n;// ${info.module.readableIdentifier(requestShortener)}\\n`\n\t\t\t\t\t);\n\t\t\t\t\tresult.add(/** @type {ReplaceSource} */ (info.source));\n\t\t\t\t\tif (info.chunkInitFragments) {\n\t\t\t\t\t\tfor (const f of info.chunkInitFragments) chunkInitFragments.push(f);\n\t\t\t\t\t}\n\t\t\t\t\tif (info.runtimeRequirements) {\n\t\t\t\t\t\tfor (const r of info.runtimeRequirements) {\n\t\t\t\t\t\t\truntimeRequirements.add(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tname = info.namespaceObjectName;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"external\": {\n\t\t\t\t\tresult.add(\n\t\t\t\t\t\t`\\n// EXTERNAL MODULE: ${info.module.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)}\\n`\n\t\t\t\t\t);\n\t\t\t\t\truntimeRequirements.add(RuntimeGlobals.require);\n\t\t\t\t\tconst { runtimeCondition } =\n\t\t\t\t\t\t/** @type {ExternalModuleInfo | ReferenceToModuleInfo} */ (rawInfo);\n\t\t\t\t\tconst condition = runtimeTemplate.runtimeConditionExpression({\n\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\truntimeCondition,\n\t\t\t\t\t\truntime,\n\t\t\t\t\t\truntimeRequirements\n\t\t\t\t\t});\n\t\t\t\t\tif (condition !== \"true\") {\n\t\t\t\t\t\tisConditional = true;\n\t\t\t\t\t\tresult.add(`if (${condition}) {\\n`);\n\t\t\t\t\t}\n\t\t\t\t\tresult.add(\n\t\t\t\t\t\t`var ${info.name} = ${RuntimeGlobals.require}(${JSON.stringify(\n\t\t\t\t\t\t\tchunkGraph.getModuleId(info.module)\n\t\t\t\t\t\t)});`\n\t\t\t\t\t);\n\t\t\t\t\tname = info.name;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\t// @ts-expect-error never is expected here\n\t\t\t\t\tthrow new Error(`Unsupported concatenation entry type ${info.type}`);\n\t\t\t}\n\t\t\tif (info.interopNamespaceObjectUsed) {\n\t\t\t\truntimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject);\n\t\t\t\tresult.add(\n\t\t\t\t\t`\\nvar ${info.interopNamespaceObjectName} = /*#__PURE__*/${RuntimeGlobals.createFakeNamespaceObject}(${name}, 2);`\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (info.interopNamespaceObject2Used) {\n\t\t\t\truntimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject);\n\t\t\t\tresult.add(\n\t\t\t\t\t`\\nvar ${info.interopNamespaceObject2Name} = /*#__PURE__*/${RuntimeGlobals.createFakeNamespaceObject}(${name});`\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (info.interopDefaultAccessUsed) {\n\t\t\t\truntimeRequirements.add(RuntimeGlobals.compatGetDefaultExport);\n\t\t\t\tresult.add(\n\t\t\t\t\t`\\nvar ${info.interopDefaultAccessName} = /*#__PURE__*/${RuntimeGlobals.compatGetDefaultExport}(${name});`\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (isConditional) {\n\t\t\t\tresult.add(\"\\n}\");\n\t\t\t}\n\t\t}\n\n\t\tconst data = new Map();\n\t\tif (chunkInitFragments.length > 0)\n\t\t\tdata.set(\"chunkInitFragments\", chunkInitFragments);\n\t\tdata.set(\"topLevelDeclarations\", topLevelDeclarations);\n\n\t\t/** @type {CodeGenerationResult} */\n\t\tconst resultEntry = {\n\t\t\tsources: new Map([[\"javascript\", new CachedSource(result)]]),\n\t\t\tdata,\n\t\t\truntimeRequirements\n\t\t};\n\n\t\treturn resultEntry;\n\t}\n\n\t/**\n\t * @param {Map<Module, ModuleInfo>} modulesMap modulesMap\n\t * @param {ModuleInfo} info info\n\t * @param {DependencyTemplates} dependencyTemplates dependencyTemplates\n\t * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate\n\t * @param {ModuleGraph} moduleGraph moduleGraph\n\t * @param {ChunkGraph} chunkGraph chunkGraph\n\t * @param {RuntimeSpec} runtime runtime\n\t * @param {CodeGenerationResults} codeGenerationResults codeGenerationResults\n\t */\n\t_analyseModule(\n\t\tmodulesMap,\n\t\tinfo,\n\t\tdependencyTemplates,\n\t\truntimeTemplate,\n\t\tmoduleGraph,\n\t\tchunkGraph,\n\t\truntime,\n\t\tcodeGenerationResults\n\t) {\n\t\tif (info.type === \"concatenated\") {\n\t\t\tconst m = info.module;\n\t\t\ttry {\n\t\t\t\t// Create a concatenation scope to track and capture information\n\t\t\t\tconst concatenationScope = new ConcatenationScope(modulesMap, info);\n\n\t\t\t\t// TODO cache codeGeneration results\n\t\t\t\tconst codeGenResult = m.codeGeneration({\n\t\t\t\t\tdependencyTemplates,\n\t\t\t\t\truntimeTemplate,\n\t\t\t\t\tmoduleGraph,\n\t\t\t\t\tchunkGraph,\n\t\t\t\t\truntime,\n\t\t\t\t\tconcatenationScope,\n\t\t\t\t\tcodeGenerationResults,\n\t\t\t\t\tsourceTypes: JS_TYPES\n\t\t\t\t});\n\t\t\t\tconst source = /** @type {Source} */ (\n\t\t\t\t\tcodeGenResult.sources.get(\"javascript\")\n\t\t\t\t);\n\t\t\t\tconst data = codeGenResult.data;\n\t\t\t\tconst chunkInitFragments = data && data.get(\"chunkInitFragments\");\n\t\t\t\tconst code = source.source().toString();\n\t\t\t\tlet ast;\n\t\t\t\ttry {\n\t\t\t\t\tast = JavascriptParser._parse(code, {\n\t\t\t\t\t\tsourceType: \"module\"\n\t\t\t\t\t});\n\t\t\t\t} catch (_err) {\n\t\t\t\t\tconst err = /** @type {TODO} */ (_err);\n\t\t\t\t\tif (\n\t\t\t\t\t\terr.loc &&\n\t\t\t\t\t\ttypeof err.loc === \"object\" &&\n\t\t\t\t\t\ttypeof err.loc.line === \"number\"\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst lineNumber = err.loc.line;\n\t\t\t\t\t\tconst lines = code.split(\"\\n\");\n\t\t\t\t\t\terr.message += `\\n| ${lines\n\t\t\t\t\t\t\t.slice(Math.max(0, lineNumber - 3), lineNumber + 2)\n\t\t\t\t\t\t\t.join(\"\\n| \")}`;\n\t\t\t\t\t}\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t\tconst scopeManager = eslintScope.analyze(ast, {\n\t\t\t\t\tecmaVersion: 6,\n\t\t\t\t\tsourceType: \"module\",\n\t\t\t\t\toptimistic: true,\n\t\t\t\t\tignoreEval: true,\n\t\t\t\t\timpliedStrict: true\n\t\t\t\t});\n\t\t\t\tconst globalScope = /** @type {Scope} */ (scopeManager.acquire(ast));\n\t\t\t\tconst moduleScope = globalScope.childScopes[0];\n\t\t\t\tconst resultSource = new ReplaceSource(source);\n\t\t\t\tinfo.runtimeRequirements =\n\t\t\t\t\t/** @type {ReadOnlyRuntimeRequirements} */\n\t\t\t\t\t(codeGenResult.runtimeRequirements);\n\t\t\t\tinfo.ast = ast;\n\t\t\t\tinfo.internalSource = source;\n\t\t\t\tinfo.source = resultSource;\n\t\t\t\tinfo.chunkInitFragments = chunkInitFragments;\n\t\t\t\tinfo.globalScope = globalScope;\n\t\t\t\tinfo.moduleScope = moduleScope;\n\t\t\t} catch (err) {\n\t\t\t\t/** @type {Error} */\n\t\t\t\t(err).message +=\n\t\t\t\t\t`\\nwhile analyzing module ${m.identifier()} for concatenation`;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {[ModuleInfoOrReference[], Map<Module, ModuleInfo>]} module info items\n\t */\n\t_getModulesWithInfo(moduleGraph, runtime) {\n\t\tconst orderedConcatenationList = this._createConcatenationList(\n\t\t\tthis.rootModule,\n\t\t\tthis._modules,\n\t\t\truntime,\n\t\t\tmoduleGraph\n\t\t);\n\t\t/** @type {Map<Module, ModuleInfo>} */\n\t\tconst map = new Map();\n\t\tconst list = orderedConcatenationList.map((info, index) => {\n\t\t\tlet item = map.get(info.module);\n\t\t\tif (item === undefined) {\n\t\t\t\tswitch (info.type) {\n\t\t\t\t\tcase \"concatenated\":\n\t\t\t\t\t\titem = {\n\t\t\t\t\t\t\ttype: \"concatenated\",\n\t\t\t\t\t\t\tmodule: info.module,\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\tast: undefined,\n\t\t\t\t\t\t\tinternalSource: undefined,\n\t\t\t\t\t\t\truntimeRequirements: undefined,\n\t\t\t\t\t\t\tsource: undefined,\n\t\t\t\t\t\t\tglobalScope: undefined,\n\t\t\t\t\t\t\tmoduleScope: undefined,\n\t\t\t\t\t\t\tinternalNames: new Map(),\n\t\t\t\t\t\t\texportMap: undefined,\n\t\t\t\t\t\t\trawExportMap: undefined,\n\t\t\t\t\t\t\tnamespaceExportSymbol: undefined,\n\t\t\t\t\t\t\tnamespaceObjectName: undefined,\n\t\t\t\t\t\t\tinteropNamespaceObjectUsed: false,\n\t\t\t\t\t\t\tinteropNamespaceObjectName: undefined,\n\t\t\t\t\t\t\tinteropNamespaceObject2Used: false,\n\t\t\t\t\t\t\tinteropNamespaceObject2Name: undefined,\n\t\t\t\t\t\t\tinteropDefaultAccessUsed: false,\n\t\t\t\t\t\t\tinteropDefaultAccessName: undefined\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"external\":\n\t\t\t\t\t\titem = {\n\t\t\t\t\t\t\ttype: \"external\",\n\t\t\t\t\t\t\tmodule: info.module,\n\t\t\t\t\t\t\truntimeCondition: info.runtimeCondition,\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\tname: undefined,\n\t\t\t\t\t\t\tinteropNamespaceObjectUsed: false,\n\t\t\t\t\t\t\tinteropNamespaceObjectName: undefined,\n\t\t\t\t\t\t\tinteropNamespaceObject2Used: false,\n\t\t\t\t\t\t\tinteropNamespaceObject2Name: undefined,\n\t\t\t\t\t\t\tinteropDefaultAccessUsed: false,\n\t\t\t\t\t\t\tinteropDefaultAccessName: undefined\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unsupported concatenation entry type ${info.type}`\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tmap.set(\n\t\t\t\t\t/** @type {ModuleInfo} */ (item).module,\n\t\t\t\t\t/** @type {ModuleInfo} */ (item)\n\t\t\t\t);\n\t\t\t\treturn /** @type {ModuleInfo} */ (item);\n\t\t\t}\n\t\t\t/** @type {ReferenceToModuleInfo} */\n\t\t\tconst ref = {\n\t\t\t\ttype: \"reference\",\n\t\t\t\truntimeCondition: info.runtimeCondition,\n\t\t\t\ttarget: item\n\t\t\t};\n\t\t\treturn ref;\n\t\t});\n\t\treturn [list, map];\n\t}\n\n\t/**\n\t * @param {Hash} hash the hash used to track dependencies\n\t * @param {UpdateHashContext} context context\n\t * @returns {void}\n\t */\n\tupdateHash(hash, context) {\n\t\tconst { chunkGraph, runtime } = context;\n\t\tfor (const info of this._createConcatenationList(\n\t\t\tthis.rootModule,\n\t\t\tthis._modules,\n\t\t\tintersectRuntime(runtime, this._runtime),\n\t\t\tchunkGraph.moduleGraph\n\t\t)) {\n\t\t\tswitch (info.type) {\n\t\t\t\tcase \"concatenated\":\n\t\t\t\t\tinfo.module.updateHash(hash, context);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"external\":\n\t\t\t\t\thash.update(`${chunkGraph.getModuleId(info.module)}`);\n\t\t\t\t\t// TODO runtimeCondition\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsuper.updateHash(hash, context);\n\t}\n\n\t/**\n\t * @param {ObjectDeserializerContext} context context\n\t * @returns {ConcatenatedModule} ConcatenatedModule\n\t */\n\tstatic deserialize(context) {\n\t\tconst obj = new ConcatenatedModule({\n\t\t\tidentifier: /** @type {EXPECTED_ANY} */ (undefined),\n\t\t\trootModule: /** @type {EXPECTED_ANY} */ (undefined),\n\t\t\tmodules: /** @type {EXPECTED_ANY} */ (undefined),\n\t\t\truntime: undefined,\n\t\t\tcompilation: /** @type {EXPECTED_ANY} */ (undefined)\n\t\t});\n\t\tobj.deserialize(context);\n\t\treturn obj;\n\t}\n}\n\nmakeSerializable(ConcatenatedModule, \"webpack/lib/optimize/ConcatenatedModule\");\n\nmodule.exports = ConcatenatedModule;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,WAAW,GAAGC,OAAO,CAAC,cAAc,CAAC;AAC3C,MAAMC,UAAU,GAAGD,OAAO,CAAC,6BAA6B,CAAC;AACzD,MAAM;EAAEE;AAAa,CAAC,GAAGF,OAAO,CAAC,SAAS,CAAC;AAC3C,MAAM;EACLG,YAAY;EACZC,YAAY;EACZC;AACD,CAAC,GAAGL,OAAO,CAAC,iBAAiB,CAAC;AAC9B,MAAMM,kBAAkB,GAAGN,OAAO,CAAC,uBAAuB,CAAC;AAC3D,MAAM;EAAEO;AAAW,CAAC,GAAGP,OAAO,CAAC,gBAAgB,CAAC;AAChD,MAAMQ,MAAM,GAAGR,OAAO,CAAC,WAAW,CAAC;AACnC,MAAM;EAAES;AAAS,CAAC,GAAGT,OAAO,CAAC,+BAA+B,CAAC;AAC7D,MAAM;EAAEU;AAA2B,CAAC,GAAGV,OAAO,CAAC,wBAAwB,CAAC;AACxE,MAAMW,cAAc,GAAGX,OAAO,CAAC,mBAAmB,CAAC;AACnD,MAAMY,QAAQ,GAAGZ,OAAO,CAAC,aAAa,CAAC;AACvC,MAAMa,uBAAuB,GAAGb,OAAO,CAAC,yCAAyC,CAAC;AAClF,MAAMc,gBAAgB,GAAGd,OAAO,CAAC,gCAAgC,CAAC;AAClE,MAAM;EAAEe;AAAO,CAAC,GAAGf,OAAO,CAAC,sBAAsB,CAAC;AAClD,MAAMgB,OAAO,GAAGhB,OAAO,CAAC,iBAAiB,CAAC;AAC1C,MAAM;EAAEiB;AAAkB,CAAC,GAAGjB,OAAO,CAAC,qBAAqB,CAAC;AAC5D,MAAM;EACLkB,cAAc;EACdC,WAAW;EACXC,eAAe;EACfC,gBAAgB;EAChBC,YAAY;EACZC;AACD,CAAC,GAAGvB,OAAO,CAAC,qBAAqB,CAAC;AAClC,MAAMwB,UAAU,GAAGxB,OAAO,CAAC,oBAAoB,CAAC;AAChD,MAAM;EAAEyB;AAAkB,CAAC,GAAGzB,OAAO,CAAC,oBAAoB,CAAC;AAC3D,MAAM0B,gBAAgB,GAAG1B,OAAO,CAAC,0BAA0B,CAAC;AAC5D,MAAM2B,cAAc,GAAG3B,OAAO,CAAC,wBAAwB,CAAC;AACxD,MAAM;EAAE4B;AAAa,CAAC,GAAG5B,OAAO,CAAC,sBAAsB,CAAC;AACxD,MAAM;EACL6B,aAAa;EACbC,gBAAgB;EAChBC,qBAAqB;EACrBC,6BAA6B;EAC7BC,wBAAwB;EACxBC;AACD,CAAC,GAAGlC,OAAO,CAAC,iBAAiB,CAAC;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAMmC,eAAe,GAAG,kBAAoBlC,UAAW;AACvD,IAAI,CAACkC,eAAe,CAACC,SAAS,CAACC,kBAAkB,EAAE;EAClDF,eAAe,CAACC,SAAS,CAACC,kBAAkB,GAC3CF,eAAe,CAACC,SAAS,CAACE,QAAQ;AACpC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,gBAAgB,GAAGA,CAACC,QAAQ,EAAEC,UAAU,KAAK,CAACC,CAAC,EAAEC,CAAC,KACvDF,UAAU,CACTC,CAAC,EAAC,sBAAwBF,QAAQ,EAAE,EACpCG,CAAC,EAAC,sBAAwBH,QAAQ,EACnC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA,MAAMI,cAAc,GAAGA,CAACF,CAAC,EAAEC,CAAC,KAAK;EAChC,IAAIE,MAAM,CAACC,KAAK,CAAC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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}