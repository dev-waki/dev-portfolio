{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Zackary Jackson @ScriptedAlchemy\n*/\n\n\"use strict\";\n\nconst AsyncDependenciesBlock = require(\"../AsyncDependenciesBlock\");\nconst ExternalModule = require(\"../ExternalModule\");\nconst {\n  STAGE_ADVANCED\n} = require(\"../OptimizationStages\");\nconst memoize = require(\"../util/memoize\");\nconst {\n  forEachRuntime\n} = require(\"../util/runtime\");\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../Module\")} Module */\n\nconst getModuleFederationPlugin = memoize(() => require(\"./ModuleFederationPlugin\"));\nconst PLUGIN_NAME = \"HoistContainerReferences\";\n\n/**\n * This class is used to hoist container references in the code.\n */\nclass HoistContainerReferences {\n  /**\n   * Apply the plugin to the compiler.\n   * @param {Compiler} compiler The webpack compiler instance.\n   */\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap(PLUGIN_NAME, compilation => {\n      const hooks = getModuleFederationPlugin().getCompilationHooks(compilation);\n      const depsToTrace = new Set();\n      const entryExternalsToHoist = new Set();\n      hooks.addContainerEntryDependency.tap(PLUGIN_NAME, dep => {\n        depsToTrace.add(dep);\n      });\n      hooks.addFederationRuntimeDependency.tap(PLUGIN_NAME, dep => {\n        depsToTrace.add(dep);\n      });\n      compilation.hooks.addEntry.tap(PLUGIN_NAME, entryDep => {\n        if (entryDep.type === \"entry\") {\n          entryExternalsToHoist.add(entryDep);\n        }\n      });\n\n      // Hook into the optimizeChunks phase\n      compilation.hooks.optimizeChunks.tap({\n        name: PLUGIN_NAME,\n        // advanced stage is where SplitChunksPlugin runs.\n        stage: STAGE_ADVANCED + 1\n      }, chunks => {\n        this.hoistModulesInChunks(compilation, depsToTrace, entryExternalsToHoist);\n      });\n    });\n  }\n\n  /**\n   * Hoist modules in chunks.\n   * @param {Compilation} compilation The webpack compilation instance.\n   * @param {Set<Dependency>} depsToTrace Set of container entry dependencies.\n   * @param {Set<Dependency>} entryExternalsToHoist Set of container entry dependencies to hoist.\n   */\n  hoistModulesInChunks(compilation, depsToTrace, entryExternalsToHoist) {\n    const {\n      chunkGraph,\n      moduleGraph\n    } = compilation;\n\n    // loop over entry points\n    for (const dep of entryExternalsToHoist) {\n      const entryModule = moduleGraph.getModule(dep);\n      if (!entryModule) continue;\n      // get all the external module types and hoist them to the runtime chunk, this will get RemoteModule externals\n      const allReferencedModules = getAllReferencedModules(compilation, entryModule, \"external\", false);\n      const containerRuntimes = chunkGraph.getModuleRuntimes(entryModule);\n      const runtimes = new Set();\n      for (const runtimeSpec of containerRuntimes) {\n        forEachRuntime(runtimeSpec, runtimeKey => {\n          if (runtimeKey) {\n            runtimes.add(runtimeKey);\n          }\n        });\n      }\n      for (const runtime of runtimes) {\n        const runtimeChunk = compilation.namedChunks.get(runtime);\n        if (!runtimeChunk) continue;\n        for (const module of allReferencedModules) {\n          if (!chunkGraph.isModuleInChunk(module, runtimeChunk)) {\n            chunkGraph.connectChunkAndModule(runtimeChunk, module);\n          }\n        }\n      }\n      this.cleanUpChunks(compilation, allReferencedModules);\n    }\n\n    // handle container entry specifically\n    for (const dep of depsToTrace) {\n      const containerEntryModule = moduleGraph.getModule(dep);\n      if (!containerEntryModule) continue;\n      const allReferencedModules = getAllReferencedModules(compilation, containerEntryModule, \"initial\", false);\n      const allRemoteReferences = getAllReferencedModules(compilation, containerEntryModule, \"external\", false);\n      for (const remote of allRemoteReferences) {\n        allReferencedModules.add(remote);\n      }\n      const containerRuntimes = chunkGraph.getModuleRuntimes(containerEntryModule);\n      const runtimes = new Set();\n      for (const runtimeSpec of containerRuntimes) {\n        forEachRuntime(runtimeSpec, runtimeKey => {\n          if (runtimeKey) {\n            runtimes.add(runtimeKey);\n          }\n        });\n      }\n      for (const runtime of runtimes) {\n        const runtimeChunk = compilation.namedChunks.get(runtime);\n        if (!runtimeChunk) continue;\n        for (const module of allReferencedModules) {\n          if (!chunkGraph.isModuleInChunk(module, runtimeChunk)) {\n            chunkGraph.connectChunkAndModule(runtimeChunk, module);\n          }\n        }\n      }\n      this.cleanUpChunks(compilation, allReferencedModules);\n    }\n  }\n\n  /**\n   * Clean up chunks by disconnecting unused modules.\n   * @param {Compilation} compilation The webpack compilation instance.\n   * @param {Set<Module>} modules Set of modules to clean up.\n   */\n  cleanUpChunks(compilation, modules) {\n    const {\n      chunkGraph\n    } = compilation;\n    for (const module of modules) {\n      for (const chunk of chunkGraph.getModuleChunks(module)) {\n        if (!chunk.hasRuntime()) {\n          chunkGraph.disconnectChunkAndModule(chunk, module);\n          if (chunkGraph.getNumberOfChunkModules(chunk) === 0 && chunkGraph.getNumberOfEntryModules(chunk) === 0) {\n            chunkGraph.disconnectChunk(chunk);\n            compilation.chunks.delete(chunk);\n            if (chunk.name) {\n              compilation.namedChunks.delete(chunk.name);\n            }\n          }\n        }\n      }\n    }\n    modules.clear();\n  }\n}\n\n/**\n * Helper method to collect all referenced modules recursively.\n * @param {Compilation} compilation The webpack compilation instance.\n * @param {Module} module The module to start collecting from.\n * @param {string} type The type of modules to collect (\"initial\", \"external\", or \"all\").\n * @param {boolean} includeInitial Should include the referenced module passed\n * @returns {Set<Module>} Set of collected modules.\n */\nfunction getAllReferencedModules(compilation, module, type, includeInitial) {\n  const collectedModules = new Set(includeInitial ? [module] : []);\n  const visitedModules = new WeakSet([module]);\n  const stack = [module];\n  while (stack.length > 0) {\n    const currentModule = stack.pop();\n    if (!currentModule) continue;\n    const outgoingConnections = compilation.moduleGraph.getOutgoingConnections(currentModule);\n    if (outgoingConnections) {\n      for (const connection of outgoingConnections) {\n        const connectedModule = connection.module;\n\n        // Skip if module has already been visited\n        if (!connectedModule || visitedModules.has(connectedModule)) {\n          continue;\n        }\n\n        // Handle 'initial' type (skipping async blocks)\n        if (type === \"initial\") {\n          const parentBlock = compilation.moduleGraph.getParentBlock(/** @type {Dependency} */\n          connection.dependency);\n          if (parentBlock instanceof AsyncDependenciesBlock) {\n            continue;\n          }\n        }\n\n        // Handle 'external' type (collecting only external modules)\n        if (type === \"external\") {\n          if (connection.module instanceof ExternalModule) {\n            collectedModules.add(connectedModule);\n          }\n        } else {\n          // Handle 'all' or unspecified types\n          collectedModules.add(connectedModule);\n        }\n\n        // Add connected module to the stack and mark it as visited\n        visitedModules.add(connectedModule);\n        stack.push(connectedModule);\n      }\n    }\n  }\n  return collectedModules;\n}\nmodule.exports = HoistContainerReferences;","map":{"version":3,"names":["AsyncDependenciesBlock","require","ExternalModule","STAGE_ADVANCED","memoize","forEachRuntime","getModuleFederationPlugin","PLUGIN_NAME","HoistContainerReferences","apply","compiler","hooks","thisCompilation","tap","compilation","getCompilationHooks","depsToTrace","Set","entryExternalsToHoist","addContainerEntryDependency","dep","add","addFederationRuntimeDependency","addEntry","entryDep","type","optimizeChunks","name","stage","chunks","hoistModulesInChunks","chunkGraph","moduleGraph","entryModule","getModule","allReferencedModules","getAllReferencedModules","containerRuntimes","getModuleRuntimes","runtimes","runtimeSpec","runtimeKey","runtime","runtimeChunk","namedChunks","get","module","isModuleInChunk","connectChunkAndModule","cleanUpChunks","containerEntryModule","allRemoteReferences","remote","modules","chunk","getModuleChunks","hasRuntime","disconnectChunkAndModule","getNumberOfChunkModules","getNumberOfEntryModules","disconnectChunk","delete","clear","includeInitial","collectedModules","visitedModules","WeakSet","stack","length","currentModule","pop","outgoingConnections","getOutgoingConnections","connection","connectedModule","has","parentBlock","getParentBlock","dependency","push","exports"],"sources":["/home/wickliff/Desktop/dev-waki/portfolio2/node_modules/webpack/lib/container/HoistContainerReferencesPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Zackary Jackson @ScriptedAlchemy\n*/\n\n\"use strict\";\n\nconst AsyncDependenciesBlock = require(\"../AsyncDependenciesBlock\");\nconst ExternalModule = require(\"../ExternalModule\");\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\nconst memoize = require(\"../util/memoize\");\nconst { forEachRuntime } = require(\"../util/runtime\");\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../Module\")} Module */\n\nconst getModuleFederationPlugin = memoize(() =>\n\trequire(\"./ModuleFederationPlugin\")\n);\n\nconst PLUGIN_NAME = \"HoistContainerReferences\";\n\n/**\n * This class is used to hoist container references in the code.\n */\nclass HoistContainerReferences {\n\t/**\n\t * Apply the plugin to the compiler.\n\t * @param {Compiler} compiler The webpack compiler instance.\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(PLUGIN_NAME, compilation => {\n\t\t\tconst hooks =\n\t\t\t\tgetModuleFederationPlugin().getCompilationHooks(compilation);\n\t\t\tconst depsToTrace = new Set();\n\t\t\tconst entryExternalsToHoist = new Set();\n\t\t\thooks.addContainerEntryDependency.tap(PLUGIN_NAME, dep => {\n\t\t\t\tdepsToTrace.add(dep);\n\t\t\t});\n\t\t\thooks.addFederationRuntimeDependency.tap(PLUGIN_NAME, dep => {\n\t\t\t\tdepsToTrace.add(dep);\n\t\t\t});\n\n\t\t\tcompilation.hooks.addEntry.tap(PLUGIN_NAME, entryDep => {\n\t\t\t\tif (entryDep.type === \"entry\") {\n\t\t\t\t\tentryExternalsToHoist.add(entryDep);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Hook into the optimizeChunks phase\n\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t{\n\t\t\t\t\tname: PLUGIN_NAME,\n\t\t\t\t\t// advanced stage is where SplitChunksPlugin runs.\n\t\t\t\t\tstage: STAGE_ADVANCED + 1\n\t\t\t\t},\n\t\t\t\tchunks => {\n\t\t\t\t\tthis.hoistModulesInChunks(\n\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\tdepsToTrace,\n\t\t\t\t\t\tentryExternalsToHoist\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Hoist modules in chunks.\n\t * @param {Compilation} compilation The webpack compilation instance.\n\t * @param {Set<Dependency>} depsToTrace Set of container entry dependencies.\n\t * @param {Set<Dependency>} entryExternalsToHoist Set of container entry dependencies to hoist.\n\t */\n\thoistModulesInChunks(compilation, depsToTrace, entryExternalsToHoist) {\n\t\tconst { chunkGraph, moduleGraph } = compilation;\n\n\t\t// loop over entry points\n\t\tfor (const dep of entryExternalsToHoist) {\n\t\t\tconst entryModule = moduleGraph.getModule(dep);\n\t\t\tif (!entryModule) continue;\n\t\t\t// get all the external module types and hoist them to the runtime chunk, this will get RemoteModule externals\n\t\t\tconst allReferencedModules = getAllReferencedModules(\n\t\t\t\tcompilation,\n\t\t\t\tentryModule,\n\t\t\t\t\"external\",\n\t\t\t\tfalse\n\t\t\t);\n\n\t\t\tconst containerRuntimes = chunkGraph.getModuleRuntimes(entryModule);\n\t\t\tconst runtimes = new Set();\n\n\t\t\tfor (const runtimeSpec of containerRuntimes) {\n\t\t\t\tforEachRuntime(runtimeSpec, runtimeKey => {\n\t\t\t\t\tif (runtimeKey) {\n\t\t\t\t\t\truntimes.add(runtimeKey);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfor (const runtime of runtimes) {\n\t\t\t\tconst runtimeChunk = compilation.namedChunks.get(runtime);\n\t\t\t\tif (!runtimeChunk) continue;\n\n\t\t\t\tfor (const module of allReferencedModules) {\n\t\t\t\t\tif (!chunkGraph.isModuleInChunk(module, runtimeChunk)) {\n\t\t\t\t\t\tchunkGraph.connectChunkAndModule(runtimeChunk, module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.cleanUpChunks(compilation, allReferencedModules);\n\t\t}\n\n\t\t// handle container entry specifically\n\t\tfor (const dep of depsToTrace) {\n\t\t\tconst containerEntryModule = moduleGraph.getModule(dep);\n\t\t\tif (!containerEntryModule) continue;\n\t\t\tconst allReferencedModules = getAllReferencedModules(\n\t\t\t\tcompilation,\n\t\t\t\tcontainerEntryModule,\n\t\t\t\t\"initial\",\n\t\t\t\tfalse\n\t\t\t);\n\n\t\t\tconst allRemoteReferences = getAllReferencedModules(\n\t\t\t\tcompilation,\n\t\t\t\tcontainerEntryModule,\n\t\t\t\t\"external\",\n\t\t\t\tfalse\n\t\t\t);\n\n\t\t\tfor (const remote of allRemoteReferences) {\n\t\t\t\tallReferencedModules.add(remote);\n\t\t\t}\n\n\t\t\tconst containerRuntimes =\n\t\t\t\tchunkGraph.getModuleRuntimes(containerEntryModule);\n\t\t\tconst runtimes = new Set();\n\n\t\t\tfor (const runtimeSpec of containerRuntimes) {\n\t\t\t\tforEachRuntime(runtimeSpec, runtimeKey => {\n\t\t\t\t\tif (runtimeKey) {\n\t\t\t\t\t\truntimes.add(runtimeKey);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfor (const runtime of runtimes) {\n\t\t\t\tconst runtimeChunk = compilation.namedChunks.get(runtime);\n\t\t\t\tif (!runtimeChunk) continue;\n\n\t\t\t\tfor (const module of allReferencedModules) {\n\t\t\t\t\tif (!chunkGraph.isModuleInChunk(module, runtimeChunk)) {\n\t\t\t\t\t\tchunkGraph.connectChunkAndModule(runtimeChunk, module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.cleanUpChunks(compilation, allReferencedModules);\n\t\t}\n\t}\n\n\t/**\n\t * Clean up chunks by disconnecting unused modules.\n\t * @param {Compilation} compilation The webpack compilation instance.\n\t * @param {Set<Module>} modules Set of modules to clean up.\n\t */\n\tcleanUpChunks(compilation, modules) {\n\t\tconst { chunkGraph } = compilation;\n\t\tfor (const module of modules) {\n\t\t\tfor (const chunk of chunkGraph.getModuleChunks(module)) {\n\t\t\t\tif (!chunk.hasRuntime()) {\n\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\tif (\n\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(chunk) === 0 &&\n\t\t\t\t\t\tchunkGraph.getNumberOfEntryModules(chunk) === 0\n\t\t\t\t\t) {\n\t\t\t\t\t\tchunkGraph.disconnectChunk(chunk);\n\t\t\t\t\t\tcompilation.chunks.delete(chunk);\n\t\t\t\t\t\tif (chunk.name) {\n\t\t\t\t\t\t\tcompilation.namedChunks.delete(chunk.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmodules.clear();\n\t}\n}\n\n/**\n * Helper method to collect all referenced modules recursively.\n * @param {Compilation} compilation The webpack compilation instance.\n * @param {Module} module The module to start collecting from.\n * @param {string} type The type of modules to collect (\"initial\", \"external\", or \"all\").\n * @param {boolean} includeInitial Should include the referenced module passed\n * @returns {Set<Module>} Set of collected modules.\n */\nfunction getAllReferencedModules(compilation, module, type, includeInitial) {\n\tconst collectedModules = new Set(includeInitial ? [module] : []);\n\tconst visitedModules = new WeakSet([module]);\n\tconst stack = [module];\n\n\twhile (stack.length > 0) {\n\t\tconst currentModule = stack.pop();\n\t\tif (!currentModule) continue;\n\n\t\tconst outgoingConnections =\n\t\t\tcompilation.moduleGraph.getOutgoingConnections(currentModule);\n\t\tif (outgoingConnections) {\n\t\t\tfor (const connection of outgoingConnections) {\n\t\t\t\tconst connectedModule = connection.module;\n\n\t\t\t\t// Skip if module has already been visited\n\t\t\t\tif (!connectedModule || visitedModules.has(connectedModule)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Handle 'initial' type (skipping async blocks)\n\t\t\t\tif (type === \"initial\") {\n\t\t\t\t\tconst parentBlock = compilation.moduleGraph.getParentBlock(\n\t\t\t\t\t\t/** @type {Dependency} */\n\t\t\t\t\t\t(connection.dependency)\n\t\t\t\t\t);\n\t\t\t\t\tif (parentBlock instanceof AsyncDependenciesBlock) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Handle 'external' type (collecting only external modules)\n\t\t\t\tif (type === \"external\") {\n\t\t\t\t\tif (connection.module instanceof ExternalModule) {\n\t\t\t\t\t\tcollectedModules.add(connectedModule);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Handle 'all' or unspecified types\n\t\t\t\t\tcollectedModules.add(connectedModule);\n\t\t\t\t}\n\n\t\t\t\t// Add connected module to the stack and mark it as visited\n\t\t\t\tvisitedModules.add(connectedModule);\n\t\t\t\tstack.push(connectedModule);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collectedModules;\n}\n\nmodule.exports = HoistContainerReferences;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}