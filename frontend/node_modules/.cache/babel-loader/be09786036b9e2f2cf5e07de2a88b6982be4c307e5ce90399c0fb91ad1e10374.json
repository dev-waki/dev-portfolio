{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  Parser: AcornParser,\n  tokTypes\n} = require(\"acorn\");\nconst {\n  SyncBailHook,\n  HookMap\n} = require(\"tapable\");\nconst vm = require(\"vm\");\nconst Parser = require(\"../Parser\");\nconst StackedMap = require(\"../util/StackedMap\");\nconst binarySearchBounds = require(\"../util/binarySearchBounds\");\nconst {\n  webpackCommentRegExp,\n  createMagicCommentContext\n} = require(\"../util/magicComment\");\nconst memoize = require(\"../util/memoize\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n\n/** @typedef {import(\"acorn\").Options} AcornOptions */\n/** @typedef {import(\"estree\").AssignmentExpression} AssignmentExpression */\n/** @typedef {import(\"estree\").BinaryExpression} BinaryExpression */\n/** @typedef {import(\"estree\").BlockStatement} BlockStatement */\n/** @typedef {import(\"estree\").SequenceExpression} SequenceExpression */\n/** @typedef {import(\"estree\").CallExpression} CallExpression */\n/** @typedef {import(\"estree\").BaseCallExpression} BaseCallExpression */\n/** @typedef {import(\"estree\").StaticBlock} StaticBlock */\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclaration */\n/** @typedef {import(\"estree\").ForStatement} ForStatement */\n/** @typedef {import(\"estree\").SwitchStatement} SwitchStatement */\n/** @typedef {import(\"estree\").ClassExpression} ClassExpression */\n/** @typedef {import(\"estree\").Comment} Comment */\n/** @typedef {import(\"estree\").ConditionalExpression} ConditionalExpression */\n/** @typedef {import(\"estree\").Declaration} Declaration */\n/** @typedef {import(\"estree\").PrivateIdentifier} PrivateIdentifier */\n/** @typedef {import(\"estree\").PropertyDefinition} PropertyDefinition */\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"estree\").Identifier} Identifier */\n/** @typedef {import(\"estree\").VariableDeclaration} VariableDeclaration */\n/** @typedef {import(\"estree\").IfStatement} IfStatement */\n/** @typedef {import(\"estree\").LabeledStatement} LabeledStatement */\n/** @typedef {import(\"estree\").Literal} Literal */\n/** @typedef {import(\"estree\").LogicalExpression} LogicalExpression */\n/** @typedef {import(\"estree\").ChainExpression} ChainExpression */\n/** @typedef {import(\"estree\").MemberExpression} MemberExpression */\n/** @typedef {import(\"estree\").YieldExpression} YieldExpression */\n/** @typedef {import(\"estree\").MetaProperty} MetaProperty */\n/** @typedef {import(\"estree\").Property} Property */\n/** @typedef {import(\"estree\").AssignmentPattern} AssignmentPattern */\n/** @typedef {import(\"estree\").ChainElement} ChainElement */\n/** @typedef {import(\"estree\").Pattern} Pattern */\n/** @typedef {import(\"estree\").UpdateExpression} UpdateExpression */\n/** @typedef {import(\"estree\").ObjectExpression} ObjectExpression */\n/** @typedef {import(\"estree\").UnaryExpression} UnaryExpression */\n/** @typedef {import(\"estree\").ArrayExpression} ArrayExpression */\n/** @typedef {import(\"estree\").ArrayPattern} ArrayPattern */\n/** @typedef {import(\"estree\").AwaitExpression} AwaitExpression */\n/** @typedef {import(\"estree\").ThisExpression} ThisExpression */\n/** @typedef {import(\"estree\").RestElement} RestElement */\n/** @typedef {import(\"estree\").ObjectPattern} ObjectPattern */\n/** @typedef {import(\"estree\").SwitchCase} SwitchCase */\n/** @typedef {import(\"estree\").CatchClause} CatchClause */\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclarator */\n/** @typedef {import(\"estree\").ForInStatement} ForInStatement */\n/** @typedef {import(\"estree\").ForOfStatement} ForOfStatement */\n/** @typedef {import(\"estree\").ReturnStatement} ReturnStatement */\n/** @typedef {import(\"estree\").WithStatement} WithStatement */\n/** @typedef {import(\"estree\").ThrowStatement} ThrowStatement */\n/** @typedef {import(\"estree\").MethodDefinition} MethodDefinition */\n/** @typedef {import(\"estree\").NewExpression} NewExpression */\n/** @typedef {import(\"estree\").SpreadElement} SpreadElement */\n/** @typedef {import(\"estree\").FunctionExpression} FunctionExpression */\n/** @typedef {import(\"estree\").WhileStatement} WhileStatement */\n/** @typedef {import(\"estree\").ArrowFunctionExpression} ArrowFunctionExpression */\n/** @typedef {import(\"estree\").ExpressionStatement} ExpressionStatement */\n/** @typedef {import(\"estree\").FunctionDeclaration} FunctionDeclaration */\n/** @typedef {import(\"estree\").DoWhileStatement} DoWhileStatement */\n/** @typedef {import(\"estree\").TryStatement} TryStatement */\n/** @typedef {import(\"estree\").Node} Node */\n/** @typedef {import(\"estree\").Program} Program */\n/** @typedef {import(\"estree\").Directive} Directive */\n/** @typedef {import(\"estree\").Statement} Statement */\n/** @typedef {import(\"estree\").ExportDefaultDeclaration} ExportDefaultDeclaration */\n/** @typedef {import(\"estree\").Super} Super */\n/** @typedef {import(\"estree\").TaggedTemplateExpression} TaggedTemplateExpression */\n/** @typedef {import(\"estree\").TemplateLiteral} TemplateLiteral */\n/** @typedef {import(\"estree\").AssignmentProperty} AssignmentProperty */\n/**\n * @template T\n * @typedef {import(\"tapable\").AsArray<T>} AsArray<T>\n */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../Parser\").PreparsedAst} PreparsedAst */\n/** @typedef {{declaredScope: ScopeInfo, freeName: string | true | undefined, tagInfo: TagInfo | undefined}} VariableInfoInterface */\n/** @typedef {{ name: string | VariableInfo, rootInfo: string | VariableInfo, getMembers: () => string[], getMembersOptionals: () => boolean[], getMemberRanges: () => Range[] }} GetInfoResult */\n/** @typedef {Statement | ModuleDeclaration | Expression} StatementPathItem */\n/** @typedef {function(string): void} OnIdentString */\n/** @typedef {function(string, Identifier): void} OnIdent */\n/** @typedef {StatementPathItem[]} StatementPath */\n\n// TODO remove cast when @types/estree has been updated to import assertions\n/** @typedef {import(\"estree\").BaseNode & { type: \"ImportAttribute\", key: Identifier | Literal, value: Literal }} ImportAttribute */\n/** @typedef {import(\"estree\").ImportDeclaration & { attributes?: Array<ImportAttribute> }} ImportDeclaration */\n/** @typedef {import(\"estree\").ExportNamedDeclaration & { attributes?: Array<ImportAttribute> }} ExportNamedDeclaration */\n/** @typedef {import(\"estree\").ExportAllDeclaration & { attributes?: Array<ImportAttribute> }} ExportAllDeclaration */\n/** @typedef {import(\"estree\").ImportExpression & { options?: Expression | null }} ImportExpression */\n/** @typedef {ImportDeclaration | ExportNamedDeclaration | ExportDefaultDeclaration | ExportAllDeclaration} ModuleDeclaration */\n\n/** @type {string[]} */\nconst EMPTY_ARRAY = [];\nconst ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = 0b01;\nconst ALLOWED_MEMBER_TYPES_EXPRESSION = 0b10;\nconst ALLOWED_MEMBER_TYPES_ALL = 0b11;\nconst LEGACY_ASSERT_ATTRIBUTES = Symbol(\"assert\");\n\n/**\n * @param {any} Parser parser\n * @returns {typeof AcornParser} extender acorn parser\n */\nconst importAssertions = Parser => (/** @type {typeof AcornParser} */\n/** @type {unknown} */\nclass extends Parser {\n  parseWithClause() {\n    const nodes = [];\n    const isAssertLegacy = this.value === \"assert\";\n    if (isAssertLegacy) {\n      if (!this.eat(tokTypes.name)) {\n        return nodes;\n      }\n    } else if (!this.eat(tokTypes._with)) {\n      return nodes;\n    }\n    this.expect(tokTypes.braceL);\n    const attributeKeys = {};\n    let first = true;\n    while (!this.eat(tokTypes.braceR)) {\n      if (!first) {\n        this.expect(tokTypes.comma);\n        if (this.afterTrailingComma(tokTypes.braceR)) {\n          break;\n        }\n      } else {\n        first = false;\n      }\n      const attr = this.parseImportAttribute();\n      const keyName = attr.key.type === \"Identifier\" ? attr.key.name : attr.key.value;\n      if (Object.prototype.hasOwnProperty.call(attributeKeys, keyName)) {\n        this.raiseRecoverable(attr.key.start, `Duplicate attribute key '${keyName}'`);\n      }\n      attributeKeys[keyName] = true;\n      nodes.push(attr);\n    }\n    if (isAssertLegacy) {\n      nodes[LEGACY_ASSERT_ATTRIBUTES] = true;\n    }\n    return nodes;\n  }\n});\n\n// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\nconst parser = AcornParser.extend(importAssertions);\n\n/** @typedef {Record<string, string> & { _isLegacyAssert?: boolean }} ImportAttributes */\n\n/**\n * @param {ImportDeclaration | ExportNamedDeclaration | ExportAllDeclaration | ImportExpression} node node with assertions\n * @returns {ImportAttributes | undefined} import attributes\n */\nconst getImportAttributes = node => {\n  if (node.type === \"ImportExpression\") {\n    if (node.options && node.options.type === \"ObjectExpression\" && node.options.properties[0] && node.options.properties[0].type === \"Property\" && node.options.properties[0].key.type === \"Identifier\" && (node.options.properties[0].key.name === \"with\" || node.options.properties[0].key.name === \"assert\") && node.options.properties[0].value.type === \"ObjectExpression\" && node.options.properties[0].value.properties.length > 0) {\n      const properties = /** @type {Property[]} */\n      node.options.properties[0].value.properties;\n      const result = /** @type {ImportAttributes} */{};\n      for (const property of properties) {\n        const key = /** @type {string} */\n\n        property.key.type === \"Identifier\" ? property.key.name : /** @type {Literal} */property.key.value;\n        result[key] = /** @type {string} */\n        /** @type {Literal} */property.value.value;\n      }\n      const key = node.options.properties[0].key.type === \"Identifier\" ? node.options.properties[0].key.name : /** @type {Literal} */node.options.properties[0].key.value;\n      if (key === \"assert\") {\n        result._isLegacyAssert = true;\n      }\n      return result;\n    }\n    return;\n  }\n  if (node.attributes === undefined || node.attributes.length === 0) {\n    return;\n  }\n  const result = /** @type {ImportAttributes} */{};\n  for (const attribute of node.attributes) {\n    const key = /** @type {string} */\n\n    attribute.key.type === \"Identifier\" ? attribute.key.name : attribute.key.value;\n    result[key] = /** @type {string} */attribute.value.value;\n  }\n  if (node.attributes[LEGACY_ASSERT_ATTRIBUTES]) {\n    result._isLegacyAssert = true;\n  }\n  return result;\n};\nclass VariableInfo {\n  /**\n   * @param {ScopeInfo} declaredScope scope in which the variable is declared\n   * @param {string | true | undefined} freeName which free name the variable aliases, or true when none\n   * @param {TagInfo | undefined} tagInfo info about tags\n   */\n  constructor(declaredScope, freeName, tagInfo) {\n    this.declaredScope = declaredScope;\n    this.freeName = freeName;\n    this.tagInfo = tagInfo;\n  }\n}\n\n/** @typedef {string | ScopeInfo | VariableInfo} ExportedVariableInfo */\n/** @typedef {Literal | string | null | undefined} ImportSource */\n/** @typedef {Omit<AcornOptions, \"sourceType\" | \"ecmaVersion\"> & { sourceType: \"module\" | \"script\" | \"auto\", ecmaVersion?: AcornOptions[\"ecmaVersion\"] }} ParseOptions */\n\n/**\n * @typedef {object} TagInfo\n * @property {any} tag\n * @property {any} data\n * @property {TagInfo | undefined} next\n */\n\n/**\n * @typedef {object} ScopeInfo\n * @property {StackedMap<string, VariableInfo | ScopeInfo>} definitions\n * @property {boolean | \"arrow\"} topLevelScope\n * @property {boolean | string} inShorthand\n * @property {boolean} inTaggedTemplateTag\n * @property {boolean} inTry\n * @property {boolean} isStrict\n * @property {boolean} isAsmJs\n */\n\n/** @typedef {[number, number]} Range */\n\n/**\n * @typedef {object} DestructuringAssignmentProperty\n * @property {string} id\n * @property {Range | undefined=} range\n * @property {boolean | string} shorthand\n */\n\n/**\n * Helper function for joining two ranges into a single range. This is useful\n * when working with AST nodes, as it allows you to combine the ranges of child nodes\n * to create the range of the _parent node_.\n * @param {[number, number]} startRange start range to join\n * @param {[number, number]} endRange end range to join\n * @returns {[number, number]} joined range\n * @example\n * ```js\n * \tconst startRange = [0, 5];\n * \tconst endRange = [10, 15];\n * \tconst joinedRange = joinRanges(startRange, endRange);\n * \tconsole.log(joinedRange); // [0, 15]\n * ```\n */\nconst joinRanges = (startRange, endRange) => {\n  if (!endRange) return startRange;\n  if (!startRange) return endRange;\n  return [startRange[0], endRange[1]];\n};\n\n/**\n * Helper function used to generate a string representation of a\n * [member expression](https://github.com/estree/estree/blob/master/es5.md#memberexpression).\n * @param {string} object object to name\n * @param {string[]} membersReversed reversed list of members\n * @returns {string} member expression as a string\n * @example\n * ```js\n * const membersReversed = [\"property1\", \"property2\", \"property3\"]; // Members parsed from the AST\n * const name = objectAndMembersToName(\"myObject\", membersReversed);\n *\n * console.log(name); // \"myObject.property1.property2.property3\"\n * ```\n */\nconst objectAndMembersToName = (object, membersReversed) => {\n  let name = object;\n  for (let i = membersReversed.length - 1; i >= 0; i--) {\n    name = `${name}.${membersReversed[i]}`;\n  }\n  return name;\n};\n\n/**\n * Grabs the name of a given expression and returns it as a string or undefined. Has particular\n * handling for [Identifiers](https://github.com/estree/estree/blob/master/es5.md#identifier),\n * [ThisExpressions](https://github.com/estree/estree/blob/master/es5.md#identifier), and\n * [MetaProperties](https://github.com/estree/estree/blob/master/es2015.md#metaproperty) which is\n * specifically for handling the `new.target` meta property.\n * @param {Expression | SpreadElement | Super} expression expression\n * @returns {string | \"this\" | undefined} name or variable info\n */\nconst getRootName = expression => {\n  switch (expression.type) {\n    case \"Identifier\":\n      return expression.name;\n    case \"ThisExpression\":\n      return \"this\";\n    case \"MetaProperty\":\n      return `${expression.meta.name}.${expression.property.name}`;\n    default:\n      return undefined;\n  }\n};\n\n/** @type {AcornOptions} */\nconst defaultParserOptions = {\n  ranges: true,\n  locations: true,\n  ecmaVersion: \"latest\",\n  sourceType: \"module\",\n  // https://github.com/tc39/proposal-hashbang\n  allowHashBang: true,\n  onComment: undefined\n};\nconst EMPTY_COMMENT_OPTIONS = {\n  options: null,\n  errors: null\n};\nclass JavascriptParser extends Parser {\n  /**\n   * @param {\"module\" | \"script\" | \"auto\"} sourceType default source type\n   */\n  constructor(sourceType = \"auto\") {\n    super();\n    this.hooks = Object.freeze({\n      /** @type {HookMap<SyncBailHook<[UnaryExpression], BasicEvaluatedExpression | null | undefined>>} */\n      evaluateTypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n      /** @type {HookMap<SyncBailHook<[Expression | SpreadElement | PrivateIdentifier], BasicEvaluatedExpression | null | undefined>>} */\n      evaluate: new HookMap(() => new SyncBailHook([\"expression\"])),\n      /** @type {HookMap<SyncBailHook<[Identifier | ThisExpression | MemberExpression | MetaProperty], BasicEvaluatedExpression | null | undefined>>} */\n      evaluateIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n      /** @type {HookMap<SyncBailHook<[Identifier | ThisExpression | MemberExpression], BasicEvaluatedExpression | null | undefined>>} */\n      evaluateDefinedIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n      /** @type {HookMap<SyncBailHook<[NewExpression], BasicEvaluatedExpression | null | undefined>>} */\n      evaluateNewExpression: new HookMap(() => new SyncBailHook([\"expression\"])),\n      /** @type {HookMap<SyncBailHook<[CallExpression], BasicEvaluatedExpression | null | undefined>>} */\n      evaluateCallExpression: new HookMap(() => new SyncBailHook([\"expression\"])),\n      /** @type {HookMap<SyncBailHook<[CallExpression, BasicEvaluatedExpression], BasicEvaluatedExpression | null | undefined>>} */\n      evaluateCallExpressionMember: new HookMap(() => new SyncBailHook([\"expression\", \"param\"])),\n      /** @type {HookMap<SyncBailHook<[Expression | Declaration | PrivateIdentifier, number], boolean | void>>} */\n      isPure: new HookMap(() => new SyncBailHook([\"expression\", \"commentsStartPosition\"])),\n      /** @type {SyncBailHook<[Statement | ModuleDeclaration], boolean | void>} */\n      preStatement: new SyncBailHook([\"statement\"]),\n      /** @type {SyncBailHook<[Statement | ModuleDeclaration], boolean | void>} */\n      blockPreStatement: new SyncBailHook([\"declaration\"]),\n      /** @type {SyncBailHook<[Statement | ModuleDeclaration], boolean | void>} */\n      statement: new SyncBailHook([\"statement\"]),\n      /** @type {SyncBailHook<[IfStatement], boolean | void>} */\n      statementIf: new SyncBailHook([\"statement\"]),\n      /** @type {SyncBailHook<[Expression, ClassExpression | ClassDeclaration], boolean | void>} */\n      classExtendsExpression: new SyncBailHook([\"expression\", \"classDefinition\"]),\n      /** @type {SyncBailHook<[MethodDefinition | PropertyDefinition | StaticBlock, ClassExpression | ClassDeclaration], boolean | void>} */\n      classBodyElement: new SyncBailHook([\"element\", \"classDefinition\"]),\n      /** @type {SyncBailHook<[Expression, MethodDefinition | PropertyDefinition, ClassExpression | ClassDeclaration], boolean | void>} */\n      classBodyValue: new SyncBailHook([\"expression\", \"element\", \"classDefinition\"]),\n      /** @type {HookMap<SyncBailHook<[LabeledStatement], boolean | void>>} */\n      label: new HookMap(() => new SyncBailHook([\"statement\"])),\n      /** @type {SyncBailHook<[ImportDeclaration, ImportSource], boolean | void>} */\n      import: new SyncBailHook([\"statement\", \"source\"]),\n      /** @type {SyncBailHook<[ImportDeclaration, ImportSource, string | null, string], boolean | void>} */\n      importSpecifier: new SyncBailHook([\"statement\", \"source\", \"exportName\", \"identifierName\"]),\n      /** @type {SyncBailHook<[ExportDefaultDeclaration | ExportNamedDeclaration], boolean | void>} */\n      export: new SyncBailHook([\"statement\"]),\n      /** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, ImportSource], boolean | void>} */\n      exportImport: new SyncBailHook([\"statement\", \"source\"]),\n      /** @type {SyncBailHook<[ExportDefaultDeclaration | ExportNamedDeclaration | ExportAllDeclaration, Declaration], boolean | void>} */\n      exportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n      /** @type {SyncBailHook<[ExportDefaultDeclaration, FunctionDeclaration | ClassDeclaration], boolean | void>} */\n      exportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n      /** @type {SyncBailHook<[ExportDefaultDeclaration | ExportNamedDeclaration | ExportAllDeclaration, string, string, number | undefined], boolean | void>} */\n      exportSpecifier: new SyncBailHook([\"statement\", \"identifierName\", \"exportName\", \"index\"]),\n      /** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, ImportSource, string | null, string | null, number | undefined], boolean | void>} */\n      exportImportSpecifier: new SyncBailHook([\"statement\", \"source\", \"identifierName\", \"exportName\", \"index\"]),\n      /** @type {SyncBailHook<[VariableDeclarator, Statement], boolean | void>} */\n      preDeclarator: new SyncBailHook([\"declarator\", \"statement\"]),\n      /** @type {SyncBailHook<[VariableDeclarator, Statement], boolean | void>} */\n      declarator: new SyncBailHook([\"declarator\", \"statement\"]),\n      /** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */\n      varDeclaration: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      /** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */\n      varDeclarationLet: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      /** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */\n      varDeclarationConst: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      /** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */\n      varDeclarationVar: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      /** @type {HookMap<SyncBailHook<[Identifier], boolean | void>>} */\n      pattern: new HookMap(() => new SyncBailHook([\"pattern\"])),\n      /** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */\n      canRename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n      /** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */\n      rename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n      /** @type {HookMap<SyncBailHook<[AssignmentExpression], boolean | void>>} */\n      assign: new HookMap(() => new SyncBailHook([\"expression\"])),\n      /** @type {HookMap<SyncBailHook<[AssignmentExpression, string[]], boolean | void>>} */\n      assignMemberChain: new HookMap(() => new SyncBailHook([\"expression\", \"members\"])),\n      /** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */\n      typeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n      /** @type {SyncBailHook<[ImportExpression], boolean | void>} */\n      importCall: new SyncBailHook([\"expression\"]),\n      /** @type {SyncBailHook<[Expression | ForOfStatement], boolean | void>} */\n      topLevelAwait: new SyncBailHook([\"expression\"]),\n      /** @type {HookMap<SyncBailHook<[CallExpression], boolean | void>>} */\n      call: new HookMap(() => new SyncBailHook([\"expression\"])),\n      /** Something like \"a.b()\" */\n      /** @type {HookMap<SyncBailHook<[CallExpression, string[], boolean[], Range[]], boolean | void>>} */\n      callMemberChain: new HookMap(() => new SyncBailHook([\"expression\", \"members\", \"membersOptionals\", \"memberRanges\"])),\n      /** Something like \"a.b().c.d\" */\n      /** @type {HookMap<SyncBailHook<[Expression, string[], CallExpression, string[], Range[]], boolean | void>>} */\n      memberChainOfCallMemberChain: new HookMap(() => new SyncBailHook([\"expression\", \"calleeMembers\", \"callExpression\", \"members\", \"memberRanges\"])),\n      /** Something like \"a.b().c.d()\"\" */\n      /** @type {HookMap<SyncBailHook<[CallExpression, string[], CallExpression, string[], Range[]], boolean | void>>} */\n      callMemberChainOfCallMemberChain: new HookMap(() => new SyncBailHook([\"expression\", \"calleeMembers\", \"innerCallExpression\", \"members\", \"memberRanges\"])),\n      /** @type {SyncBailHook<[ChainExpression], boolean | void>} */\n      optionalChaining: new SyncBailHook([\"optionalChaining\"]),\n      /** @type {HookMap<SyncBailHook<[NewExpression], boolean | void>>} */\n      new: new HookMap(() => new SyncBailHook([\"expression\"])),\n      /** @type {SyncBailHook<[BinaryExpression], boolean | void>} */\n      binaryExpression: new SyncBailHook([\"binaryExpression\"]),\n      /** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */\n      expression: new HookMap(() => new SyncBailHook([\"expression\"])),\n      /** @type {HookMap<SyncBailHook<[MemberExpression, string[], boolean[], Range[]], boolean | void>>} */\n      expressionMemberChain: new HookMap(() => new SyncBailHook([\"expression\", \"members\", \"membersOptionals\", \"memberRanges\"])),\n      /** @type {HookMap<SyncBailHook<[MemberExpression, string[]], boolean | void>>} */\n      unhandledExpressionMemberChain: new HookMap(() => new SyncBailHook([\"expression\", \"members\"])),\n      /** @type {SyncBailHook<[ConditionalExpression], boolean | void>} */\n      expressionConditionalOperator: new SyncBailHook([\"expression\"]),\n      /** @type {SyncBailHook<[LogicalExpression], boolean | void>} */\n      expressionLogicalOperator: new SyncBailHook([\"expression\"]),\n      /** @type {SyncBailHook<[Program, Comment[]], boolean | void>} */\n      program: new SyncBailHook([\"ast\", \"comments\"]),\n      /** @type {SyncBailHook<[Program, Comment[]], boolean | void>} */\n      finish: new SyncBailHook([\"ast\", \"comments\"])\n    });\n    this.sourceType = sourceType;\n    /** @type {ScopeInfo} */\n    this.scope = undefined;\n    /** @type {ParserState} */\n    this.state = undefined;\n    /** @type {Comment[] | undefined} */\n    this.comments = undefined;\n    /** @type {Set<number> | undefined} */\n    this.semicolons = undefined;\n    /** @type {StatementPath | undefined} */\n    this.statementPath = undefined;\n    /** @type {Statement | ModuleDeclaration | Expression | undefined} */\n    this.prevStatement = undefined;\n    /** @type {WeakMap<Expression, Set<DestructuringAssignmentProperty>> | undefined} */\n    this.destructuringAssignmentProperties = undefined;\n    this.currentTagData = undefined;\n    this.magicCommentContext = createMagicCommentContext();\n    this._initializeEvaluating();\n  }\n  _initializeEvaluating() {\n    this.hooks.evaluate.for(\"Literal\").tap(\"JavascriptParser\", _expr => {\n      const expr = /** @type {Literal} */_expr;\n      switch (typeof expr.value) {\n        case \"number\":\n          return new BasicEvaluatedExpression().setNumber(expr.value).setRange(/** @type {Range} */expr.range);\n        case \"bigint\":\n          return new BasicEvaluatedExpression().setBigInt(expr.value).setRange(/** @type {Range} */expr.range);\n        case \"string\":\n          return new BasicEvaluatedExpression().setString(expr.value).setRange(/** @type {Range} */expr.range);\n        case \"boolean\":\n          return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(/** @type {Range} */expr.range);\n      }\n      if (expr.value === null) {\n        return new BasicEvaluatedExpression().setNull().setRange(/** @type {Range} */expr.range);\n      }\n      if (expr.value instanceof RegExp) {\n        return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(/** @type {Range} */expr.range);\n      }\n    });\n    this.hooks.evaluate.for(\"NewExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr = /** @type {NewExpression} */_expr;\n      const callee = expr.callee;\n      if (callee.type !== \"Identifier\") return;\n      if (callee.name !== \"RegExp\") {\n        return this.callHooksForName(this.hooks.evaluateNewExpression, callee.name, expr);\n      } else if (expr.arguments.length > 2 || this.getVariableInfo(\"RegExp\") !== \"RegExp\") return;\n      let regExp;\n      const arg1 = expr.arguments[0];\n      if (arg1) {\n        if (arg1.type === \"SpreadElement\") return;\n        const evaluatedRegExp = this.evaluateExpression(arg1);\n        if (!evaluatedRegExp) return;\n        regExp = evaluatedRegExp.asString();\n        if (!regExp) return;\n      } else {\n        return new BasicEvaluatedExpression()\n        // eslint-disable-next-line prefer-regex-literals\n        .setRegExp(new RegExp(\"\")).setRange(/** @type {Range} */expr.range);\n      }\n      let flags;\n      const arg2 = expr.arguments[1];\n      if (arg2) {\n        if (arg2.type === \"SpreadElement\") return;\n        const evaluatedFlags = this.evaluateExpression(arg2);\n        if (!evaluatedFlags) return;\n        if (!evaluatedFlags.isUndefined()) {\n          flags = evaluatedFlags.asString();\n          if (flags === undefined || !BasicEvaluatedExpression.isValidRegExpFlags(flags)) return;\n        }\n      }\n      return new BasicEvaluatedExpression().setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp)).setRange(/** @type {Range} */expr.range);\n    });\n    this.hooks.evaluate.for(\"LogicalExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr = /** @type {LogicalExpression} */_expr;\n      const left = this.evaluateExpression(expr.left);\n      let returnRight = false;\n      /** @type {boolean | undefined} */\n      let allowedRight;\n      if (expr.operator === \"&&\") {\n        const leftAsBool = left.asBool();\n        if (leftAsBool === false) return left.setRange(/** @type {Range} */expr.range);\n        returnRight = leftAsBool === true;\n        allowedRight = false;\n      } else if (expr.operator === \"||\") {\n        const leftAsBool = left.asBool();\n        if (leftAsBool === true) return left.setRange(/** @type {Range} */expr.range);\n        returnRight = leftAsBool === false;\n        allowedRight = true;\n      } else if (expr.operator === \"??\") {\n        const leftAsNullish = left.asNullish();\n        if (leftAsNullish === false) return left.setRange(/** @type {Range} */expr.range);\n        if (leftAsNullish !== true) return;\n        returnRight = true;\n      } else return;\n      const right = this.evaluateExpression(expr.right);\n      if (returnRight) {\n        if (left.couldHaveSideEffects()) right.setSideEffects();\n        return right.setRange(/** @type {Range} */expr.range);\n      }\n      const asBool = right.asBool();\n      if (allowedRight === true && asBool === true) {\n        return new BasicEvaluatedExpression().setRange(/** @type {Range} */expr.range).setTruthy();\n      } else if (allowedRight === false && asBool === false) {\n        return new BasicEvaluatedExpression().setRange(/** @type {Range} */expr.range).setFalsy();\n      }\n    });\n\n    /**\n     * In simple logical cases, we can use valueAsExpression to assist us in evaluating the expression on\n     * either side of a [BinaryExpression](https://github.com/estree/estree/blob/master/es5.md#binaryexpression).\n     * This supports scenarios in webpack like conditionally `import()`'ing modules based on some simple evaluation:\n     *\n     * ```js\n     * if (1 === 3) {\n     *  import(\"./moduleA\"); // webpack will auto evaluate this and not import the modules\n     * }\n     * ```\n     *\n     * Additional scenarios include evaluation of strings inside of dynamic import statements:\n     *\n     * ```js\n     * const foo = \"foo\";\n     * const bar = \"bar\";\n     *\n     * import(\"./\" + foo + bar); // webpack will auto evaluate this into import(\"./foobar\")\n     * ```\n     * @param {boolean | number | bigint | string} value the value to convert to an expression\n     * @param {BinaryExpression | UnaryExpression} expr the expression being evaluated\n     * @param {boolean} sideEffects whether the expression has side effects\n     * @returns {BasicEvaluatedExpression | undefined} the evaluated expression\n     * @example\n     *\n     * ```js\n     * const binaryExpr = new BinaryExpression(\"+\",\n     * \t{ type: \"Literal\", value: 2 },\n     * \t{ type: \"Literal\", value: 3 }\n     * );\n     *\n     * const leftValue = 2;\n     * const rightValue = 3;\n     *\n     * const leftExpr = valueAsExpression(leftValue, binaryExpr.left, false);\n     * const rightExpr = valueAsExpression(rightValue, binaryExpr.right, false);\n     * const result = new BasicEvaluatedExpression()\n     * \t.setNumber(leftExpr.number + rightExpr.number)\n     * \t.setRange(binaryExpr.range);\n     *\n     * console.log(result.number); // Output: 5\n     * ```\n     */\n    const valueAsExpression = (value, expr, sideEffects) => {\n      switch (typeof value) {\n        case \"boolean\":\n          return new BasicEvaluatedExpression().setBoolean(value).setSideEffects(sideEffects).setRange(/** @type {Range} */expr.range);\n        case \"number\":\n          return new BasicEvaluatedExpression().setNumber(value).setSideEffects(sideEffects).setRange(/** @type {Range} */expr.range);\n        case \"bigint\":\n          return new BasicEvaluatedExpression().setBigInt(value).setSideEffects(sideEffects).setRange(/** @type {Range} */expr.range);\n        case \"string\":\n          return new BasicEvaluatedExpression().setString(value).setSideEffects(sideEffects).setRange(/** @type {Range} */expr.range);\n      }\n    };\n    this.hooks.evaluate.for(\"BinaryExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr = /** @type {BinaryExpression} */_expr;\n\n      /**\n       * Evaluates a binary expression if and only if it is a const operation (e.g. 1 + 2, \"a\" + \"b\", etc.).\n       * @template T\n       * @param {(leftOperand: T, rightOperand: T) => boolean | number | bigint | string} operandHandler the handler for the operation (e.g. (a, b) => a + b)\n       * @returns {BasicEvaluatedExpression | undefined} the evaluated expression\n       */\n      const handleConstOperation = operandHandler => {\n        const left = this.evaluateExpression(expr.left);\n        if (!left.isCompileTimeValue()) return;\n        const right = this.evaluateExpression(expr.right);\n        if (!right.isCompileTimeValue()) return;\n        const result = operandHandler(left.asCompileTimeValue(), right.asCompileTimeValue());\n        return valueAsExpression(result, expr, left.couldHaveSideEffects() || right.couldHaveSideEffects());\n      };\n\n      /**\n       * Helper function to determine if two booleans are always different. This is used in `handleStrictEqualityComparison`\n       * to determine if an expressions boolean or nullish conversion is equal or not.\n       * @param {boolean} a first boolean to compare\n       * @param {boolean} b second boolean to compare\n       * @returns {boolean} true if the two booleans are always different, false otherwise\n       */\n      const isAlwaysDifferent = (a, b) => a === true && b === false || a === false && b === true;\n\n      /**\n       * @param {BasicEvaluatedExpression} left left\n       * @param {BasicEvaluatedExpression} right right\n       * @param {BasicEvaluatedExpression} res res\n       * @param {boolean} eql true for \"===\" and false for \"!==\"\n       * @returns {BasicEvaluatedExpression | undefined} result\n       */\n      const handleTemplateStringCompare = (left, right, res, eql) => {\n        /**\n         * @param {BasicEvaluatedExpression[]} parts parts\n         * @returns {string} value\n         */\n        const getPrefix = parts => {\n          let value = \"\";\n          for (const p of parts) {\n            const v = p.asString();\n            if (v !== undefined) value += v;else break;\n          }\n          return value;\n        };\n        /**\n         * @param {BasicEvaluatedExpression[]} parts parts\n         * @returns {string} value\n         */\n        const getSuffix = parts => {\n          let value = \"\";\n          for (let i = parts.length - 1; i >= 0; i--) {\n            const v = parts[i].asString();\n            if (v !== undefined) value = v + value;else break;\n          }\n          return value;\n        };\n        const leftPrefix = getPrefix(/** @type {BasicEvaluatedExpression[]} */left.parts);\n        const rightPrefix = getPrefix(/** @type {BasicEvaluatedExpression[]} */right.parts);\n        const leftSuffix = getSuffix(/** @type {BasicEvaluatedExpression[]} */left.parts);\n        const rightSuffix = getSuffix(/** @type {BasicEvaluatedExpression[]} */right.parts);\n        const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);\n        const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);\n        const prefixMismatch = lenPrefix > 0 && leftPrefix.slice(0, lenPrefix) !== rightPrefix.slice(0, lenPrefix);\n        const suffixMismatch = lenSuffix > 0 && leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix);\n        if (prefixMismatch || suffixMismatch) {\n          return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        }\n      };\n\n      /**\n       * Helper function to handle BinaryExpressions using strict equality comparisons (e.g. \"===\" and \"!==\").\n       * @param {boolean} eql true for \"===\" and false for \"!==\"\n       * @returns {BasicEvaluatedExpression | undefined} the evaluated expression\n       */\n      const handleStrictEqualityComparison = eql => {\n        const left = this.evaluateExpression(expr.left);\n        const right = this.evaluateExpression(expr.right);\n        const res = new BasicEvaluatedExpression();\n        res.setRange(/** @type {Range} */expr.range);\n        const leftConst = left.isCompileTimeValue();\n        const rightConst = right.isCompileTimeValue();\n        if (leftConst && rightConst) {\n          return res.setBoolean(eql === (left.asCompileTimeValue() === right.asCompileTimeValue())).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        }\n        if (left.isArray() && right.isArray()) {\n          return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        }\n        if (left.isTemplateString() && right.isTemplateString()) {\n          return handleTemplateStringCompare(left, right, res, eql);\n        }\n        const leftPrimitive = left.isPrimitiveType();\n        const rightPrimitive = right.isPrimitiveType();\n        if (\n        // Primitive !== Object or\n        // compile-time object types are never equal to something at runtime\n        leftPrimitive === false && (leftConst || rightPrimitive === true) || rightPrimitive === false && (rightConst || leftPrimitive === true) ||\n        // Different nullish or boolish status also means not equal\n        isAlwaysDifferent(/** @type {boolean} */left.asBool(), /** @type {boolean} */right.asBool()) || isAlwaysDifferent(/** @type {boolean} */left.asNullish(), /** @type {boolean} */right.asNullish())) {\n          return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        }\n      };\n\n      /**\n       * Helper function to handle BinaryExpressions using abstract equality comparisons (e.g. \"==\" and \"!=\").\n       * @param {boolean} eql true for \"==\" and false for \"!=\"\n       * @returns {BasicEvaluatedExpression | undefined} the evaluated expression\n       */\n      const handleAbstractEqualityComparison = eql => {\n        const left = this.evaluateExpression(expr.left);\n        const right = this.evaluateExpression(expr.right);\n        const res = new BasicEvaluatedExpression();\n        res.setRange(/** @type {Range} */expr.range);\n        const leftConst = left.isCompileTimeValue();\n        const rightConst = right.isCompileTimeValue();\n        if (leftConst && rightConst) {\n          return res.setBoolean(eql === (\n          // eslint-disable-next-line eqeqeq\n          left.asCompileTimeValue() == right.asCompileTimeValue())).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        }\n        if (left.isArray() && right.isArray()) {\n          return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        }\n        if (left.isTemplateString() && right.isTemplateString()) {\n          return handleTemplateStringCompare(left, right, res, eql);\n        }\n      };\n      if (expr.operator === \"+\") {\n        const left = this.evaluateExpression(expr.left);\n        const right = this.evaluateExpression(expr.right);\n        const res = new BasicEvaluatedExpression();\n        if (left.isString()) {\n          if (right.isString()) {\n            res.setString(/** @type {string} */left.string + (/** @type {string} */right.string));\n          } else if (right.isNumber()) {\n            res.setString(/** @type {string} */left.string + right.number);\n          } else if (right.isWrapped() && right.prefix && right.prefix.isString()) {\n            // \"left\" + (\"prefix\" + inner + \"postfix\")\n            // => (\"leftPrefix\" + inner + \"postfix\")\n            res.setWrapped(new BasicEvaluatedExpression().setString(/** @type {string} */left.string + (/** @type {string} */right.prefix.string)).setRange(joinRanges(/** @type {Range} */left.range, /** @type {Range} */right.prefix.range)), right.postfix, right.wrappedInnerExpressions);\n          } else if (right.isWrapped()) {\n            // \"left\" + ([null] + inner + \"postfix\")\n            // => (\"left\" + inner + \"postfix\")\n            res.setWrapped(left, right.postfix, right.wrappedInnerExpressions);\n          } else {\n            // \"left\" + expr\n            // => (\"left\" + expr + \"\")\n            res.setWrapped(left, null, [right]);\n          }\n        } else if (left.isNumber()) {\n          if (right.isString()) {\n            res.setString(left.number + (/** @type {string} */right.string));\n          } else if (right.isNumber()) {\n            res.setNumber(/** @type {number} */left.number + (/** @type {number} */right.number));\n          } else {\n            return;\n          }\n        } else if (left.isBigInt()) {\n          if (right.isBigInt()) {\n            res.setBigInt(/** @type {bigint} */left.bigint + (/** @type {bigint} */right.bigint));\n          }\n        } else if (left.isWrapped()) {\n          if (left.postfix && left.postfix.isString() && right.isString()) {\n            // (\"prefix\" + inner + \"postfix\") + \"right\"\n            // => (\"prefix\" + inner + \"postfixRight\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(/** @type {string} */left.postfix.string + (/** @type {string} */right.string)).setRange(joinRanges(/** @type {Range} */left.postfix.range, /** @type {Range} */right.range)), left.wrappedInnerExpressions);\n          } else if (left.postfix && left.postfix.isString() && right.isNumber()) {\n            // (\"prefix\" + inner + \"postfix\") + 123\n            // => (\"prefix\" + inner + \"postfix123\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(/** @type {string} */left.postfix.string + (/** @type {number} */right.number)).setRange(joinRanges(/** @type {Range} */left.postfix.range, /** @type {Range} */right.range)), left.wrappedInnerExpressions);\n          } else if (right.isString()) {\n            // (\"prefix\" + inner + [null]) + \"right\"\n            // => (\"prefix\" + inner + \"right\")\n            res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n          } else if (right.isNumber()) {\n            // (\"prefix\" + inner + [null]) + 123\n            // => (\"prefix\" + inner + \"123\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(String(right.number)).setRange(/** @type {Range} */right.range), left.wrappedInnerExpressions);\n          } else if (right.isWrapped()) {\n            // (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n            // (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n            res.setWrapped(left.prefix, right.postfix, left.wrappedInnerExpressions && right.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix] : []).concat(right.prefix ? [right.prefix] : []).concat(right.wrappedInnerExpressions));\n          } else {\n            // (\"prefix\" + inner + postfix) + expr\n            // => (\"prefix\" + inner + postfix + expr + [null])\n            res.setWrapped(left.prefix, null, left.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix, right] : [right]));\n          }\n        } else if (right.isString()) {\n          // left + \"right\"\n          // => ([null] + left + \"right\")\n          res.setWrapped(null, right, [left]);\n        } else if (right.isWrapped()) {\n          // left + (prefix + inner + \"postfix\")\n          // => ([null] + left + prefix + inner + \"postfix\")\n          res.setWrapped(null, right.postfix, right.wrappedInnerExpressions && (right.prefix ? [left, right.prefix] : [left]).concat(right.wrappedInnerExpressions));\n        } else {\n          return;\n        }\n        if (left.couldHaveSideEffects() || right.couldHaveSideEffects()) res.setSideEffects();\n        res.setRange(/** @type {Range} */expr.range);\n        return res;\n      } else if (expr.operator === \"-\") {\n        return handleConstOperation((l, r) => l - r);\n      } else if (expr.operator === \"*\") {\n        return handleConstOperation((l, r) => l * r);\n      } else if (expr.operator === \"/\") {\n        return handleConstOperation((l, r) => l / r);\n      } else if (expr.operator === \"**\") {\n        return handleConstOperation((l, r) => l ** r);\n      } else if (expr.operator === \"===\") {\n        return handleStrictEqualityComparison(true);\n      } else if (expr.operator === \"==\") {\n        return handleAbstractEqualityComparison(true);\n      } else if (expr.operator === \"!==\") {\n        return handleStrictEqualityComparison(false);\n      } else if (expr.operator === \"!=\") {\n        return handleAbstractEqualityComparison(false);\n      } else if (expr.operator === \"&\") {\n        return handleConstOperation((l, r) => l & r);\n      } else if (expr.operator === \"|\") {\n        return handleConstOperation((l, r) => l | r);\n      } else if (expr.operator === \"^\") {\n        return handleConstOperation((l, r) => l ^ r);\n      } else if (expr.operator === \">>>\") {\n        return handleConstOperation((l, r) => l >>> r);\n      } else if (expr.operator === \">>\") {\n        return handleConstOperation((l, r) => l >> r);\n      } else if (expr.operator === \"<<\") {\n        return handleConstOperation((l, r) => l << r);\n      } else if (expr.operator === \"<\") {\n        return handleConstOperation((l, r) => l < r);\n      } else if (expr.operator === \">\") {\n        return handleConstOperation((l, r) => l > r);\n      } else if (expr.operator === \"<=\") {\n        return handleConstOperation((l, r) => l <= r);\n      } else if (expr.operator === \">=\") {\n        return handleConstOperation((l, r) => l >= r);\n      }\n    });\n    this.hooks.evaluate.for(\"UnaryExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr = /** @type {UnaryExpression} */_expr;\n\n      /**\n       * Evaluates a UnaryExpression if and only if it is a basic const operator (e.g. +a, -a, ~a).\n       * @template T\n       * @param {(operand: T) => boolean | number | bigint | string} operandHandler handler for the operand\n       * @returns {BasicEvaluatedExpression | undefined} evaluated expression\n       */\n      const handleConstOperation = operandHandler => {\n        const argument = this.evaluateExpression(expr.argument);\n        if (!argument.isCompileTimeValue()) return;\n        const result = operandHandler(argument.asCompileTimeValue());\n        return valueAsExpression(result, expr, argument.couldHaveSideEffects());\n      };\n      if (expr.operator === \"typeof\") {\n        switch (expr.argument.type) {\n          case \"Identifier\":\n            {\n              const res = this.callHooksForName(this.hooks.evaluateTypeof, expr.argument.name, expr);\n              if (res !== undefined) return res;\n              break;\n            }\n          case \"MetaProperty\":\n            {\n              const res = this.callHooksForName(this.hooks.evaluateTypeof, /** @type {string} */getRootName(expr.argument), expr);\n              if (res !== undefined) return res;\n              break;\n            }\n          case \"MemberExpression\":\n            {\n              const res = this.callHooksForExpression(this.hooks.evaluateTypeof, expr.argument, expr);\n              if (res !== undefined) return res;\n              break;\n            }\n          case \"ChainExpression\":\n            {\n              const res = this.callHooksForExpression(this.hooks.evaluateTypeof, expr.argument.expression, expr);\n              if (res !== undefined) return res;\n              break;\n            }\n          case \"FunctionExpression\":\n            {\n              return new BasicEvaluatedExpression().setString(\"function\").setRange(/** @type {Range} */expr.range);\n            }\n        }\n        const arg = this.evaluateExpression(expr.argument);\n        if (arg.isUnknown()) return;\n        if (arg.isString()) {\n          return new BasicEvaluatedExpression().setString(\"string\").setRange(/** @type {Range} */expr.range);\n        }\n        if (arg.isWrapped()) {\n          return new BasicEvaluatedExpression().setString(\"string\").setSideEffects().setRange(/** @type {Range} */expr.range);\n        }\n        if (arg.isUndefined()) {\n          return new BasicEvaluatedExpression().setString(\"undefined\").setRange(/** @type {Range} */expr.range);\n        }\n        if (arg.isNumber()) {\n          return new BasicEvaluatedExpression().setString(\"number\").setRange(/** @type {Range} */expr.range);\n        }\n        if (arg.isBigInt()) {\n          return new BasicEvaluatedExpression().setString(\"bigint\").setRange(/** @type {Range} */expr.range);\n        }\n        if (arg.isBoolean()) {\n          return new BasicEvaluatedExpression().setString(\"boolean\").setRange(/** @type {Range} */expr.range);\n        }\n        if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {\n          return new BasicEvaluatedExpression().setString(\"object\").setRange(/** @type {Range} */expr.range);\n        }\n        if (arg.isArray()) {\n          return new BasicEvaluatedExpression().setString(\"object\").setSideEffects(arg.couldHaveSideEffects()).setRange(/** @type {Range} */expr.range);\n        }\n      } else if (expr.operator === \"!\") {\n        const argument = this.evaluateExpression(expr.argument);\n        const bool = argument.asBool();\n        if (typeof bool !== \"boolean\") return;\n        return new BasicEvaluatedExpression().setBoolean(!bool).setSideEffects(argument.couldHaveSideEffects()).setRange(/** @type {Range} */expr.range);\n      } else if (expr.operator === \"~\") {\n        return handleConstOperation(v => ~v);\n      } else if (expr.operator === \"+\") {\n        // eslint-disable-next-line no-implicit-coercion\n        return handleConstOperation(v => +v);\n      } else if (expr.operator === \"-\") {\n        return handleConstOperation(v => -v);\n      }\n    });\n    this.hooks.evaluateTypeof.for(\"undefined\").tap(\"JavascriptParser\", expr => new BasicEvaluatedExpression().setString(\"undefined\").setRange(/** @type {Range} */expr.range));\n    this.hooks.evaluate.for(\"Identifier\").tap(\"JavascriptParser\", expr => {\n      if (/** @type {Identifier} */expr.name === \"undefined\") {\n        return new BasicEvaluatedExpression().setUndefined().setRange(/** @type {Range} */expr.range);\n      }\n    });\n    /**\n     * @param {\"Identifier\" | \"ThisExpression\" | \"MemberExpression\"} exprType expression type name\n     * @param {function(Expression | SpreadElement): GetInfoResult | undefined} getInfo get info\n     * @returns {void}\n     */\n    const tapEvaluateWithVariableInfo = (exprType, getInfo) => {\n      /** @type {Expression | undefined} */\n      let cachedExpression;\n      /** @type {GetInfoResult | undefined} */\n      let cachedInfo;\n      this.hooks.evaluate.for(exprType).tap(\"JavascriptParser\", expr => {\n        const expression = /** @type {Identifier | ThisExpression | MemberExpression} */expr;\n        const info = getInfo(expression);\n        if (info !== undefined) {\n          return this.callHooksForInfoWithFallback(this.hooks.evaluateIdentifier, info.name, name => {\n            cachedExpression = expression;\n            cachedInfo = info;\n          }, name => {\n            const hook = this.hooks.evaluateDefinedIdentifier.get(name);\n            if (hook !== undefined) {\n              return hook.call(expression);\n            }\n          }, expression);\n        }\n      });\n      this.hooks.evaluate.for(exprType).tap({\n        name: \"JavascriptParser\",\n        stage: 100\n      }, expr => {\n        const expression = /** @type {Identifier | ThisExpression | MemberExpression} */\n        expr;\n        const info = cachedExpression === expression ? cachedInfo : getInfo(expression);\n        if (info !== undefined) {\n          return new BasicEvaluatedExpression().setIdentifier(info.name, info.rootInfo, info.getMembers, info.getMembersOptionals, info.getMemberRanges).setRange(/** @type {Range} */expression.range);\n        }\n      });\n      this.hooks.finish.tap(\"JavascriptParser\", () => {\n        // Cleanup for GC\n        cachedExpression = cachedInfo = undefined;\n      });\n    };\n    tapEvaluateWithVariableInfo(\"Identifier\", expr => {\n      const info = this.getVariableInfo(/** @type {Identifier} */expr.name);\n      if (typeof info === \"string\" || info instanceof VariableInfo && typeof info.freeName === \"string\") {\n        return {\n          name: info,\n          rootInfo: info,\n          getMembers: () => [],\n          getMembersOptionals: () => [],\n          getMemberRanges: () => []\n        };\n      }\n    });\n    tapEvaluateWithVariableInfo(\"ThisExpression\", expr => {\n      const info = this.getVariableInfo(\"this\");\n      if (typeof info === \"string\" || info instanceof VariableInfo && typeof info.freeName === \"string\") {\n        return {\n          name: info,\n          rootInfo: info,\n          getMembers: () => [],\n          getMembersOptionals: () => [],\n          getMemberRanges: () => []\n        };\n      }\n    });\n    this.hooks.evaluate.for(\"MetaProperty\").tap(\"JavascriptParser\", expr => {\n      const metaProperty = /** @type {MetaProperty} */expr;\n      return this.callHooksForName(this.hooks.evaluateIdentifier, /** @type {string} */getRootName(metaProperty), metaProperty);\n    });\n    tapEvaluateWithVariableInfo(\"MemberExpression\", expr => this.getMemberExpressionInfo(/** @type {MemberExpression} */expr, ALLOWED_MEMBER_TYPES_EXPRESSION));\n    this.hooks.evaluate.for(\"CallExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr = /** @type {CallExpression} */_expr;\n      if (expr.callee.type === \"MemberExpression\" && expr.callee.property.type === (expr.callee.computed ? \"Literal\" : \"Identifier\")) {\n        // type Super also possible here\n        const param = this.evaluateExpression(/** @type {Expression} */expr.callee.object);\n        const property = expr.callee.property.type === \"Literal\" ? `${expr.callee.property.value}` : expr.callee.property.name;\n        const hook = this.hooks.evaluateCallExpressionMember.get(property);\n        if (hook !== undefined) {\n          return hook.call(expr, param);\n        }\n      } else if (expr.callee.type === \"Identifier\") {\n        return this.callHooksForName(this.hooks.evaluateCallExpression, expr.callee.name, expr);\n      }\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"indexOf\").tap(\"JavascriptParser\", (expr, param) => {\n      if (!param.isString()) return;\n      if (expr.arguments.length === 0) return;\n      const [arg1, arg2] = expr.arguments;\n      if (arg1.type === \"SpreadElement\") return;\n      const arg1Eval = this.evaluateExpression(arg1);\n      if (!arg1Eval.isString()) return;\n      const arg1Value = /** @type {string} */arg1Eval.string;\n      let result;\n      if (arg2) {\n        if (arg2.type === \"SpreadElement\") return;\n        const arg2Eval = this.evaluateExpression(arg2);\n        if (!arg2Eval.isNumber()) return;\n        result = /** @type {string} */param.string.indexOf(arg1Value, arg2Eval.number);\n      } else {\n        result = /** @type {string} */param.string.indexOf(arg1Value);\n      }\n      return new BasicEvaluatedExpression().setNumber(result).setSideEffects(param.couldHaveSideEffects()).setRange(/** @type {Range} */expr.range);\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"replace\").tap(\"JavascriptParser\", (expr, param) => {\n      if (!param.isString()) return;\n      if (expr.arguments.length !== 2) return;\n      if (expr.arguments[0].type === \"SpreadElement\") return;\n      if (expr.arguments[1].type === \"SpreadElement\") return;\n      const arg1 = this.evaluateExpression(expr.arguments[0]);\n      const arg2 = this.evaluateExpression(expr.arguments[1]);\n      if (!arg1.isString() && !arg1.isRegExp()) return;\n      const arg1Value = /** @type {string | RegExp} */\n      arg1.regExp || arg1.string;\n      if (!arg2.isString()) return;\n      const arg2Value = /** @type {string} */arg2.string;\n      return new BasicEvaluatedExpression().setString(/** @type {string} */param.string.replace(arg1Value, arg2Value)).setSideEffects(param.couldHaveSideEffects()).setRange(/** @type {Range} */expr.range);\n    });\n    for (const fn of [\"substr\", \"substring\", \"slice\"]) {\n      this.hooks.evaluateCallExpressionMember.for(fn).tap(\"JavascriptParser\", (expr, param) => {\n        if (!param.isString()) return;\n        let arg1;\n        let result;\n        const str = /** @type {string} */param.string;\n        switch (expr.arguments.length) {\n          case 1:\n            if (expr.arguments[0].type === \"SpreadElement\") return;\n            arg1 = this.evaluateExpression(expr.arguments[0]);\n            if (!arg1.isNumber()) return;\n            result = str[(/** @type {\"substr\" | \"substring\" | \"slice\"} */fn)](/** @type {number} */arg1.number);\n            break;\n          case 2:\n            {\n              if (expr.arguments[0].type === \"SpreadElement\") return;\n              if (expr.arguments[1].type === \"SpreadElement\") return;\n              arg1 = this.evaluateExpression(expr.arguments[0]);\n              const arg2 = this.evaluateExpression(expr.arguments[1]);\n              if (!arg1.isNumber()) return;\n              if (!arg2.isNumber()) return;\n              result = str[(/** @type {\"substr\" | \"substring\" | \"slice\"} */fn)](/** @type {number} */arg1.number, /** @type {number} */arg2.number);\n              break;\n            }\n          default:\n            return;\n        }\n        return new BasicEvaluatedExpression().setString(result).setSideEffects(param.couldHaveSideEffects()).setRange(/** @type {Range} */expr.range);\n      });\n    }\n\n    /**\n     * @param {\"cooked\" | \"raw\"} kind kind of values to get\n     * @param {TemplateLiteral} templateLiteralExpr TemplateLiteral expr\n     * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n     */\n    const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {\n      /** @type {BasicEvaluatedExpression[]} */\n      const quasis = [];\n      /** @type {BasicEvaluatedExpression[]} */\n      const parts = [];\n      for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {\n        const quasiExpr = templateLiteralExpr.quasis[i];\n        const quasi = quasiExpr.value[kind];\n        if (i > 0) {\n          const prevExpr = parts[parts.length - 1];\n          const expr = this.evaluateExpression(templateLiteralExpr.expressions[i - 1]);\n          const exprAsString = expr.asString();\n          if (typeof exprAsString === \"string\" && !expr.couldHaveSideEffects()) {\n            // We can merge quasi + expr + quasi when expr\n            // is a const string\n\n            prevExpr.setString(prevExpr.string + exprAsString + quasi);\n            prevExpr.setRange([/** @type {Range} */prevExpr.range[0], /** @type {Range} */quasiExpr.range[1]]);\n            // We unset the expression as it doesn't match to a single expression\n            prevExpr.setExpression(undefined);\n            continue;\n          }\n          parts.push(expr);\n        }\n        const part = new BasicEvaluatedExpression().setString(/** @type {string} */quasi).setRange(/** @type {Range} */quasiExpr.range).setExpression(quasiExpr);\n        quasis.push(part);\n        parts.push(part);\n      }\n      return {\n        quasis,\n        parts\n      };\n    };\n    this.hooks.evaluate.for(\"TemplateLiteral\").tap(\"JavascriptParser\", _node => {\n      const node = /** @type {TemplateLiteral} */_node;\n      const {\n        quasis,\n        parts\n      } = getSimplifiedTemplateResult(\"cooked\", node);\n      if (parts.length === 1) {\n        return parts[0].setRange(/** @type {Range} */node.range);\n      }\n      return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"cooked\").setRange(/** @type {Range} */node.range);\n    });\n    this.hooks.evaluate.for(\"TaggedTemplateExpression\").tap(\"JavascriptParser\", _node => {\n      const node = /** @type {TaggedTemplateExpression} */_node;\n      const tag = this.evaluateExpression(node.tag);\n      if (tag.isIdentifier() && tag.identifier === \"String.raw\") {\n        const {\n          quasis,\n          parts\n        } = getSimplifiedTemplateResult(\"raw\", node.quasi);\n        return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"raw\").setRange(/** @type {Range} */node.range);\n      }\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"concat\").tap(\"JavascriptParser\", (expr, param) => {\n      if (!param.isString() && !param.isWrapped()) return;\n      let stringSuffix = null;\n      let hasUnknownParams = false;\n      const innerExpressions = [];\n      for (let i = expr.arguments.length - 1; i >= 0; i--) {\n        const arg = expr.arguments[i];\n        if (arg.type === \"SpreadElement\") return;\n        const argExpr = this.evaluateExpression(arg);\n        if (hasUnknownParams || !argExpr.isString() && !argExpr.isNumber()) {\n          hasUnknownParams = true;\n          innerExpressions.push(argExpr);\n          continue;\n        }\n\n        /** @type {string} */\n        const value = argExpr.isString() ? (/** @type {string} */argExpr.string) : String(/** @type {number} */argExpr.number);\n\n        /** @type {string} */\n        const newString = value + (stringSuffix ? stringSuffix.string : \"\");\n        const newRange = /** @type {Range} */[/** @type {Range} */argExpr.range[0], /** @type {Range} */(stringSuffix || argExpr).range[1]];\n        stringSuffix = new BasicEvaluatedExpression().setString(newString).setSideEffects(stringSuffix && stringSuffix.couldHaveSideEffects() || argExpr.couldHaveSideEffects()).setRange(newRange);\n      }\n      if (hasUnknownParams) {\n        const prefix = param.isString() ? param : param.prefix;\n        const inner = param.isWrapped() && param.wrappedInnerExpressions ? param.wrappedInnerExpressions.concat(innerExpressions.reverse()) : innerExpressions.reverse();\n        return new BasicEvaluatedExpression().setWrapped(prefix, stringSuffix, inner).setRange(/** @type {Range} */expr.range);\n      } else if (param.isWrapped()) {\n        const postfix = stringSuffix || param.postfix;\n        const inner = param.wrappedInnerExpressions ? param.wrappedInnerExpressions.concat(innerExpressions.reverse()) : innerExpressions.reverse();\n        return new BasicEvaluatedExpression().setWrapped(param.prefix, postfix, inner).setRange(/** @type {Range} */expr.range);\n      }\n      const newString = /** @type {string} */param.string + (stringSuffix ? stringSuffix.string : \"\");\n      return new BasicEvaluatedExpression().setString(newString).setSideEffects(stringSuffix && stringSuffix.couldHaveSideEffects() || param.couldHaveSideEffects()).setRange(/** @type {Range} */expr.range);\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"split\").tap(\"JavascriptParser\", (expr, param) => {\n      if (!param.isString()) return;\n      if (expr.arguments.length !== 1) return;\n      if (expr.arguments[0].type === \"SpreadElement\") return;\n      let result;\n      const arg = this.evaluateExpression(expr.arguments[0]);\n      if (arg.isString()) {\n        result = /** @type {string} */\n        param.string.split(/** @type {string} */arg.string);\n      } else if (arg.isRegExp()) {\n        result = /** @type {string} */param.string.split(/** @type {RegExp} */arg.regExp);\n      } else {\n        return;\n      }\n      return new BasicEvaluatedExpression().setArray(result).setSideEffects(param.couldHaveSideEffects()).setRange(/** @type {Range} */expr.range);\n    });\n    this.hooks.evaluate.for(\"ConditionalExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr = /** @type {ConditionalExpression} */_expr;\n      const condition = this.evaluateExpression(expr.test);\n      const conditionValue = condition.asBool();\n      let res;\n      if (conditionValue === undefined) {\n        const consequent = this.evaluateExpression(expr.consequent);\n        const alternate = this.evaluateExpression(expr.alternate);\n        res = new BasicEvaluatedExpression();\n        if (consequent.isConditional()) {\n          res.setOptions(/** @type {BasicEvaluatedExpression[]} */consequent.options);\n        } else {\n          res.setOptions([consequent]);\n        }\n        if (alternate.isConditional()) {\n          res.addOptions(/** @type {BasicEvaluatedExpression[]} */alternate.options);\n        } else {\n          res.addOptions([alternate]);\n        }\n      } else {\n        res = this.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);\n        if (condition.couldHaveSideEffects()) res.setSideEffects();\n      }\n      res.setRange(/** @type {Range} */expr.range);\n      return res;\n    });\n    this.hooks.evaluate.for(\"ArrayExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr = /** @type {ArrayExpression} */_expr;\n      const items = expr.elements.map(element => element !== null && element.type !== \"SpreadElement\" && this.evaluateExpression(element));\n      if (!items.every(Boolean)) return;\n      return new BasicEvaluatedExpression().setItems(/** @type {BasicEvaluatedExpression[]} */items).setRange(/** @type {Range} */expr.range);\n    });\n    this.hooks.evaluate.for(\"ChainExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr = /** @type {ChainExpression} */_expr;\n      /** @type {Expression[]} */\n      const optionalExpressionsStack = [];\n      /** @type {Expression|Super} */\n      let next = expr.expression;\n      while (next.type === \"MemberExpression\" || next.type === \"CallExpression\") {\n        if (next.type === \"MemberExpression\") {\n          if (next.optional) {\n            // SuperNode can not be optional\n            optionalExpressionsStack.push(/** @type {Expression} */next.object);\n          }\n          next = next.object;\n        } else {\n          if (next.optional) {\n            // SuperNode can not be optional\n            optionalExpressionsStack.push(/** @type {Expression} */next.callee);\n          }\n          next = next.callee;\n        }\n      }\n      while (optionalExpressionsStack.length > 0) {\n        const expression = /** @type {Expression} */\n        optionalExpressionsStack.pop();\n        const evaluated = this.evaluateExpression(expression);\n        if (evaluated.asNullish()) {\n          return evaluated.setRange(/** @type {Range} */_expr.range);\n        }\n      }\n      return this.evaluateExpression(expr.expression);\n    });\n  }\n\n  /**\n   * @param {Expression} node node\n   * @returns {Set<DestructuringAssignmentProperty> | undefined} destructured identifiers\n   */\n  destructuringAssignmentPropertiesFor(node) {\n    if (!this.destructuringAssignmentProperties) return;\n    return this.destructuringAssignmentProperties.get(node);\n  }\n\n  /**\n   * @param {Expression | SpreadElement} expr expression\n   * @returns {string | VariableInfoInterface | undefined} identifier\n   */\n  getRenameIdentifier(expr) {\n    const result = this.evaluateExpression(expr);\n    if (result.isIdentifier()) {\n      return result.identifier;\n    }\n  }\n\n  /**\n   * @param {ClassExpression | ClassDeclaration} classy a class node\n   * @returns {void}\n   */\n  walkClass(classy) {\n    if (classy.superClass && !this.hooks.classExtendsExpression.call(classy.superClass, classy)) {\n      this.walkExpression(classy.superClass);\n    }\n    if (classy.body && classy.body.type === \"ClassBody\") {\n      const scopeParams = [];\n      // Add class name in scope for recursive calls\n      if (classy.id) {\n        scopeParams.push(classy.id);\n      }\n      this.inClassScope(true, scopeParams, () => {\n        for (const classElement of (/** @type {TODO} */classy.body.body)) {\n          if (!this.hooks.classBodyElement.call(classElement, classy)) {\n            if (classElement.computed && classElement.key) {\n              this.walkExpression(classElement.key);\n            }\n            if (classElement.value) {\n              if (!this.hooks.classBodyValue.call(classElement.value, classElement, classy)) {\n                const wasTopLevel = this.scope.topLevelScope;\n                this.scope.topLevelScope = false;\n                this.walkExpression(classElement.value);\n                this.scope.topLevelScope = wasTopLevel;\n              }\n            } else if (classElement.type === \"StaticBlock\") {\n              const wasTopLevel = this.scope.topLevelScope;\n              this.scope.topLevelScope = false;\n              this.walkBlockStatement(classElement);\n              this.scope.topLevelScope = wasTopLevel;\n            }\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Pre walking iterates the scope for variable declarations\n   * @param {(Statement | ModuleDeclaration)[]} statements statements\n   */\n  preWalkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.preWalkStatement(statement);\n    }\n  }\n\n  /**\n   * Block pre walking iterates the scope for block variable declarations\n   * @param {(Statement | ModuleDeclaration)[]} statements statements\n   */\n  blockPreWalkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.blockPreWalkStatement(statement);\n    }\n  }\n\n  /**\n   * Walking iterates the statements and expressions and processes them\n   * @param {(Statement | ModuleDeclaration)[]} statements statements\n   */\n  walkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.walkStatement(statement);\n    }\n  }\n\n  /**\n   * Walking iterates the statements and expressions and processes them\n   * @param {Statement | ModuleDeclaration} statement statement\n   */\n  preWalkStatement(statement) {\n    /** @type {StatementPath} */\n    this.statementPath.push(statement);\n    if (this.hooks.preStatement.call(statement)) {\n      this.prevStatement = /** @type {StatementPath} */\n      this.statementPath.pop();\n      return;\n    }\n    switch (statement.type) {\n      case \"BlockStatement\":\n        this.preWalkBlockStatement(statement);\n        break;\n      case \"DoWhileStatement\":\n        this.preWalkDoWhileStatement(statement);\n        break;\n      case \"ForInStatement\":\n        this.preWalkForInStatement(statement);\n        break;\n      case \"ForOfStatement\":\n        this.preWalkForOfStatement(statement);\n        break;\n      case \"ForStatement\":\n        this.preWalkForStatement(statement);\n        break;\n      case \"FunctionDeclaration\":\n        this.preWalkFunctionDeclaration(statement);\n        break;\n      case \"IfStatement\":\n        this.preWalkIfStatement(statement);\n        break;\n      case \"LabeledStatement\":\n        this.preWalkLabeledStatement(statement);\n        break;\n      case \"SwitchStatement\":\n        this.preWalkSwitchStatement(statement);\n        break;\n      case \"TryStatement\":\n        this.preWalkTryStatement(statement);\n        break;\n      case \"VariableDeclaration\":\n        this.preWalkVariableDeclaration(statement);\n        break;\n      case \"WhileStatement\":\n        this.preWalkWhileStatement(statement);\n        break;\n      case \"WithStatement\":\n        this.preWalkWithStatement(statement);\n        break;\n    }\n    this.prevStatement = /** @type {StatementPath} */\n    this.statementPath.pop();\n  }\n\n  /**\n   * @param {Statement | ModuleDeclaration} statement statement\n   */\n  blockPreWalkStatement(statement) {\n    /** @type {StatementPath} */\n    this.statementPath.push(statement);\n    if (this.hooks.blockPreStatement.call(statement)) {\n      this.prevStatement = /** @type {StatementPath} */\n      this.statementPath.pop();\n      return;\n    }\n    switch (statement.type) {\n      case \"ImportDeclaration\":\n        this.blockPreWalkImportDeclaration(statement);\n        break;\n      case \"ExportAllDeclaration\":\n        this.blockPreWalkExportAllDeclaration(statement);\n        break;\n      case \"ExportDefaultDeclaration\":\n        this.blockPreWalkExportDefaultDeclaration(statement);\n        break;\n      case \"ExportNamedDeclaration\":\n        this.blockPreWalkExportNamedDeclaration(statement);\n        break;\n      case \"VariableDeclaration\":\n        this.blockPreWalkVariableDeclaration(statement);\n        break;\n      case \"ClassDeclaration\":\n        this.blockPreWalkClassDeclaration(statement);\n        break;\n      case \"ExpressionStatement\":\n        this.blockPreWalkExpressionStatement(statement);\n    }\n    this.prevStatement = /** @type {StatementPath} */\n    this.statementPath.pop();\n  }\n\n  /**\n   * @param {Statement | ModuleDeclaration} statement statement\n   */\n  walkStatement(statement) {\n    /** @type {StatementPath} */\n    this.statementPath.push(statement);\n    if (this.hooks.statement.call(statement) !== undefined) {\n      this.prevStatement = /** @type {StatementPath} */\n      this.statementPath.pop();\n      return;\n    }\n    switch (statement.type) {\n      case \"BlockStatement\":\n        this.walkBlockStatement(statement);\n        break;\n      case \"ClassDeclaration\":\n        this.walkClassDeclaration(statement);\n        break;\n      case \"DoWhileStatement\":\n        this.walkDoWhileStatement(statement);\n        break;\n      case \"ExportDefaultDeclaration\":\n        this.walkExportDefaultDeclaration(statement);\n        break;\n      case \"ExportNamedDeclaration\":\n        this.walkExportNamedDeclaration(statement);\n        break;\n      case \"ExpressionStatement\":\n        this.walkExpressionStatement(statement);\n        break;\n      case \"ForInStatement\":\n        this.walkForInStatement(statement);\n        break;\n      case \"ForOfStatement\":\n        this.walkForOfStatement(statement);\n        break;\n      case \"ForStatement\":\n        this.walkForStatement(statement);\n        break;\n      case \"FunctionDeclaration\":\n        this.walkFunctionDeclaration(statement);\n        break;\n      case \"IfStatement\":\n        this.walkIfStatement(statement);\n        break;\n      case \"LabeledStatement\":\n        this.walkLabeledStatement(statement);\n        break;\n      case \"ReturnStatement\":\n        this.walkReturnStatement(statement);\n        break;\n      case \"SwitchStatement\":\n        this.walkSwitchStatement(statement);\n        break;\n      case \"ThrowStatement\":\n        this.walkThrowStatement(statement);\n        break;\n      case \"TryStatement\":\n        this.walkTryStatement(statement);\n        break;\n      case \"VariableDeclaration\":\n        this.walkVariableDeclaration(statement);\n        break;\n      case \"WhileStatement\":\n        this.walkWhileStatement(statement);\n        break;\n      case \"WithStatement\":\n        this.walkWithStatement(statement);\n        break;\n    }\n    this.prevStatement = /** @type {StatementPath} */\n    this.statementPath.pop();\n  }\n\n  /**\n   * Walks a statements that is nested within a parent statement\n   * and can potentially be a non-block statement.\n   * This enforces the nested statement to never be in ASI position.\n   * @param {Statement} statement the nested statement\n   */\n  walkNestedStatement(statement) {\n    this.prevStatement = undefined;\n    this.walkStatement(statement);\n  }\n\n  // Real Statements\n  /**\n   * @param {BlockStatement} statement block statement\n   */\n  preWalkBlockStatement(statement) {\n    this.preWalkStatements(statement.body);\n  }\n\n  /**\n   * @param {BlockStatement} statement block statement\n   */\n  walkBlockStatement(statement) {\n    this.inBlockScope(() => {\n      const body = statement.body;\n      const prev = this.prevStatement;\n      this.blockPreWalkStatements(body);\n      this.prevStatement = prev;\n      this.walkStatements(body);\n    });\n  }\n\n  /**\n   * @param {ExpressionStatement} statement expression statement\n   */\n  walkExpressionStatement(statement) {\n    this.walkExpression(statement.expression);\n  }\n\n  /**\n   * @param {IfStatement} statement if statement\n   */\n  preWalkIfStatement(statement) {\n    this.preWalkStatement(statement.consequent);\n    if (statement.alternate) {\n      this.preWalkStatement(statement.alternate);\n    }\n  }\n\n  /**\n   * @param {IfStatement} statement if statement\n   */\n  walkIfStatement(statement) {\n    const result = this.hooks.statementIf.call(statement);\n    if (result === undefined) {\n      this.walkExpression(statement.test);\n      this.walkNestedStatement(statement.consequent);\n      if (statement.alternate) {\n        this.walkNestedStatement(statement.alternate);\n      }\n    } else if (result) {\n      this.walkNestedStatement(statement.consequent);\n    } else if (statement.alternate) {\n      this.walkNestedStatement(statement.alternate);\n    }\n  }\n\n  /**\n   * @param {LabeledStatement} statement with statement\n   */\n  preWalkLabeledStatement(statement) {\n    this.preWalkStatement(statement.body);\n  }\n\n  /**\n   * @param {LabeledStatement} statement with statement\n   */\n  walkLabeledStatement(statement) {\n    const hook = this.hooks.label.get(statement.label.name);\n    if (hook !== undefined) {\n      const result = hook.call(statement);\n      if (result === true) return;\n    }\n    this.walkNestedStatement(statement.body);\n  }\n\n  /**\n   * @param {WithStatement} statement with statement\n   */\n  preWalkWithStatement(statement) {\n    this.preWalkStatement(statement.body);\n  }\n\n  /**\n   * @param {WithStatement} statement with statement\n   */\n  walkWithStatement(statement) {\n    this.walkExpression(statement.object);\n    this.walkNestedStatement(statement.body);\n  }\n\n  /**\n   * @param {SwitchStatement} statement switch statement\n   */\n  preWalkSwitchStatement(statement) {\n    this.preWalkSwitchCases(statement.cases);\n  }\n\n  /**\n   * @param {SwitchStatement} statement switch statement\n   */\n  walkSwitchStatement(statement) {\n    this.walkExpression(statement.discriminant);\n    this.walkSwitchCases(statement.cases);\n  }\n\n  /**\n   * @param {ReturnStatement | ThrowStatement} statement return or throw statement\n   */\n  walkTerminatingStatement(statement) {\n    if (statement.argument) this.walkExpression(statement.argument);\n  }\n\n  /**\n   * @param {ReturnStatement} statement return statement\n   */\n  walkReturnStatement(statement) {\n    this.walkTerminatingStatement(statement);\n  }\n\n  /**\n   * @param {ThrowStatement} statement return statement\n   */\n  walkThrowStatement(statement) {\n    this.walkTerminatingStatement(statement);\n  }\n\n  /**\n   * @param {TryStatement} statement try statement\n   */\n  preWalkTryStatement(statement) {\n    this.preWalkStatement(statement.block);\n    if (statement.handler) this.preWalkCatchClause(statement.handler);\n    if (statement.finalizer) this.preWalkStatement(statement.finalizer);\n  }\n\n  /**\n   * @param {TryStatement} statement try statement\n   */\n  walkTryStatement(statement) {\n    if (this.scope.inTry) {\n      this.walkStatement(statement.block);\n    } else {\n      this.scope.inTry = true;\n      this.walkStatement(statement.block);\n      this.scope.inTry = false;\n    }\n    if (statement.handler) this.walkCatchClause(statement.handler);\n    if (statement.finalizer) this.walkStatement(statement.finalizer);\n  }\n\n  /**\n   * @param {WhileStatement} statement while statement\n   */\n  preWalkWhileStatement(statement) {\n    this.preWalkStatement(statement.body);\n  }\n\n  /**\n   * @param {WhileStatement} statement while statement\n   */\n  walkWhileStatement(statement) {\n    this.walkExpression(statement.test);\n    this.walkNestedStatement(statement.body);\n  }\n\n  /**\n   * @param {DoWhileStatement} statement do while statement\n   */\n  preWalkDoWhileStatement(statement) {\n    this.preWalkStatement(statement.body);\n  }\n\n  /**\n   * @param {DoWhileStatement} statement do while statement\n   */\n  walkDoWhileStatement(statement) {\n    this.walkNestedStatement(statement.body);\n    this.walkExpression(statement.test);\n  }\n\n  /**\n   * @param {ForStatement} statement for statement\n   */\n  preWalkForStatement(statement) {\n    if (statement.init && statement.init.type === \"VariableDeclaration\") {\n      this.preWalkStatement(statement.init);\n    }\n    this.preWalkStatement(statement.body);\n  }\n\n  /**\n   * @param {ForStatement} statement for statement\n   */\n  walkForStatement(statement) {\n    this.inBlockScope(() => {\n      if (statement.init) {\n        if (statement.init.type === \"VariableDeclaration\") {\n          this.blockPreWalkVariableDeclaration(statement.init);\n          this.prevStatement = undefined;\n          this.walkStatement(statement.init);\n        } else {\n          this.walkExpression(statement.init);\n        }\n      }\n      if (statement.test) {\n        this.walkExpression(statement.test);\n      }\n      if (statement.update) {\n        this.walkExpression(statement.update);\n      }\n      const body = statement.body;\n      if (body.type === \"BlockStatement\") {\n        // no need to add additional scope\n        const prev = this.prevStatement;\n        this.blockPreWalkStatements(body.body);\n        this.prevStatement = prev;\n        this.walkStatements(body.body);\n      } else {\n        this.walkNestedStatement(body);\n      }\n    });\n  }\n\n  /**\n   * @param {ForInStatement} statement for statement\n   */\n  preWalkForInStatement(statement) {\n    if (statement.left.type === \"VariableDeclaration\") {\n      this.preWalkVariableDeclaration(statement.left);\n    }\n    this.preWalkStatement(statement.body);\n  }\n\n  /**\n   * @param {ForInStatement} statement for statement\n   */\n  walkForInStatement(statement) {\n    this.inBlockScope(() => {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.blockPreWalkVariableDeclaration(statement.left);\n        this.walkVariableDeclaration(statement.left);\n      } else {\n        this.walkPattern(statement.left);\n      }\n      this.walkExpression(statement.right);\n      const body = statement.body;\n      if (body.type === \"BlockStatement\") {\n        // no need to add additional scope\n        const prev = this.prevStatement;\n        this.blockPreWalkStatements(body.body);\n        this.prevStatement = prev;\n        this.walkStatements(body.body);\n      } else {\n        this.walkNestedStatement(body);\n      }\n    });\n  }\n\n  /**\n   * @param {ForOfStatement} statement statement\n   */\n  preWalkForOfStatement(statement) {\n    if (statement.await && this.scope.topLevelScope === true) {\n      this.hooks.topLevelAwait.call(statement);\n    }\n    if (statement.left.type === \"VariableDeclaration\") {\n      this.preWalkVariableDeclaration(statement.left);\n    }\n    this.preWalkStatement(statement.body);\n  }\n\n  /**\n   * @param {ForOfStatement} statement for statement\n   */\n  walkForOfStatement(statement) {\n    this.inBlockScope(() => {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.blockPreWalkVariableDeclaration(statement.left);\n        this.walkVariableDeclaration(statement.left);\n      } else {\n        this.walkPattern(statement.left);\n      }\n      this.walkExpression(statement.right);\n      const body = statement.body;\n      if (body.type === \"BlockStatement\") {\n        // no need to add additional scope\n        const prev = this.prevStatement;\n        this.blockPreWalkStatements(body.body);\n        this.prevStatement = prev;\n        this.walkStatements(body.body);\n      } else {\n        this.walkNestedStatement(body);\n      }\n    });\n  }\n\n  /**\n   * @param {FunctionDeclaration} statement function declaration\n   */\n  preWalkFunctionDeclaration(statement) {\n    if (statement.id) {\n      this.defineVariable(statement.id.name);\n    }\n  }\n\n  /**\n   * @param {FunctionDeclaration} statement function declaration\n   */\n  walkFunctionDeclaration(statement) {\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = false;\n    this.inFunctionScope(true, statement.params, () => {\n      for (const param of statement.params) {\n        this.walkPattern(param);\n      }\n      if (statement.body.type === \"BlockStatement\") {\n        this.detectMode(statement.body.body);\n        const prev = this.prevStatement;\n        this.preWalkStatement(statement.body);\n        this.prevStatement = prev;\n        this.walkStatement(statement.body);\n      } else {\n        this.walkExpression(statement.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n\n  /**\n   * @param {ExpressionStatement} statement expression statement\n   */\n  blockPreWalkExpressionStatement(statement) {\n    const expression = statement.expression;\n    switch (expression.type) {\n      case \"AssignmentExpression\":\n        this.preWalkAssignmentExpression(expression);\n    }\n  }\n\n  /**\n   * @param {AssignmentExpression} expression assignment expression\n   */\n  preWalkAssignmentExpression(expression) {\n    if (expression.left.type !== \"ObjectPattern\" || !this.destructuringAssignmentProperties) return;\n    const keys = this._preWalkObjectPattern(expression.left);\n    if (!keys) return;\n\n    // check multiple assignments\n    if (this.destructuringAssignmentProperties.has(expression)) {\n      const set = /** @type {Set<DestructuringAssignmentProperty>} */\n      this.destructuringAssignmentProperties.get(expression);\n      this.destructuringAssignmentProperties.delete(expression);\n      for (const id of set) keys.add(id);\n    }\n    this.destructuringAssignmentProperties.set(expression.right.type === \"AwaitExpression\" ? expression.right.argument : expression.right, keys);\n    if (expression.right.type === \"AssignmentExpression\") {\n      this.preWalkAssignmentExpression(expression.right);\n    }\n  }\n\n  /**\n   * @param {ImportDeclaration} statement statement\n   */\n  blockPreWalkImportDeclaration(statement) {\n    const source = /** @type {ImportSource} */statement.source.value;\n    this.hooks.import.call(statement, source);\n    for (const specifier of statement.specifiers) {\n      const name = specifier.local.name;\n      switch (specifier.type) {\n        case \"ImportDefaultSpecifier\":\n          if (!this.hooks.importSpecifier.call(statement, source, \"default\", name)) {\n            this.defineVariable(name);\n          }\n          break;\n        case \"ImportSpecifier\":\n          if (!this.hooks.importSpecifier.call(statement, source, /** @type {Identifier} */\n          specifier.imported.name || (/** @type {string} */\n\n          /** @type {Literal} */\n          specifier.imported.value), name)) {\n            this.defineVariable(name);\n          }\n          break;\n        case \"ImportNamespaceSpecifier\":\n          if (!this.hooks.importSpecifier.call(statement, source, null, name)) {\n            this.defineVariable(name);\n          }\n          break;\n        default:\n          this.defineVariable(name);\n      }\n    }\n  }\n\n  /**\n   * @param {Declaration} declaration declaration\n   * @param {OnIdent} onIdent on ident callback\n   */\n  enterDeclaration(declaration, onIdent) {\n    switch (declaration.type) {\n      case \"VariableDeclaration\":\n        for (const declarator of declaration.declarations) {\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                this.enterPattern(declarator.id, onIdent);\n                break;\n              }\n          }\n        }\n        break;\n      case \"FunctionDeclaration\":\n        this.enterPattern(declaration.id, onIdent);\n        break;\n      case \"ClassDeclaration\":\n        this.enterPattern(declaration.id, onIdent);\n        break;\n    }\n  }\n\n  /**\n   * @param {ExportNamedDeclaration} statement statement\n   */\n  blockPreWalkExportNamedDeclaration(statement) {\n    let source;\n    if (statement.source) {\n      source = /** @type {ImportSource} */statement.source.value;\n      this.hooks.exportImport.call(statement, source);\n    } else {\n      this.hooks.export.call(statement);\n    }\n    if (statement.declaration && !this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n      const prev = this.prevStatement;\n      this.preWalkStatement(statement.declaration);\n      this.prevStatement = prev;\n      this.blockPreWalkStatement(statement.declaration);\n      let index = 0;\n      this.enterDeclaration(statement.declaration, def => {\n        this.hooks.exportSpecifier.call(statement, def, def, index++);\n      });\n    }\n    if (statement.specifiers) {\n      for (let specifierIndex = 0; specifierIndex < statement.specifiers.length; specifierIndex++) {\n        const specifier = statement.specifiers[specifierIndex];\n        switch (specifier.type) {\n          case \"ExportSpecifier\":\n            {\n              const localName = /** @type {Identifier} */specifier.local.name || (/** @type {string} */\n              /** @type {Literal} */specifier.local.value);\n              const name = /** @type {Identifier} */\n              specifier.exported.name || (/** @type {string} */\n              /** @type {Literal} */specifier.exported.value);\n              if (source) {\n                this.hooks.exportImportSpecifier.call(statement, source, localName, name, specifierIndex);\n              } else {\n                this.hooks.exportSpecifier.call(statement, localName, name, specifierIndex);\n              }\n              break;\n            }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {ExportNamedDeclaration} statement the statement\n   */\n  walkExportNamedDeclaration(statement) {\n    if (statement.declaration) {\n      this.walkStatement(statement.declaration);\n    }\n  }\n\n  /**\n   * @param {TODO} statement statement\n   */\n  blockPreWalkExportDefaultDeclaration(statement) {\n    const prev = this.prevStatement;\n    this.preWalkStatement(statement.declaration);\n    this.prevStatement = prev;\n    this.blockPreWalkStatement(statement.declaration);\n    if (/** @type {FunctionDeclaration | ClassDeclaration} */statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n      const declaration = /** @type {FunctionDeclaration | ClassDeclaration} */\n      statement.declaration;\n      this.hooks.exportSpecifier.call(statement, declaration.id.name, \"default\", undefined);\n    }\n  }\n\n  /**\n   * @param {ExportDefaultDeclaration} statement statement\n   */\n  walkExportDefaultDeclaration(statement) {\n    this.hooks.export.call(statement);\n    if (/** @type {FunctionDeclaration | ClassDeclaration} */statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n      const declaration = /** @type {FunctionDeclaration | ClassDeclaration} */\n      statement.declaration;\n      if (!this.hooks.exportDeclaration.call(statement, declaration)) {\n        this.walkStatement(declaration);\n      }\n    } else {\n      // Acorn parses `export default function() {}` as `FunctionDeclaration` and\n      // `export default class {}` as `ClassDeclaration`, both with `id = null`.\n      // These nodes must be treated as expressions.\n      if (statement.declaration.type === \"FunctionDeclaration\" || statement.declaration.type === \"ClassDeclaration\") {\n        this.walkStatement(/** @type {FunctionDeclaration | ClassDeclaration} */\n        statement.declaration);\n      } else {\n        this.walkExpression(statement.declaration);\n      }\n      if (!this.hooks.exportExpression.call(statement, /** @type {TODO} */statement.declaration)) {\n        this.hooks.exportSpecifier.call(statement, /** @type {TODO} */statement.declaration, \"default\", undefined);\n      }\n    }\n  }\n\n  /**\n   * @param {ExportAllDeclaration} statement statement\n   */\n  blockPreWalkExportAllDeclaration(statement) {\n    const source = /** @type {ImportSource} */statement.source.value;\n    const name = statement.exported ? /** @type {Identifier} */\n    statement.exported.name || (/** @type {string} */\n    /** @type {Literal} */statement.exported.value) : null;\n    this.hooks.exportImport.call(statement, source);\n    this.hooks.exportImportSpecifier.call(statement, source, null, name, 0);\n  }\n\n  /**\n   * @param {VariableDeclaration} statement variable declaration\n   */\n  preWalkVariableDeclaration(statement) {\n    if (statement.kind !== \"var\") return;\n    this._preWalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n  }\n\n  /**\n   * @param {VariableDeclaration} statement variable declaration\n   */\n  blockPreWalkVariableDeclaration(statement) {\n    if (statement.kind === \"var\") return;\n    const hookMap = statement.kind === \"const\" ? this.hooks.varDeclarationConst : this.hooks.varDeclarationLet;\n    this._preWalkVariableDeclaration(statement, hookMap);\n  }\n\n  /**\n   * @param {VariableDeclaration} statement variable declaration\n   * @param {TODO} hookMap map of hooks\n   */\n  _preWalkVariableDeclaration(statement, hookMap) {\n    for (const declarator of statement.declarations) {\n      switch (declarator.type) {\n        case \"VariableDeclarator\":\n          {\n            this.preWalkVariableDeclarator(declarator);\n            if (!this.hooks.preDeclarator.call(declarator, statement)) {\n              this.enterPattern(declarator.id, (name, decl) => {\n                let hook = hookMap.get(name);\n                if (hook === undefined || !hook.call(decl)) {\n                  hook = this.hooks.varDeclaration.get(name);\n                  if (hook === undefined || !hook.call(decl)) {\n                    this.defineVariable(name);\n                  }\n                }\n              });\n            }\n            break;\n          }\n      }\n    }\n  }\n\n  /**\n   * @param {ObjectPattern} objectPattern object pattern\n   * @returns {Set<DestructuringAssignmentProperty> | undefined} set of names or undefined if not all keys are identifiers\n   */\n  _preWalkObjectPattern(objectPattern) {\n    /** @type {Set<DestructuringAssignmentProperty>} */\n    const props = new Set();\n    const properties = objectPattern.properties;\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (property.type !== \"Property\") return;\n      if (property.shorthand && property.value.type === \"Identifier\") {\n        this.scope.inShorthand = property.value.name;\n      }\n      const key = property.key;\n      if (key.type === \"Identifier\") {\n        props.add({\n          id: key.name,\n          range: key.range,\n          shorthand: this.scope.inShorthand\n        });\n      } else {\n        const id = this.evaluateExpression(key);\n        const str = id.asString();\n        if (str) {\n          props.add({\n            id: str,\n            range: key.range,\n            shorthand: this.scope.inShorthand\n          });\n        } else {\n          // could not evaluate key\n          return;\n        }\n      }\n      this.scope.inShorthand = false;\n    }\n    return props;\n  }\n\n  /**\n   * @param {VariableDeclarator} declarator variable declarator\n   */\n  preWalkVariableDeclarator(declarator) {\n    if (!declarator.init || declarator.id.type !== \"ObjectPattern\" || !this.destructuringAssignmentProperties) return;\n    const keys = this._preWalkObjectPattern(declarator.id);\n    if (!keys) return;\n    this.destructuringAssignmentProperties.set(declarator.init.type === \"AwaitExpression\" ? declarator.init.argument : declarator.init, keys);\n    if (declarator.init.type === \"AssignmentExpression\") {\n      this.preWalkAssignmentExpression(declarator.init);\n    }\n  }\n\n  /**\n   * @param {VariableDeclaration} statement variable declaration\n   */\n  walkVariableDeclaration(statement) {\n    for (const declarator of statement.declarations) {\n      switch (declarator.type) {\n        case \"VariableDeclarator\":\n          {\n            const renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);\n            if (renameIdentifier && declarator.id.type === \"Identifier\") {\n              const hook = this.hooks.canRename.get(renameIdentifier);\n              if (hook !== undefined && hook.call(/** @type {Expression} */declarator.init)) {\n                // renaming with \"var a = b;\"\n                const hook = this.hooks.rename.get(renameIdentifier);\n                if (hook === undefined || !hook.call(/** @type {Expression} */declarator.init)) {\n                  this.setVariable(declarator.id.name, renameIdentifier);\n                }\n                break;\n              }\n            }\n            if (!this.hooks.declarator.call(declarator, statement)) {\n              this.walkPattern(declarator.id);\n              if (declarator.init) this.walkExpression(declarator.init);\n            }\n            break;\n          }\n      }\n    }\n  }\n\n  /**\n   * @param {ClassDeclaration} statement class declaration\n   */\n  blockPreWalkClassDeclaration(statement) {\n    if (statement.id) {\n      this.defineVariable(statement.id.name);\n    }\n  }\n\n  /**\n   * @param {ClassDeclaration} statement class declaration\n   */\n  walkClassDeclaration(statement) {\n    this.walkClass(statement);\n  }\n\n  /**\n   * @param {SwitchCase[]} switchCases switch statement\n   */\n  preWalkSwitchCases(switchCases) {\n    for (let index = 0, len = switchCases.length; index < len; index++) {\n      const switchCase = switchCases[index];\n      this.preWalkStatements(switchCase.consequent);\n    }\n  }\n\n  /**\n   * @param {SwitchCase[]} switchCases switch statement\n   */\n  walkSwitchCases(switchCases) {\n    this.inBlockScope(() => {\n      const len = switchCases.length;\n\n      // we need to pre walk all statements first since we can have invalid code\n      // import A from \"module\";\n      // switch(1) {\n      //    case 1:\n      //      console.log(A); // should fail at runtime\n      //    case 2:\n      //      const A = 1;\n      // }\n      for (let index = 0; index < len; index++) {\n        const switchCase = switchCases[index];\n        if (switchCase.consequent.length > 0) {\n          const prev = this.prevStatement;\n          this.blockPreWalkStatements(switchCase.consequent);\n          this.prevStatement = prev;\n        }\n      }\n      for (let index = 0; index < len; index++) {\n        const switchCase = switchCases[index];\n        if (switchCase.test) {\n          this.walkExpression(switchCase.test);\n        }\n        if (switchCase.consequent.length > 0) {\n          this.walkStatements(switchCase.consequent);\n        }\n      }\n    });\n  }\n\n  /**\n   * @param {CatchClause} catchClause catch clause\n   */\n  preWalkCatchClause(catchClause) {\n    this.preWalkStatement(catchClause.body);\n  }\n\n  /**\n   * @param {CatchClause} catchClause catch clause\n   */\n  walkCatchClause(catchClause) {\n    this.inBlockScope(() => {\n      // Error binding is optional in catch clause since ECMAScript 2019\n      if (catchClause.param !== null) {\n        this.enterPattern(catchClause.param, ident => {\n          this.defineVariable(ident);\n        });\n        this.walkPattern(catchClause.param);\n      }\n      const prev = this.prevStatement;\n      this.blockPreWalkStatement(catchClause.body);\n      this.prevStatement = prev;\n      this.walkStatement(catchClause.body);\n    });\n  }\n\n  /**\n   * @param {Pattern} pattern pattern\n   */\n  walkPattern(pattern) {\n    switch (pattern.type) {\n      case \"ArrayPattern\":\n        this.walkArrayPattern(pattern);\n        break;\n      case \"AssignmentPattern\":\n        this.walkAssignmentPattern(pattern);\n        break;\n      case \"MemberExpression\":\n        this.walkMemberExpression(pattern);\n        break;\n      case \"ObjectPattern\":\n        this.walkObjectPattern(pattern);\n        break;\n      case \"RestElement\":\n        this.walkRestElement(pattern);\n        break;\n    }\n  }\n\n  /**\n   * @param {AssignmentPattern} pattern assignment pattern\n   */\n  walkAssignmentPattern(pattern) {\n    this.walkExpression(pattern.right);\n    this.walkPattern(pattern.left);\n  }\n\n  /**\n   * @param {ObjectPattern} pattern pattern\n   */\n  walkObjectPattern(pattern) {\n    for (let i = 0, len = pattern.properties.length; i < len; i++) {\n      const prop = pattern.properties[i];\n      if (prop) {\n        if (prop.type === \"RestElement\") {\n          continue;\n        }\n        if (prop.computed) this.walkExpression(prop.key);\n        if (prop.value) this.walkPattern(prop.value);\n      }\n    }\n  }\n\n  /**\n   * @param {ArrayPattern} pattern array pattern\n   */\n  walkArrayPattern(pattern) {\n    for (let i = 0, len = pattern.elements.length; i < len; i++) {\n      const element = pattern.elements[i];\n      if (element) this.walkPattern(element);\n    }\n  }\n\n  /**\n   * @param {RestElement} pattern rest element\n   */\n  walkRestElement(pattern) {\n    this.walkPattern(pattern.argument);\n  }\n\n  /**\n   * @param {(Expression | SpreadElement | null)[]} expressions expressions\n   */\n  walkExpressions(expressions) {\n    for (const expression of expressions) {\n      if (expression) {\n        this.walkExpression(expression);\n      }\n    }\n  }\n\n  /**\n   * @param {TODO} expression expression\n   */\n  walkExpression(expression) {\n    switch (expression.type) {\n      case \"ArrayExpression\":\n        this.walkArrayExpression(expression);\n        break;\n      case \"ArrowFunctionExpression\":\n        this.walkArrowFunctionExpression(expression);\n        break;\n      case \"AssignmentExpression\":\n        this.walkAssignmentExpression(expression);\n        break;\n      case \"AwaitExpression\":\n        this.walkAwaitExpression(expression);\n        break;\n      case \"BinaryExpression\":\n        this.walkBinaryExpression(expression);\n        break;\n      case \"CallExpression\":\n        this.walkCallExpression(expression);\n        break;\n      case \"ChainExpression\":\n        this.walkChainExpression(expression);\n        break;\n      case \"ClassExpression\":\n        this.walkClassExpression(expression);\n        break;\n      case \"ConditionalExpression\":\n        this.walkConditionalExpression(expression);\n        break;\n      case \"FunctionExpression\":\n        this.walkFunctionExpression(expression);\n        break;\n      case \"Identifier\":\n        this.walkIdentifier(expression);\n        break;\n      case \"ImportExpression\":\n        this.walkImportExpression(expression);\n        break;\n      case \"LogicalExpression\":\n        this.walkLogicalExpression(expression);\n        break;\n      case \"MetaProperty\":\n        this.walkMetaProperty(expression);\n        break;\n      case \"MemberExpression\":\n        this.walkMemberExpression(expression);\n        break;\n      case \"NewExpression\":\n        this.walkNewExpression(expression);\n        break;\n      case \"ObjectExpression\":\n        this.walkObjectExpression(expression);\n        break;\n      case \"SequenceExpression\":\n        this.walkSequenceExpression(expression);\n        break;\n      case \"SpreadElement\":\n        this.walkSpreadElement(expression);\n        break;\n      case \"TaggedTemplateExpression\":\n        this.walkTaggedTemplateExpression(expression);\n        break;\n      case \"TemplateLiteral\":\n        this.walkTemplateLiteral(expression);\n        break;\n      case \"ThisExpression\":\n        this.walkThisExpression(expression);\n        break;\n      case \"UnaryExpression\":\n        this.walkUnaryExpression(expression);\n        break;\n      case \"UpdateExpression\":\n        this.walkUpdateExpression(expression);\n        break;\n      case \"YieldExpression\":\n        this.walkYieldExpression(expression);\n        break;\n    }\n  }\n\n  /**\n   * @param {AwaitExpression} expression await expression\n   */\n  walkAwaitExpression(expression) {\n    if (this.scope.topLevelScope === true) this.hooks.topLevelAwait.call(expression);\n    this.walkExpression(expression.argument);\n  }\n\n  /**\n   * @param {ArrayExpression} expression array expression\n   */\n  walkArrayExpression(expression) {\n    if (expression.elements) {\n      this.walkExpressions(expression.elements);\n    }\n  }\n\n  /**\n   * @param {SpreadElement} expression spread element\n   */\n  walkSpreadElement(expression) {\n    if (expression.argument) {\n      this.walkExpression(expression.argument);\n    }\n  }\n\n  /**\n   * @param {ObjectExpression} expression object expression\n   */\n  walkObjectExpression(expression) {\n    for (let propIndex = 0, len = expression.properties.length; propIndex < len; propIndex++) {\n      const prop = expression.properties[propIndex];\n      this.walkProperty(prop);\n    }\n  }\n\n  /**\n   * @param {Property | SpreadElement} prop property or spread element\n   */\n  walkProperty(prop) {\n    if (prop.type === \"SpreadElement\") {\n      this.walkExpression(prop.argument);\n      return;\n    }\n    if (prop.computed) {\n      this.walkExpression(prop.key);\n    }\n    if (prop.shorthand && prop.value && prop.value.type === \"Identifier\") {\n      this.scope.inShorthand = prop.value.name;\n      this.walkIdentifier(prop.value);\n      this.scope.inShorthand = false;\n    } else {\n      this.walkExpression(prop.value);\n    }\n  }\n\n  /**\n   * @param {FunctionExpression} expression arrow function expression\n   */\n  walkFunctionExpression(expression) {\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = false;\n    const scopeParams = [...expression.params];\n\n    // Add function name in scope for recursive calls\n    if (expression.id) {\n      scopeParams.push(expression.id);\n    }\n    this.inFunctionScope(true, scopeParams, () => {\n      for (const param of expression.params) {\n        this.walkPattern(param);\n      }\n      if (expression.body.type === \"BlockStatement\") {\n        this.detectMode(expression.body.body);\n        const prev = this.prevStatement;\n        this.preWalkStatement(expression.body);\n        this.prevStatement = prev;\n        this.walkStatement(expression.body);\n      } else {\n        this.walkExpression(expression.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n\n  /**\n   * @param {ArrowFunctionExpression} expression arrow function expression\n   */\n  walkArrowFunctionExpression(expression) {\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = wasTopLevel ? \"arrow\" : false;\n    this.inFunctionScope(false, expression.params, () => {\n      for (const param of expression.params) {\n        this.walkPattern(param);\n      }\n      if (expression.body.type === \"BlockStatement\") {\n        this.detectMode(expression.body.body);\n        const prev = this.prevStatement;\n        this.preWalkStatement(expression.body);\n        this.prevStatement = prev;\n        this.walkStatement(expression.body);\n      } else {\n        this.walkExpression(expression.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n\n  /**\n   * @param {SequenceExpression} expression the sequence\n   */\n  walkSequenceExpression(expression) {\n    if (!expression.expressions) return;\n    // We treat sequence expressions like statements when they are one statement level\n    // This has some benefits for optimizations that only work on statement level\n    const currentStatement = /** @type {StatementPath} */\n    this.statementPath[/** @type {StatementPath} */\n    this.statementPath.length - 1];\n    if (currentStatement === expression || currentStatement.type === \"ExpressionStatement\" && currentStatement.expression === expression) {\n      const old = /** @type {StatementPathItem} */\n      /** @type {StatementPath} */this.statementPath.pop();\n      const prev = this.prevStatement;\n      for (const expr of expression.expressions) {\n        /** @type {StatementPath} */\n        this.statementPath.push(expr);\n        this.walkExpression(expr);\n        this.prevStatement = /** @type {StatementPath} */\n        this.statementPath.pop();\n      }\n      this.prevStatement = prev;\n      /** @type {StatementPath} */\n      this.statementPath.push(old);\n    } else {\n      this.walkExpressions(expression.expressions);\n    }\n  }\n\n  /**\n   * @param {UpdateExpression} expression the update expression\n   */\n  walkUpdateExpression(expression) {\n    this.walkExpression(expression.argument);\n  }\n\n  /**\n   * @param {UnaryExpression} expression the unary expression\n   */\n  walkUnaryExpression(expression) {\n    if (expression.operator === \"typeof\") {\n      const result = this.callHooksForExpression(this.hooks.typeof, expression.argument, expression);\n      if (result === true) return;\n      if (expression.argument.type === \"ChainExpression\") {\n        const result = this.callHooksForExpression(this.hooks.typeof, expression.argument.expression, expression);\n        if (result === true) return;\n      }\n    }\n    this.walkExpression(expression.argument);\n  }\n\n  /**\n   * @param {LogicalExpression | BinaryExpression} expression the expression\n   */\n  walkLeftRightExpression(expression) {\n    this.walkExpression(expression.left);\n    this.walkExpression(expression.right);\n  }\n\n  /**\n   * @param {BinaryExpression} expression the binary expression\n   */\n  walkBinaryExpression(expression) {\n    if (this.hooks.binaryExpression.call(expression) === undefined) {\n      this.walkLeftRightExpression(expression);\n    }\n  }\n\n  /**\n   * @param {LogicalExpression} expression the logical expression\n   */\n  walkLogicalExpression(expression) {\n    const result = this.hooks.expressionLogicalOperator.call(expression);\n    if (result === undefined) {\n      this.walkLeftRightExpression(expression);\n    } else if (result) {\n      this.walkExpression(expression.right);\n    }\n  }\n\n  /**\n   * @param {AssignmentExpression} expression assignment expression\n   */\n  walkAssignmentExpression(expression) {\n    if (expression.left.type === \"Identifier\") {\n      const renameIdentifier = this.getRenameIdentifier(expression.right);\n      if (renameIdentifier && this.callHooksForInfo(this.hooks.canRename, renameIdentifier, expression.right)) {\n        // renaming \"a = b;\"\n        if (!this.callHooksForInfo(this.hooks.rename, renameIdentifier, expression.right)) {\n          this.setVariable(expression.left.name, typeof renameIdentifier === \"string\" ? this.getVariableInfo(renameIdentifier) : renameIdentifier);\n        }\n        return;\n      }\n      this.walkExpression(expression.right);\n      this.enterPattern(expression.left, (name, decl) => {\n        if (!this.callHooksForName(this.hooks.assign, name, expression)) {\n          this.walkExpression(expression.left);\n        }\n      });\n      return;\n    }\n    if (expression.left.type.endsWith(\"Pattern\")) {\n      this.walkExpression(expression.right);\n      this.enterPattern(expression.left, (name, decl) => {\n        if (!this.callHooksForName(this.hooks.assign, name, expression)) {\n          this.defineVariable(name);\n        }\n      });\n      this.walkPattern(expression.left);\n    } else if (expression.left.type === \"MemberExpression\") {\n      const exprName = this.getMemberExpressionInfo(expression.left, ALLOWED_MEMBER_TYPES_EXPRESSION);\n      if (exprName && this.callHooksForInfo(this.hooks.assignMemberChain, exprName.rootInfo, expression, exprName.getMembers())) {\n        return;\n      }\n      this.walkExpression(expression.right);\n      this.walkExpression(expression.left);\n    } else {\n      this.walkExpression(expression.right);\n      this.walkExpression(expression.left);\n    }\n  }\n\n  /**\n   * @param {ConditionalExpression} expression conditional expression\n   */\n  walkConditionalExpression(expression) {\n    const result = this.hooks.expressionConditionalOperator.call(expression);\n    if (result === undefined) {\n      this.walkExpression(expression.test);\n      this.walkExpression(expression.consequent);\n      if (expression.alternate) {\n        this.walkExpression(expression.alternate);\n      }\n    } else if (result) {\n      this.walkExpression(expression.consequent);\n    } else if (expression.alternate) {\n      this.walkExpression(expression.alternate);\n    }\n  }\n\n  /**\n   * @param {NewExpression} expression new expression\n   */\n  walkNewExpression(expression) {\n    const result = this.callHooksForExpression(this.hooks.new, expression.callee, expression);\n    if (result === true) return;\n    this.walkExpression(expression.callee);\n    if (expression.arguments) {\n      this.walkExpressions(expression.arguments);\n    }\n  }\n\n  /**\n   * @param {YieldExpression} expression yield expression\n   */\n  walkYieldExpression(expression) {\n    if (expression.argument) {\n      this.walkExpression(expression.argument);\n    }\n  }\n\n  /**\n   * @param {TemplateLiteral} expression template literal\n   */\n  walkTemplateLiteral(expression) {\n    if (expression.expressions) {\n      this.walkExpressions(expression.expressions);\n    }\n  }\n\n  /**\n   * @param {TaggedTemplateExpression} expression tagged template expression\n   */\n  walkTaggedTemplateExpression(expression) {\n    if (expression.tag) {\n      this.scope.inTaggedTemplateTag = true;\n      this.walkExpression(expression.tag);\n      this.scope.inTaggedTemplateTag = false;\n    }\n    if (expression.quasi && expression.quasi.expressions) {\n      this.walkExpressions(expression.quasi.expressions);\n    }\n  }\n\n  /**\n   * @param {ClassExpression} expression the class expression\n   */\n  walkClassExpression(expression) {\n    this.walkClass(expression);\n  }\n\n  /**\n   * @param {ChainExpression} expression expression\n   */\n  walkChainExpression(expression) {\n    const result = this.hooks.optionalChaining.call(expression);\n    if (result === undefined) {\n      if (expression.expression.type === \"CallExpression\") {\n        this.walkCallExpression(expression.expression);\n      } else {\n        this.walkMemberExpression(expression.expression);\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {FunctionExpression | ArrowFunctionExpression} functionExpression function expression\n   * @param {(Expression | SpreadElement)[]} options options\n   * @param {Expression | SpreadElement | null} currentThis current this\n   */\n  _walkIIFE(functionExpression, options, currentThis) {\n    /**\n     * @param {Expression | SpreadElement} argOrThis arg or this\n     * @returns {string | VariableInfoInterface | undefined} var info\n     */\n    const getVarInfo = argOrThis => {\n      const renameIdentifier = this.getRenameIdentifier(argOrThis);\n      if (renameIdentifier && this.callHooksForInfo(this.hooks.canRename, renameIdentifier, /** @type {Expression} */\n      argOrThis) && !this.callHooksForInfo(this.hooks.rename, renameIdentifier, /** @type {Expression} */\n      argOrThis)) {\n        return typeof renameIdentifier === \"string\" ? (/** @type {string} */this.getVariableInfo(renameIdentifier)) : renameIdentifier;\n      }\n      this.walkExpression(argOrThis);\n    };\n    const {\n      params,\n      type\n    } = functionExpression;\n    const arrow = type === \"ArrowFunctionExpression\";\n    const renameThis = currentThis ? getVarInfo(currentThis) : null;\n    const varInfoForArgs = options.map(getVarInfo);\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = wasTopLevel && arrow ? \"arrow\" : false;\n    const scopeParams = /** @type {(Identifier | string)[]} */\n    params.filter((identifier, idx) => !varInfoForArgs[idx]);\n\n    // Add function name in scope for recursive calls\n    if (functionExpression.type === \"FunctionExpression\" && functionExpression.id) {\n      scopeParams.push(functionExpression.id.name);\n    }\n    this.inFunctionScope(true, scopeParams, () => {\n      if (renameThis && !arrow) {\n        this.setVariable(\"this\", renameThis);\n      }\n      for (let i = 0; i < varInfoForArgs.length; i++) {\n        const varInfo = varInfoForArgs[i];\n        if (!varInfo) continue;\n        if (!params[i] || params[i].type !== \"Identifier\") continue;\n        this.setVariable(/** @type {Identifier} */params[i].name, varInfo);\n      }\n      if (functionExpression.body.type === \"BlockStatement\") {\n        this.detectMode(functionExpression.body.body);\n        const prev = this.prevStatement;\n        this.preWalkStatement(functionExpression.body);\n        this.prevStatement = prev;\n        this.walkStatement(functionExpression.body);\n      } else {\n        this.walkExpression(functionExpression.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n\n  /**\n   * @param {ImportExpression} expression import expression\n   */\n  walkImportExpression(expression) {\n    const result = this.hooks.importCall.call(expression);\n    if (result === true) return;\n    this.walkExpression(expression.source);\n  }\n\n  /**\n   * @param {CallExpression} expression expression\n   */\n  walkCallExpression(expression) {\n    /**\n     * @param {FunctionExpression | ArrowFunctionExpression} fn function\n     * @returns {boolean} true when simple function\n     */\n    const isSimpleFunction = fn => fn.params.every(p => p.type === \"Identifier\");\n    if (expression.callee.type === \"MemberExpression\" && expression.callee.object.type.endsWith(\"FunctionExpression\") && !expression.callee.computed && (\n    // eslint-disable-next-line no-warning-comments\n    // @ts-ignore\n    // TODO check me and handle more cases\n    expression.callee.property.name === \"call\" ||\n    // eslint-disable-next-line no-warning-comments\n    // @ts-ignore\n    expression.callee.property.name === \"bind\") && expression.arguments.length > 0 && isSimpleFunction(/** @type {FunctionExpression | ArrowFunctionExpression} */\n    expression.callee.object)) {\n      // (function(…) { }.call/bind(?, …))\n      this._walkIIFE(/** @type {FunctionExpression | ArrowFunctionExpression} */\n      expression.callee.object, expression.arguments.slice(1), expression.arguments[0]);\n    } else if (expression.callee.type.endsWith(\"FunctionExpression\") && isSimpleFunction(/** @type {FunctionExpression | ArrowFunctionExpression} */\n    expression.callee)) {\n      // (function(…) { }(…))\n      this._walkIIFE(/** @type {FunctionExpression | ArrowFunctionExpression} */\n      expression.callee, expression.arguments, null);\n    } else {\n      if (expression.callee.type === \"MemberExpression\") {\n        const exprInfo = this.getMemberExpressionInfo(expression.callee, ALLOWED_MEMBER_TYPES_CALL_EXPRESSION);\n        if (exprInfo && exprInfo.type === \"call\") {\n          const result = this.callHooksForInfo(this.hooks.callMemberChainOfCallMemberChain, exprInfo.rootInfo, expression, exprInfo.getCalleeMembers(), exprInfo.call, exprInfo.getMembers(), exprInfo.getMemberRanges());\n          if (result === true) return;\n        }\n      }\n      const callee = this.evaluateExpression(/** @type {TODO} */expression.callee);\n      if (callee.isIdentifier()) {\n        const result1 = this.callHooksForInfo(this.hooks.callMemberChain, /** @type {NonNullable<BasicEvaluatedExpression[\"rootInfo\"]>} */\n        callee.rootInfo, expression, /** @type {NonNullable<BasicEvaluatedExpression[\"getMembers\"]>} */\n        callee.getMembers(), callee.getMembersOptionals ? callee.getMembersOptionals() : /** @type {NonNullable<BasicEvaluatedExpression[\"getMembers\"]>} */\n        callee.getMembers().map(() => false), callee.getMemberRanges ? callee.getMemberRanges() : []);\n        if (result1 === true) return;\n        const result2 = this.callHooksForInfo(this.hooks.call, /** @type {NonNullable<BasicEvaluatedExpression[\"identifier\"]>} */\n        callee.identifier, expression);\n        if (result2 === true) return;\n      }\n      if (expression.callee) {\n        if (expression.callee.type === \"MemberExpression\") {\n          // because of call context we need to walk the call context as expression\n          this.walkExpression(expression.callee.object);\n          if (expression.callee.computed === true) this.walkExpression(expression.callee.property);\n        } else {\n          this.walkExpression(expression.callee);\n        }\n      }\n      if (expression.arguments) this.walkExpressions(expression.arguments);\n    }\n  }\n\n  /**\n   * @param {MemberExpression} expression member expression\n   */\n  walkMemberExpression(expression) {\n    const exprInfo = this.getMemberExpressionInfo(expression, ALLOWED_MEMBER_TYPES_ALL);\n    if (exprInfo) {\n      switch (exprInfo.type) {\n        case \"expression\":\n          {\n            const result1 = this.callHooksForInfo(this.hooks.expression, exprInfo.name, expression);\n            if (result1 === true) return;\n            const members = exprInfo.getMembers();\n            const membersOptionals = exprInfo.getMembersOptionals();\n            const memberRanges = exprInfo.getMemberRanges();\n            const result2 = this.callHooksForInfo(this.hooks.expressionMemberChain, exprInfo.rootInfo, expression, members, membersOptionals, memberRanges);\n            if (result2 === true) return;\n            this.walkMemberExpressionWithExpressionName(expression, exprInfo.name, exprInfo.rootInfo, members.slice(), () => this.callHooksForInfo(this.hooks.unhandledExpressionMemberChain, exprInfo.rootInfo, expression, members));\n            return;\n          }\n        case \"call\":\n          {\n            const result = this.callHooksForInfo(this.hooks.memberChainOfCallMemberChain, exprInfo.rootInfo, expression, exprInfo.getCalleeMembers(), exprInfo.call, exprInfo.getMembers(), exprInfo.getMemberRanges());\n            if (result === true) return;\n            // Fast skip over the member chain as we already called memberChainOfCallMemberChain\n            // and call computed property are literals anyway\n            this.walkExpression(exprInfo.call);\n            return;\n          }\n      }\n    }\n    this.walkExpression(expression.object);\n    if (expression.computed === true) this.walkExpression(expression.property);\n  }\n\n  /**\n   * @param {TODO} expression member expression\n   * @param {string} name name\n   * @param {string | VariableInfo} rootInfo root info\n   * @param {string[]} members members\n   * @param {TODO} onUnhandled on unhandled callback\n   */\n  walkMemberExpressionWithExpressionName(expression, name, rootInfo, members, onUnhandled) {\n    if (expression.object.type === \"MemberExpression\") {\n      // optimize the case where expression.object is a MemberExpression too.\n      // we can keep info here when calling walkMemberExpression directly\n      const property = expression.property.name || `${expression.property.value}`;\n      name = name.slice(0, -property.length - 1);\n      members.pop();\n      const result = this.callHooksForInfo(this.hooks.expression, name, expression.object);\n      if (result === true) return;\n      this.walkMemberExpressionWithExpressionName(expression.object, name, rootInfo, members, onUnhandled);\n    } else if (!onUnhandled || !onUnhandled()) {\n      this.walkExpression(expression.object);\n    }\n    if (expression.computed === true) this.walkExpression(expression.property);\n  }\n\n  /**\n   * @param {ThisExpression} expression this expression\n   */\n  walkThisExpression(expression) {\n    this.callHooksForName(this.hooks.expression, \"this\", expression);\n  }\n\n  /**\n   * @param {Identifier} expression identifier\n   */\n  walkIdentifier(expression) {\n    this.callHooksForName(this.hooks.expression, expression.name, expression);\n  }\n\n  /**\n   * @param {MetaProperty} metaProperty meta property\n   */\n  walkMetaProperty(metaProperty) {\n    this.hooks.expression.for(getRootName(metaProperty)).call(metaProperty);\n  }\n\n  /**\n   * @template T\n   * @template R\n   * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n   * @param {Expression | Super} expr expression\n   * @param {AsArray<T>} args args for the hook\n   * @returns {R | undefined} result of hook\n   */\n  callHooksForExpression(hookMap, expr, ...args) {\n    return this.callHooksForExpressionWithFallback(hookMap, expr, undefined, undefined, ...args);\n  }\n\n  /**\n   * @template T\n   * @template R\n   * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n   * @param {Expression | Super} expr expression info\n   * @param {(function(string, string | ScopeInfo | VariableInfo, function(): string[]): any) | undefined} fallback callback when variable in not handled by hooks\n   * @param {(function(string): any) | undefined} defined callback when variable is defined\n   * @param {AsArray<T>} args args for the hook\n   * @returns {R | undefined} result of hook\n   */\n  callHooksForExpressionWithFallback(hookMap, expr, fallback, defined, ...args) {\n    const exprName = this.getMemberExpressionInfo(expr, ALLOWED_MEMBER_TYPES_EXPRESSION);\n    if (exprName !== undefined) {\n      const members = exprName.getMembers();\n      return this.callHooksForInfoWithFallback(hookMap, members.length === 0 ? exprName.rootInfo : exprName.name, fallback && (name => fallback(name, exprName.rootInfo, exprName.getMembers)), defined && (() => defined(exprName.name)), ...args);\n    }\n  }\n\n  /**\n   * @template T\n   * @template R\n   * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n   * @param {string} name key in map\n   * @param {AsArray<T>} args args for the hook\n   * @returns {R | undefined} result of hook\n   */\n  callHooksForName(hookMap, name, ...args) {\n    return this.callHooksForNameWithFallback(hookMap, name, undefined, undefined, ...args);\n  }\n\n  /**\n   * @template T\n   * @template R\n   * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks that should be called\n   * @param {ExportedVariableInfo} info variable info\n   * @param  {AsArray<T>} args args for the hook\n   * @returns {R | undefined} result of hook\n   */\n  callHooksForInfo(hookMap, info, ...args) {\n    return this.callHooksForInfoWithFallback(hookMap, info, undefined, undefined, ...args);\n  }\n\n  /**\n   * @template T\n   * @template R\n   * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n   * @param {ExportedVariableInfo} info variable info\n   * @param {(function(string): any) | undefined} fallback callback when variable in not handled by hooks\n   * @param {(function(string=): any) | undefined} defined callback when variable is defined\n   * @param {AsArray<T>} args args for the hook\n   * @returns {R | undefined} result of hook\n   */\n  callHooksForInfoWithFallback(hookMap, info, fallback, defined, ...args) {\n    let name;\n    if (typeof info === \"string\") {\n      name = info;\n    } else {\n      if (!(info instanceof VariableInfo)) {\n        if (defined !== undefined) {\n          return defined();\n        }\n        return;\n      }\n      let tagInfo = info.tagInfo;\n      while (tagInfo !== undefined) {\n        const hook = hookMap.get(tagInfo.tag);\n        if (hook !== undefined) {\n          this.currentTagData = tagInfo.data;\n          const result = hook.call(...args);\n          this.currentTagData = undefined;\n          if (result !== undefined) return result;\n        }\n        tagInfo = tagInfo.next;\n      }\n      if (info.freeName === true) {\n        if (defined !== undefined) {\n          return defined();\n        }\n        return;\n      }\n      name = info.freeName;\n    }\n    const hook = hookMap.get(name);\n    if (hook !== undefined) {\n      const result = hook.call(...args);\n      if (result !== undefined) return result;\n    }\n    if (fallback !== undefined) {\n      return fallback(/** @type {string} */name);\n    }\n  }\n\n  /**\n   * @template T\n   * @template R\n   * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n   * @param {string} name key in map\n   * @param {(function(string): any) | undefined} fallback callback when variable in not handled by hooks\n   * @param {(function(): any) | undefined} defined callback when variable is defined\n   * @param {AsArray<T>} args args for the hook\n   * @returns {R | undefined} result of hook\n   */\n  callHooksForNameWithFallback(hookMap, name, fallback, defined, ...args) {\n    return this.callHooksForInfoWithFallback(hookMap, this.getVariableInfo(name), fallback, defined, ...args);\n  }\n\n  /**\n   * @deprecated\n   * @param {any} params scope params\n   * @param {function(): void} fn inner function\n   * @returns {void}\n   */\n  inScope(params, fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: false,\n      inShorthand: false,\n      inTaggedTemplateTag: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild()\n    };\n    this.undefineVariable(\"this\");\n    this.enterPatterns(params, ident => {\n      this.defineVariable(ident);\n    });\n    fn();\n    this.scope = oldScope;\n  }\n\n  /**\n   * @param {boolean} hasThis true, when this is defined\n   * @param {Identifier[]} params scope params\n   * @param {function(): void} fn inner function\n   * @returns {void}\n   */\n  inClassScope(hasThis, params, fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: false,\n      inShorthand: false,\n      inTaggedTemplateTag: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild()\n    };\n    if (hasThis) {\n      this.undefineVariable(\"this\");\n    }\n    this.enterPatterns(params, ident => {\n      this.defineVariable(ident);\n    });\n    fn();\n    this.scope = oldScope;\n  }\n\n  /**\n   * @param {boolean} hasThis true, when this is defined\n   * @param {(Pattern | string)[]} params scope params\n   * @param {function(): void} fn inner function\n   * @returns {void}\n   */\n  inFunctionScope(hasThis, params, fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: false,\n      inShorthand: false,\n      inTaggedTemplateTag: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild()\n    };\n    if (hasThis) {\n      this.undefineVariable(\"this\");\n    }\n    this.enterPatterns(params, ident => {\n      this.defineVariable(ident);\n    });\n    fn();\n    this.scope = oldScope;\n  }\n\n  /**\n   * @param {function(): void} fn inner function\n   * @returns {void}\n   */\n  inBlockScope(fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: oldScope.inTry,\n      inShorthand: false,\n      inTaggedTemplateTag: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild()\n    };\n    fn();\n    this.scope = oldScope;\n  }\n\n  /**\n   * @param {Array<Directive | Statement | ModuleDeclaration>} statements statements\n   */\n  detectMode(statements) {\n    const isLiteral = statements.length >= 1 && statements[0].type === \"ExpressionStatement\" && statements[0].expression.type === \"Literal\";\n    if (isLiteral && /** @type {Literal} */\n    (/** @type {ExpressionStatement} */statements[0].expression).value === \"use strict\") {\n      this.scope.isStrict = true;\n    }\n    if (isLiteral && /** @type {Literal} */\n    (/** @type {ExpressionStatement} */statements[0].expression).value === \"use asm\") {\n      this.scope.isAsmJs = true;\n    }\n  }\n\n  /**\n   * @param {(string | Pattern | Property)[]} patterns patterns\n   * @param {OnIdentString} onIdent on ident callback\n   */\n  enterPatterns(patterns, onIdent) {\n    for (const pattern of patterns) {\n      if (typeof pattern !== \"string\") {\n        this.enterPattern(pattern, onIdent);\n      } else if (pattern) {\n        onIdent(pattern);\n      }\n    }\n  }\n\n  /**\n   * @param {Pattern | Property} pattern pattern\n   * @param {OnIdent} onIdent on ident callback\n   */\n  enterPattern(pattern, onIdent) {\n    if (!pattern) return;\n    switch (pattern.type) {\n      case \"ArrayPattern\":\n        this.enterArrayPattern(pattern, onIdent);\n        break;\n      case \"AssignmentPattern\":\n        this.enterAssignmentPattern(pattern, onIdent);\n        break;\n      case \"Identifier\":\n        this.enterIdentifier(pattern, onIdent);\n        break;\n      case \"ObjectPattern\":\n        this.enterObjectPattern(pattern, onIdent);\n        break;\n      case \"RestElement\":\n        this.enterRestElement(pattern, onIdent);\n        break;\n      case \"Property\":\n        if (pattern.shorthand && pattern.value.type === \"Identifier\") {\n          this.scope.inShorthand = pattern.value.name;\n          this.enterIdentifier(pattern.value, onIdent);\n          this.scope.inShorthand = false;\n        } else {\n          this.enterPattern(/** @type {Pattern} */pattern.value, onIdent);\n        }\n        break;\n    }\n  }\n\n  /**\n   * @param {Identifier} pattern identifier pattern\n   * @param {OnIdent} onIdent callback\n   */\n  enterIdentifier(pattern, onIdent) {\n    if (!this.callHooksForName(this.hooks.pattern, pattern.name, pattern)) {\n      onIdent(pattern.name, pattern);\n    }\n  }\n\n  /**\n   * @param {ObjectPattern} pattern object pattern\n   * @param {OnIdent} onIdent callback\n   */\n  enterObjectPattern(pattern, onIdent) {\n    for (let propIndex = 0, len = pattern.properties.length; propIndex < len; propIndex++) {\n      const prop = pattern.properties[propIndex];\n      this.enterPattern(prop, onIdent);\n    }\n  }\n\n  /**\n   * @param {ArrayPattern} pattern object pattern\n   * @param {OnIdent} onIdent callback\n   */\n  enterArrayPattern(pattern, onIdent) {\n    for (let elementIndex = 0, len = pattern.elements.length; elementIndex < len; elementIndex++) {\n      const element = pattern.elements[elementIndex];\n      if (element) {\n        this.enterPattern(element, onIdent);\n      }\n    }\n  }\n\n  /**\n   * @param {RestElement} pattern object pattern\n   * @param {OnIdent} onIdent callback\n   */\n  enterRestElement(pattern, onIdent) {\n    this.enterPattern(pattern.argument, onIdent);\n  }\n\n  /**\n   * @param {AssignmentPattern} pattern object pattern\n   * @param {OnIdent} onIdent callback\n   */\n  enterAssignmentPattern(pattern, onIdent) {\n    this.enterPattern(pattern.left, onIdent);\n  }\n\n  /**\n   * @param {Expression | SpreadElement | PrivateIdentifier} expression expression node\n   * @returns {BasicEvaluatedExpression} evaluation result\n   */\n  evaluateExpression(expression) {\n    try {\n      const hook = this.hooks.evaluate.get(expression.type);\n      if (hook !== undefined) {\n        const result = hook.call(expression);\n        if (result !== undefined && result !== null) {\n          result.setExpression(expression);\n          return result;\n        }\n      }\n    } catch (err) {\n      console.warn(err);\n      // ignore error\n    }\n    return new BasicEvaluatedExpression().setRange(/** @type {Range} */expression.range).setExpression(expression);\n  }\n\n  /**\n   * @param {Expression} expression expression\n   * @returns {string} parsed string\n   */\n  parseString(expression) {\n    switch (expression.type) {\n      case \"BinaryExpression\":\n        if (expression.operator === \"+\") {\n          return this.parseString(/** @type {Expression} */expression.left) + this.parseString(expression.right);\n        }\n        break;\n      case \"Literal\":\n        return String(expression.value);\n    }\n    throw new Error(`${expression.type} is not supported as parameter for require`);\n  }\n\n  /**\n   * @param {Expression} expression expression\n   * @returns {{ range?: Range, value: string, code: boolean, conditional: TODO }} result\n   */\n  parseCalculatedString(expression) {\n    switch (expression.type) {\n      case \"BinaryExpression\":\n        if (expression.operator === \"+\") {\n          const left = this.parseCalculatedString(/** @type {Expression} */\n          expression.left);\n          const right = this.parseCalculatedString(expression.right);\n          if (left.code) {\n            return {\n              range: left.range,\n              value: left.value,\n              code: true,\n              conditional: false\n            };\n          } else if (right.code) {\n            return {\n              range: [/** @type {Range} */\n              left.range[0], right.range ? right.range[1] : /** @type {Range} */left.range[1]],\n              value: left.value + right.value,\n              code: true,\n              conditional: false\n            };\n          }\n          return {\n            range: [/** @type {Range} */\n            left.range[0], /** @type {Range} */\n            right.range[1]],\n            value: left.value + right.value,\n            code: false,\n            conditional: false\n          };\n        }\n        break;\n      case \"ConditionalExpression\":\n        {\n          const consequent = this.parseCalculatedString(expression.consequent);\n          const alternate = this.parseCalculatedString(expression.alternate);\n          const items = [];\n          if (consequent.conditional) {\n            items.push(...consequent.conditional);\n          } else if (!consequent.code) {\n            items.push(consequent);\n          } else {\n            break;\n          }\n          if (alternate.conditional) {\n            items.push(...alternate.conditional);\n          } else if (!alternate.code) {\n            items.push(alternate);\n          } else {\n            break;\n          }\n          return {\n            range: undefined,\n            value: \"\",\n            code: true,\n            conditional: items\n          };\n        }\n      case \"Literal\":\n        return {\n          range: expression.range,\n          value: String(expression.value),\n          code: false,\n          conditional: false\n        };\n    }\n    return {\n      range: undefined,\n      value: \"\",\n      code: true,\n      conditional: false\n    };\n  }\n\n  /**\n   * @param {string | Buffer | PreparsedAst} source the source to parse\n   * @param {ParserState} state the parser state\n   * @returns {ParserState} the parser state\n   */\n  parse(source, state) {\n    let ast;\n    /** @type {import(\"acorn\").Comment[]} */\n    let comments;\n    const semicolons = new Set();\n    if (source === null) {\n      throw new Error(\"source must not be null\");\n    }\n    if (Buffer.isBuffer(source)) {\n      source = source.toString(\"utf-8\");\n    }\n    if (typeof source === \"object\") {\n      ast = /** @type {Program} */source;\n      comments = source.comments;\n    } else {\n      comments = [];\n      ast = JavascriptParser._parse(source, {\n        sourceType: this.sourceType,\n        onComment: comments,\n        onInsertedSemicolon: pos => semicolons.add(pos)\n      });\n    }\n    const oldScope = this.scope;\n    const oldState = this.state;\n    const oldComments = this.comments;\n    const oldSemicolons = this.semicolons;\n    const oldStatementPath = this.statementPath;\n    const oldPrevStatement = this.prevStatement;\n    this.scope = {\n      topLevelScope: true,\n      inTry: false,\n      inShorthand: false,\n      inTaggedTemplateTag: false,\n      isStrict: false,\n      isAsmJs: false,\n      definitions: new StackedMap()\n    };\n    /** @type {ParserState} */\n    this.state = state;\n    this.comments = comments;\n    this.semicolons = semicolons;\n    this.statementPath = [];\n    this.prevStatement = undefined;\n    if (this.hooks.program.call(ast, comments) === undefined) {\n      this.destructuringAssignmentProperties = new WeakMap();\n      this.detectMode(ast.body);\n      this.preWalkStatements(ast.body);\n      this.prevStatement = undefined;\n      this.blockPreWalkStatements(ast.body);\n      this.prevStatement = undefined;\n      this.walkStatements(ast.body);\n      this.destructuringAssignmentProperties = undefined;\n    }\n    this.hooks.finish.call(ast, comments);\n    this.scope = oldScope;\n    /** @type {ParserState} */\n    this.state = oldState;\n    this.comments = oldComments;\n    this.semicolons = oldSemicolons;\n    this.statementPath = oldStatementPath;\n    this.prevStatement = oldPrevStatement;\n    return state;\n  }\n\n  /**\n   * @param {string} source source code\n   * @returns {BasicEvaluatedExpression} evaluation result\n   */\n  evaluate(source) {\n    const ast = JavascriptParser._parse(`(${source})`, {\n      sourceType: this.sourceType,\n      locations: false\n    });\n    if (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n      throw new Error(\"evaluate: Source is not a expression\");\n    }\n    return this.evaluateExpression(ast.body[0].expression);\n  }\n\n  /**\n   * @param {Expression | Declaration | PrivateIdentifier | null | undefined} expr an expression\n   * @param {number} commentsStartPos source position from which annotation comments are checked\n   * @returns {boolean} true, when the expression is pure\n   */\n  isPure(expr, commentsStartPos) {\n    if (!expr) return true;\n    const result = this.hooks.isPure.for(expr.type).call(expr, commentsStartPos);\n    if (typeof result === \"boolean\") return result;\n    switch (expr.type) {\n      // TODO handle more cases\n      case \"ClassDeclaration\":\n      case \"ClassExpression\":\n        {\n          if (expr.body.type !== \"ClassBody\") return false;\n          if (expr.superClass && !this.isPure(expr.superClass, /** @type {Range} */expr.range[0])) {\n            return false;\n          }\n          const items = /** @type {TODO[]} */\n          expr.body.body;\n          return items.every(item => {\n            if (item.computed && item.key && !this.isPure(item.key, item.range[0])) {\n              return false;\n            }\n            if (item.static && item.value && !this.isPure(item.value, item.key ? item.key.range[1] : item.range[0])) {\n              return false;\n            }\n            if (item.type === \"StaticBlock\") {\n              return false;\n            }\n            if (expr.superClass && item.type === \"MethodDefinition\" && item.kind === \"constructor\") {\n              return false;\n            }\n            return true;\n          });\n        }\n      case \"FunctionDeclaration\":\n      case \"FunctionExpression\":\n      case \"ArrowFunctionExpression\":\n      case \"ThisExpression\":\n      case \"Literal\":\n      case \"TemplateLiteral\":\n      case \"Identifier\":\n      case \"PrivateIdentifier\":\n        return true;\n      case \"VariableDeclaration\":\n        return expr.declarations.every(decl => this.isPure(decl.init, /** @type {Range} */decl.range[0]));\n      case \"ConditionalExpression\":\n        return this.isPure(expr.test, commentsStartPos) && this.isPure(expr.consequent, /** @type {Range} */expr.test.range[1]) && this.isPure(expr.alternate, /** @type {Range} */expr.consequent.range[1]);\n      case \"LogicalExpression\":\n        return this.isPure(expr.left, commentsStartPos) && this.isPure(expr.right, /** @type {Range} */expr.left.range[1]);\n      case \"SequenceExpression\":\n        return expr.expressions.every(expr => {\n          const pureFlag = this.isPure(expr, commentsStartPos);\n          commentsStartPos = /** @type {Range} */expr.range[1];\n          return pureFlag;\n        });\n      case \"CallExpression\":\n        {\n          const pureFlag = /** @type {Range} */expr.range[0] - commentsStartPos > 12 && this.getComments([commentsStartPos, /** @type {Range} */expr.range[0]]).some(comment => comment.type === \"Block\" && /^\\s*(#|@)__PURE__\\s*$/.test(comment.value));\n          if (!pureFlag) return false;\n          commentsStartPos = /** @type {Range} */expr.callee.range[1];\n          return expr.arguments.every(arg => {\n            if (arg.type === \"SpreadElement\") return false;\n            const pureFlag = this.isPure(arg, commentsStartPos);\n            commentsStartPos = /** @type {Range} */arg.range[1];\n            return pureFlag;\n          });\n        }\n    }\n    const evaluated = this.evaluateExpression(expr);\n    return !evaluated.couldHaveSideEffects();\n  }\n\n  /**\n   * @param {Range} range range\n   * @returns {Comment[]} comments in the range\n   */\n  getComments(range) {\n    const [rangeStart, rangeEnd] = range;\n    /**\n     * @param {Comment} comment comment\n     * @param {number} needle needle\n     * @returns {number} compared\n     */\n    const compare = (comment, needle) => /** @type {Range} */comment.range[0] - needle;\n    const comments = /** @type {Comment[]} */this.comments;\n    let idx = binarySearchBounds.ge(comments, rangeStart, compare);\n    /** @type {Comment[]} */\n    const commentsInRange = [];\n    while (comments[idx] && /** @type {Range} */comments[idx].range[1] <= rangeEnd) {\n      commentsInRange.push(comments[idx]);\n      idx++;\n    }\n    return commentsInRange;\n  }\n\n  /**\n   * @param {number} pos source code position\n   * @returns {boolean} true when a semicolon has been inserted before this position, false if not\n   */\n  isAsiPosition(pos) {\n    const currentStatement = /** @type {StatementPath} */\n    this.statementPath[/** @type {StatementPath} */\n    this.statementPath.length - 1];\n    if (currentStatement === undefined) throw new Error(\"Not in statement\");\n    const range = /** @type {Range} */currentStatement.range;\n    return (\n      // Either asking directly for the end position of the current statement\n      range[1] === pos && /** @type {Set<number>} */this.semicolons.has(pos) ||\n      // Or asking for the start position of the current statement,\n      // here we have to check multiple things\n      range[0] === pos &&\n      // is there a previous statement which might be relevant?\n      this.prevStatement !== undefined &&\n      // is the end position of the previous statement an ASI position?\n      /** @type {Set<number>} */\n      this.semicolons.has(/** @type {Range} */this.prevStatement.range[1])\n    );\n  }\n\n  /**\n   * @param {number} pos source code position\n   * @returns {void}\n   */\n  setAsiPosition(pos) {\n    /** @type {Set<number>} */this.semicolons.add(pos);\n  }\n\n  /**\n   * @param {number} pos source code position\n   * @returns {void}\n   */\n  unsetAsiPosition(pos) {\n    /** @type {Set<number>} */this.semicolons.delete(pos);\n  }\n\n  /**\n   * @param {Expression} expr expression\n   * @returns {boolean} true, when the expression is a statement level expression\n   */\n  isStatementLevelExpression(expr) {\n    const currentStatement = /** @type {StatementPath} */\n    this.statementPath[/** @type {StatementPath} */\n    this.statementPath.length - 1];\n    return expr === currentStatement || currentStatement.type === \"ExpressionStatement\" && currentStatement.expression === expr;\n  }\n\n  /**\n   * @param {string} name name\n   * @param {symbol} tag tag info\n   * @returns {TODO} tag data\n   */\n  getTagData(name, tag) {\n    const info = this.scope.definitions.get(name);\n    if (info instanceof VariableInfo) {\n      let tagInfo = info.tagInfo;\n      while (tagInfo !== undefined) {\n        if (tagInfo.tag === tag) return tagInfo.data;\n        tagInfo = tagInfo.next;\n      }\n    }\n  }\n\n  /**\n   * @param {string} name name\n   * @param {symbol} tag tag info\n   * @param {TODO=} data data\n   */\n  tagVariable(name, tag, data) {\n    const oldInfo = this.scope.definitions.get(name);\n    /** @type {VariableInfo} */\n    let newInfo;\n    if (oldInfo === undefined) {\n      newInfo = new VariableInfo(this.scope, name, {\n        tag,\n        data,\n        next: undefined\n      });\n    } else if (oldInfo instanceof VariableInfo) {\n      newInfo = new VariableInfo(oldInfo.declaredScope, oldInfo.freeName, {\n        tag,\n        data,\n        next: oldInfo.tagInfo\n      });\n    } else {\n      newInfo = new VariableInfo(oldInfo, true, {\n        tag,\n        data,\n        next: undefined\n      });\n    }\n    this.scope.definitions.set(name, newInfo);\n  }\n\n  /**\n   * @param {string} name variable name\n   */\n  defineVariable(name) {\n    const oldInfo = this.scope.definitions.get(name);\n    // Don't redefine variable in same scope to keep existing tags\n    if (oldInfo instanceof VariableInfo && oldInfo.declaredScope === this.scope) return;\n    this.scope.definitions.set(name, this.scope);\n  }\n\n  /**\n   * @param {string} name variable name\n   */\n  undefineVariable(name) {\n    this.scope.definitions.delete(name);\n  }\n\n  /**\n   * @param {string} name variable name\n   * @returns {boolean} true, when variable is defined\n   */\n  isVariableDefined(name) {\n    const info = this.scope.definitions.get(name);\n    if (info === undefined) return false;\n    if (info instanceof VariableInfo) {\n      return info.freeName === true;\n    }\n    return true;\n  }\n\n  /**\n   * @param {string} name variable name\n   * @returns {string | ExportedVariableInfo} info for this variable\n   */\n  getVariableInfo(name) {\n    const value = this.scope.definitions.get(name);\n    if (value === undefined) {\n      return name;\n    }\n    return value;\n  }\n\n  /**\n   * @param {string} name variable name\n   * @param {string | ExportedVariableInfo} variableInfo new info for this variable\n   * @returns {void}\n   */\n  setVariable(name, variableInfo) {\n    if (typeof variableInfo === \"string\") {\n      if (variableInfo === name) {\n        this.scope.definitions.delete(name);\n      } else {\n        this.scope.definitions.set(name, new VariableInfo(this.scope, variableInfo, undefined));\n      }\n    } else {\n      this.scope.definitions.set(name, variableInfo);\n    }\n  }\n\n  /**\n   * @param {TagInfo} tagInfo tag info\n   * @returns {VariableInfo} variable info\n   */\n  evaluatedVariable(tagInfo) {\n    return new VariableInfo(this.scope, undefined, tagInfo);\n  }\n\n  /**\n   * @param {Range} range range of the comment\n   * @returns {{ options: Record<string, any> | null, errors: (Error & { comment: Comment })[] | null }} result\n   */\n  parseCommentOptions(range) {\n    const comments = this.getComments(range);\n    if (comments.length === 0) {\n      return EMPTY_COMMENT_OPTIONS;\n    }\n    /** @type {Record<string, EXPECTED_ANY> } */\n    const options = {};\n    /** @type {(Error & { comment: Comment })[]} */\n    const errors = [];\n    for (const comment of comments) {\n      const {\n        value\n      } = comment;\n      if (value && webpackCommentRegExp.test(value)) {\n        // try compile only if webpack options comment is present\n        try {\n          for (let [key, val] of Object.entries(vm.runInContext(`(function(){return {${value}};})()`, this.magicCommentContext))) {\n            if (typeof val === \"object\" && val !== null) {\n              val = val.constructor.name === \"RegExp\" ? new RegExp(val) : JSON.parse(JSON.stringify(val));\n            }\n            options[key] = val;\n          }\n        } catch (err) {\n          const newErr = new Error(String(/** @type {Error} */err.message));\n          newErr.stack = String(/** @type {Error} */err.stack);\n          Object.assign(newErr, {\n            comment\n          });\n          errors.push(/** @type {(Error & { comment: Comment })} */newErr);\n        }\n      }\n    }\n    return {\n      options,\n      errors\n    };\n  }\n\n  /**\n   * @param {Expression | Super} expression a member expression\n   * @returns {{ members: string[], object: Expression | Super, membersOptionals: boolean[], memberRanges: Range[] }} member names (reverse order) and remaining object\n   */\n  extractMemberExpressionChain(expression) {\n    /** @type {Node} */\n    let expr = expression;\n    const members = [];\n    const membersOptionals = [];\n    const memberRanges = [];\n    while (expr.type === \"MemberExpression\") {\n      if (expr.computed) {\n        if (expr.property.type !== \"Literal\") break;\n        members.push(`${expr.property.value}`); // the literal\n        memberRanges.push(/** @type {Range} */expr.object.range); // the range of the expression fragment before the literal\n      } else {\n        if (expr.property.type !== \"Identifier\") break;\n        members.push(expr.property.name); // the identifier\n        memberRanges.push(/** @type {Range} */expr.object.range); // the range of the expression fragment before the identifier\n      }\n      membersOptionals.push(expr.optional);\n      expr = expr.object;\n    }\n    return {\n      members,\n      membersOptionals,\n      memberRanges,\n      object: expr\n    };\n  }\n\n  /**\n   * @param {string} varName variable name\n   * @returns {{name: string, info: VariableInfo | string} | undefined} name of the free variable and variable info for that\n   */\n  getFreeInfoFromVariable(varName) {\n    const info = this.getVariableInfo(varName);\n    let name;\n    if (info instanceof VariableInfo) {\n      name = info.freeName;\n      if (typeof name !== \"string\") return;\n    } else if (typeof info !== \"string\") {\n      return;\n    } else {\n      name = info;\n    }\n    return {\n      info,\n      name\n    };\n  }\n\n  /** @typedef {{ type: \"call\", call: CallExpression, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () => string[], name: string, getMembers: () => string[], getMembersOptionals: () => boolean[], getMemberRanges: () => Range[]}} CallExpressionInfo */\n  /** @typedef {{ type: \"expression\", rootInfo: string | VariableInfo, name: string, getMembers: () => string[], getMembersOptionals: () => boolean[], getMemberRanges: () => Range[]}} ExpressionExpressionInfo */\n\n  /**\n   * @param {Expression | Super} expression a member expression\n   * @param {number} allowedTypes which types should be returned, presented in bit mask\n   * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info\n   */\n  getMemberExpressionInfo(expression, allowedTypes) {\n    const {\n      object,\n      members,\n      membersOptionals,\n      memberRanges\n    } = this.extractMemberExpressionChain(expression);\n    switch (object.type) {\n      case \"CallExpression\":\n        {\n          if ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0) return;\n          let callee = object.callee;\n          let rootMembers = EMPTY_ARRAY;\n          if (callee.type === \"MemberExpression\") {\n            ({\n              object: callee,\n              members: rootMembers\n            } = this.extractMemberExpressionChain(callee));\n          }\n          const rootName = getRootName(callee);\n          if (!rootName) return;\n          const result = this.getFreeInfoFromVariable(rootName);\n          if (!result) return;\n          const {\n            info: rootInfo,\n            name: resolvedRoot\n          } = result;\n          const calleeName = objectAndMembersToName(resolvedRoot, rootMembers);\n          return {\n            type: \"call\",\n            call: object,\n            calleeName,\n            rootInfo,\n            getCalleeMembers: memoize(() => rootMembers.reverse()),\n            name: objectAndMembersToName(`${calleeName}()`, members),\n            getMembers: memoize(() => members.reverse()),\n            getMembersOptionals: memoize(() => membersOptionals.reverse()),\n            getMemberRanges: memoize(() => memberRanges.reverse())\n          };\n        }\n      case \"Identifier\":\n      case \"MetaProperty\":\n      case \"ThisExpression\":\n        {\n          if ((allowedTypes & ALLOWED_MEMBER_TYPES_EXPRESSION) === 0) return;\n          const rootName = getRootName(object);\n          if (!rootName) return;\n          const result = this.getFreeInfoFromVariable(rootName);\n          if (!result) return;\n          const {\n            info: rootInfo,\n            name: resolvedRoot\n          } = result;\n          return {\n            type: \"expression\",\n            name: objectAndMembersToName(resolvedRoot, members),\n            rootInfo,\n            getMembers: memoize(() => members.reverse()),\n            getMembersOptionals: memoize(() => membersOptionals.reverse()),\n            getMemberRanges: memoize(() => memberRanges.reverse())\n          };\n        }\n    }\n  }\n\n  /**\n   * @param {MemberExpression} expression an expression\n   * @returns {{ name: string, rootInfo: ExportedVariableInfo, getMembers: () => string[]} | undefined} name info\n   */\n  getNameForExpression(expression) {\n    return this.getMemberExpressionInfo(expression, ALLOWED_MEMBER_TYPES_EXPRESSION);\n  }\n\n  /**\n   * @param {string} code source code\n   * @param {ParseOptions} options parsing options\n   * @returns {Program} parsed ast\n   */\n  static _parse(code, options) {\n    const type = options ? options.sourceType : \"module\";\n    /** @type {AcornOptions} */\n    const parserOptions = {\n      ...defaultParserOptions,\n      allowReturnOutsideFunction: type === \"script\",\n      ...options,\n      sourceType: type === \"auto\" ? \"module\" : type\n    };\n\n    /** @type {import(\"acorn\").Program | undefined} */\n    let ast;\n    let error;\n    let threw = false;\n    try {\n      ast = parser.parse(code, parserOptions);\n    } catch (err) {\n      error = err;\n      threw = true;\n    }\n    if (threw && type === \"auto\") {\n      parserOptions.sourceType = \"script\";\n      if (!(\"allowReturnOutsideFunction\" in options)) {\n        parserOptions.allowReturnOutsideFunction = true;\n      }\n      if (Array.isArray(parserOptions.onComment)) {\n        parserOptions.onComment.length = 0;\n      }\n      try {\n        ast = parser.parse(code, parserOptions);\n        threw = false;\n      } catch (_err) {\n        // we use the error from first parse try\n        // so nothing to do here\n      }\n    }\n    if (threw) {\n      throw error;\n    }\n    return /** @type {Program} */ast;\n  }\n}\nmodule.exports = JavascriptParser;\nmodule.exports.ALLOWED_MEMBER_TYPES_ALL = ALLOWED_MEMBER_TYPES_ALL;\nmodule.exports.ALLOWED_MEMBER_TYPES_EXPRESSION = ALLOWED_MEMBER_TYPES_EXPRESSION;\nmodule.exports.ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = ALLOWED_MEMBER_TYPES_CALL_EXPRESSION;\nmodule.exports.getImportAttributes = getImportAttributes;","map":{"version":3,"names":["Parser","AcornParser","tokTypes","require","SyncBailHook","HookMap","vm","StackedMap","binarySearchBounds","webpackCommentRegExp","createMagicCommentContext","memoize","BasicEvaluatedExpression","EMPTY_ARRAY","ALLOWED_MEMBER_TYPES_CALL_EXPRESSION","ALLOWED_MEMBER_TYPES_EXPRESSION","ALLOWED_MEMBER_TYPES_ALL","LEGACY_ASSERT_ATTRIBUTES","Symbol","importAssertions","parseWithClause","nodes","isAssertLegacy","value","eat","name","_with","expect","braceL","attributeKeys","first","braceR","comma","afterTrailingComma","attr","parseImportAttribute","keyName","key","type","Object","prototype","hasOwnProperty","call","raiseRecoverable","start","push","parser","extend","getImportAttributes","node","options","properties","length","result","property","_isLegacyAssert","attributes","undefined","attribute","VariableInfo","constructor","declaredScope","freeName","tagInfo","joinRanges","startRange","endRange","objectAndMembersToName","object","membersReversed","i","getRootName","expression","meta","defaultParserOptions","ranges","locations","ecmaVersion","sourceType","allowHashBang","onComment","EMPTY_COMMENT_OPTIONS","errors","JavascriptParser","hooks","freeze","evaluateTypeof","evaluate","evaluateIdentifier","evaluateDefinedIdentifier","evaluateNewExpression","evaluateCallExpression","evaluateCallExpressionMember","isPure","preStatement","blockPreStatement","statement","statementIf","classExtendsExpression","classBodyElement","classBodyValue","label","import","importSpecifier","export","exportImport","exportDeclaration","exportExpression","exportSpecifier","exportImportSpecifier","preDeclarator","declarator","varDeclaration","varDeclarationLet","varDeclarationConst","varDeclarationVar","pattern","canRename","rename","assign","assignMemberChain","typeof","importCall","topLevelAwait","callMemberChain","memberChainOfCallMemberChain","callMemberChainOfCallMemberChain","optionalChaining","new","binaryExpression","expressionMemberChain","unhandledExpressionMemberChain","expressionConditionalOperator","expressionLogicalOperator","program","finish","scope","state","comments","semicolons","statementPath","prevStatement","destructuringAssignmentProperties","currentTagData","magicCommentContext","_initializeEvaluating","for","tap","_expr","expr","setNumber","setRange","range","setBigInt","setString","setBoolean","setNull","RegExp","setRegExp","callee","callHooksForName","arguments","getVariableInfo","regExp","arg1","evaluatedRegExp","evaluateExpression","asString","flags","arg2","evaluatedFlags","isUndefined","isValidRegExpFlags","left","returnRight","allowedRight","operator","leftAsBool","asBool","leftAsNullish","asNullish","right","couldHaveSideEffects","setSideEffects","setTruthy","setFalsy","valueAsExpression","sideEffects","handleConstOperation","operandHandler","isCompileTimeValue","asCompileTimeValue","isAlwaysDifferent","a","b","handleTemplateStringCompare","res","eql","getPrefix","parts","p","v","getSuffix","leftPrefix","rightPrefix","leftSuffix","rightSuffix","lenPrefix","Math","min","lenSuffix","prefixMismatch","slice","suffixMismatch","handleStrictEqualityComparison","leftConst","rightConst","isArray","isTemplateString","leftPrimitive","isPrimitiveType","rightPrimitive","handleAbstractEqualityComparison","isString","string","isNumber","number","isWrapped","prefix","setWrapped","postfix","wrappedInnerExpressions","isBigInt","bigint","String","concat","l","r","argument","callHooksForExpression","arg","isUnknown","isBoolean","isConstArray","isRegExp","isNull","bool","setUndefined","tapEvaluateWithVariableInfo","exprType","getInfo","cachedExpression","cachedInfo","info","callHooksForInfoWithFallback","hook","get","stage","setIdentifier","rootInfo","getMembers","getMembersOptionals","getMemberRanges","metaProperty","getMemberExpressionInfo","computed","param","arg1Eval","arg1Value","arg2Eval","indexOf","arg2Value","replace","fn","str","getSimplifiedTemplateResult","kind","templateLiteralExpr","quasis","quasiExpr","quasi","prevExpr","expressions","exprAsString","setExpression","part","_node","setTemplateString","tag","isIdentifier","identifier","stringSuffix","hasUnknownParams","innerExpressions","argExpr","newString","newRange","inner","reverse","split","setArray","condition","test","conditionValue","consequent","alternate","isConditional","setOptions","addOptions","items","elements","map","element","every","Boolean","setItems","optionalExpressionsStack","next","optional","pop","evaluated","destructuringAssignmentPropertiesFor","getRenameIdentifier","walkClass","classy","superClass","walkExpression","body","scopeParams","id","inClassScope","classElement","wasTopLevel","topLevelScope","walkBlockStatement","preWalkStatements","statements","index","len","preWalkStatement","blockPreWalkStatements","blockPreWalkStatement","walkStatements","walkStatement","preWalkBlockStatement","preWalkDoWhileStatement","preWalkForInStatement","preWalkForOfStatement","preWalkForStatement","preWalkFunctionDeclaration","preWalkIfStatement","preWalkLabeledStatement","preWalkSwitchStatement","preWalkTryStatement","preWalkVariableDeclaration","preWalkWhileStatement","preWalkWithStatement","blockPreWalkImportDeclaration","blockPreWalkExportAllDeclaration","blockPreWalkExportDefaultDeclaration","blockPreWalkExportNamedDeclaration","blockPreWalkVariableDeclaration","blockPreWalkClassDeclaration","blockPreWalkExpressionStatement","walkClassDeclaration","walkDoWhileStatement","walkExportDefaultDeclaration","walkExportNamedDeclaration","walkExpressionStatement","walkForInStatement","walkForOfStatement","walkForStatement","walkFunctionDeclaration","walkIfStatement","walkLabeledStatement","walkReturnStatement","walkSwitchStatement","walkThrowStatement","walkTryStatement","walkVariableDeclaration","walkWhileStatement","walkWithStatement","walkNestedStatement","inBlockScope","prev","preWalkSwitchCases","cases","discriminant","walkSwitchCases","walkTerminatingStatement","block","handler","preWalkCatchClause","finalizer","inTry","walkCatchClause","init","update","walkPattern","await","defineVariable","inFunctionScope","params","detectMode","preWalkAssignmentExpression","keys","_preWalkObjectPattern","has","set","delete","add","source","specifier","specifiers","local","imported","enterDeclaration","declaration","onIdent","declarations","enterPattern","def","specifierIndex","localName","exported","_preWalkVariableDeclaration","hookMap","preWalkVariableDeclarator","decl","objectPattern","props","Set","shorthand","inShorthand","renameIdentifier","setVariable","switchCases","switchCase","catchClause","ident","walkArrayPattern","walkAssignmentPattern","walkMemberExpression","walkObjectPattern","walkRestElement","prop","walkExpressions","walkArrayExpression","walkArrowFunctionExpression","walkAssignmentExpression","walkAwaitExpression","walkBinaryExpression","walkCallExpression","walkChainExpression","walkClassExpression","walkConditionalExpression","walkFunctionExpression","walkIdentifier","walkImportExpression","walkLogicalExpression","walkMetaProperty","walkNewExpression","walkObjectExpression","walkSequenceExpression","walkSpreadElement","walkTaggedTemplateExpression","walkTemplateLiteral","walkThisExpression","walkUnaryExpression","walkUpdateExpression","walkYieldExpression","propIndex","walkProperty","currentStatement","old","walkLeftRightExpression","callHooksForInfo","endsWith","exprName","inTaggedTemplateTag","_walkIIFE","functionExpression","currentThis","getVarInfo","argOrThis","arrow","renameThis","varInfoForArgs","filter","idx","varInfo","isSimpleFunction","exprInfo","getCalleeMembers","result1","result2","members","membersOptionals","memberRanges","walkMemberExpressionWithExpressionName","onUnhandled","args","callHooksForExpressionWithFallback","fallback","defined","callHooksForNameWithFallback","data","inScope","oldScope","isStrict","isAsmJs","definitions","createChild","undefineVariable","enterPatterns","hasThis","isLiteral","patterns","enterArrayPattern","enterAssignmentPattern","enterIdentifier","enterObjectPattern","enterRestElement","elementIndex","err","console","warn","parseString","Error","parseCalculatedString","code","conditional","parse","ast","Buffer","isBuffer","toString","_parse","onInsertedSemicolon","pos","oldState","oldComments","oldSemicolons","oldStatementPath","oldPrevStatement","WeakMap","commentsStartPos","item","static","pureFlag","getComments","some","comment","rangeStart","rangeEnd","compare","needle","ge","commentsInRange","isAsiPosition","setAsiPosition","unsetAsiPosition","isStatementLevelExpression","getTagData","tagVariable","oldInfo","newInfo","isVariableDefined","variableInfo","evaluatedVariable","parseCommentOptions","val","entries","runInContext","JSON","stringify","newErr","message","stack","extractMemberExpressionChain","getFreeInfoFromVariable","varName","allowedTypes","rootMembers","rootName","resolvedRoot","calleeName","getNameForExpression","parserOptions","allowReturnOutsideFunction","error","threw","Array","_err","module","exports"],"sources":["/home/wickliff/Desktop/dev-waki/portfolio2/node_modules/webpack/lib/javascript/JavascriptParser.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { Parser: AcornParser, tokTypes } = require(\"acorn\");\nconst { SyncBailHook, HookMap } = require(\"tapable\");\nconst vm = require(\"vm\");\nconst Parser = require(\"../Parser\");\nconst StackedMap = require(\"../util/StackedMap\");\nconst binarySearchBounds = require(\"../util/binarySearchBounds\");\nconst {\n\twebpackCommentRegExp,\n\tcreateMagicCommentContext\n} = require(\"../util/magicComment\");\nconst memoize = require(\"../util/memoize\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n\n/** @typedef {import(\"acorn\").Options} AcornOptions */\n/** @typedef {import(\"estree\").AssignmentExpression} AssignmentExpression */\n/** @typedef {import(\"estree\").BinaryExpression} BinaryExpression */\n/** @typedef {import(\"estree\").BlockStatement} BlockStatement */\n/** @typedef {import(\"estree\").SequenceExpression} SequenceExpression */\n/** @typedef {import(\"estree\").CallExpression} CallExpression */\n/** @typedef {import(\"estree\").BaseCallExpression} BaseCallExpression */\n/** @typedef {import(\"estree\").StaticBlock} StaticBlock */\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclaration */\n/** @typedef {import(\"estree\").ForStatement} ForStatement */\n/** @typedef {import(\"estree\").SwitchStatement} SwitchStatement */\n/** @typedef {import(\"estree\").ClassExpression} ClassExpression */\n/** @typedef {import(\"estree\").Comment} Comment */\n/** @typedef {import(\"estree\").ConditionalExpression} ConditionalExpression */\n/** @typedef {import(\"estree\").Declaration} Declaration */\n/** @typedef {import(\"estree\").PrivateIdentifier} PrivateIdentifier */\n/** @typedef {import(\"estree\").PropertyDefinition} PropertyDefinition */\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"estree\").Identifier} Identifier */\n/** @typedef {import(\"estree\").VariableDeclaration} VariableDeclaration */\n/** @typedef {import(\"estree\").IfStatement} IfStatement */\n/** @typedef {import(\"estree\").LabeledStatement} LabeledStatement */\n/** @typedef {import(\"estree\").Literal} Literal */\n/** @typedef {import(\"estree\").LogicalExpression} LogicalExpression */\n/** @typedef {import(\"estree\").ChainExpression} ChainExpression */\n/** @typedef {import(\"estree\").MemberExpression} MemberExpression */\n/** @typedef {import(\"estree\").YieldExpression} YieldExpression */\n/** @typedef {import(\"estree\").MetaProperty} MetaProperty */\n/** @typedef {import(\"estree\").Property} Property */\n/** @typedef {import(\"estree\").AssignmentPattern} AssignmentPattern */\n/** @typedef {import(\"estree\").ChainElement} ChainElement */\n/** @typedef {import(\"estree\").Pattern} Pattern */\n/** @typedef {import(\"estree\").UpdateExpression} UpdateExpression */\n/** @typedef {import(\"estree\").ObjectExpression} ObjectExpression */\n/** @typedef {import(\"estree\").UnaryExpression} UnaryExpression */\n/** @typedef {import(\"estree\").ArrayExpression} ArrayExpression */\n/** @typedef {import(\"estree\").ArrayPattern} ArrayPattern */\n/** @typedef {import(\"estree\").AwaitExpression} AwaitExpression */\n/** @typedef {import(\"estree\").ThisExpression} ThisExpression */\n/** @typedef {import(\"estree\").RestElement} RestElement */\n/** @typedef {import(\"estree\").ObjectPattern} ObjectPattern */\n/** @typedef {import(\"estree\").SwitchCase} SwitchCase */\n/** @typedef {import(\"estree\").CatchClause} CatchClause */\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclarator */\n/** @typedef {import(\"estree\").ForInStatement} ForInStatement */\n/** @typedef {import(\"estree\").ForOfStatement} ForOfStatement */\n/** @typedef {import(\"estree\").ReturnStatement} ReturnStatement */\n/** @typedef {import(\"estree\").WithStatement} WithStatement */\n/** @typedef {import(\"estree\").ThrowStatement} ThrowStatement */\n/** @typedef {import(\"estree\").MethodDefinition} MethodDefinition */\n/** @typedef {import(\"estree\").NewExpression} NewExpression */\n/** @typedef {import(\"estree\").SpreadElement} SpreadElement */\n/** @typedef {import(\"estree\").FunctionExpression} FunctionExpression */\n/** @typedef {import(\"estree\").WhileStatement} WhileStatement */\n/** @typedef {import(\"estree\").ArrowFunctionExpression} ArrowFunctionExpression */\n/** @typedef {import(\"estree\").ExpressionStatement} ExpressionStatement */\n/** @typedef {import(\"estree\").FunctionDeclaration} FunctionDeclaration */\n/** @typedef {import(\"estree\").DoWhileStatement} DoWhileStatement */\n/** @typedef {import(\"estree\").TryStatement} TryStatement */\n/** @typedef {import(\"estree\").Node} Node */\n/** @typedef {import(\"estree\").Program} Program */\n/** @typedef {import(\"estree\").Directive} Directive */\n/** @typedef {import(\"estree\").Statement} Statement */\n/** @typedef {import(\"estree\").ExportDefaultDeclaration} ExportDefaultDeclaration */\n/** @typedef {import(\"estree\").Super} Super */\n/** @typedef {import(\"estree\").TaggedTemplateExpression} TaggedTemplateExpression */\n/** @typedef {import(\"estree\").TemplateLiteral} TemplateLiteral */\n/** @typedef {import(\"estree\").AssignmentProperty} AssignmentProperty */\n/**\n * @template T\n * @typedef {import(\"tapable\").AsArray<T>} AsArray<T>\n */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../Parser\").PreparsedAst} PreparsedAst */\n/** @typedef {{declaredScope: ScopeInfo, freeName: string | true | undefined, tagInfo: TagInfo | undefined}} VariableInfoInterface */\n/** @typedef {{ name: string | VariableInfo, rootInfo: string | VariableInfo, getMembers: () => string[], getMembersOptionals: () => boolean[], getMemberRanges: () => Range[] }} GetInfoResult */\n/** @typedef {Statement | ModuleDeclaration | Expression} StatementPathItem */\n/** @typedef {function(string): void} OnIdentString */\n/** @typedef {function(string, Identifier): void} OnIdent */\n/** @typedef {StatementPathItem[]} StatementPath */\n\n// TODO remove cast when @types/estree has been updated to import assertions\n/** @typedef {import(\"estree\").BaseNode & { type: \"ImportAttribute\", key: Identifier | Literal, value: Literal }} ImportAttribute */\n/** @typedef {import(\"estree\").ImportDeclaration & { attributes?: Array<ImportAttribute> }} ImportDeclaration */\n/** @typedef {import(\"estree\").ExportNamedDeclaration & { attributes?: Array<ImportAttribute> }} ExportNamedDeclaration */\n/** @typedef {import(\"estree\").ExportAllDeclaration & { attributes?: Array<ImportAttribute> }} ExportAllDeclaration */\n/** @typedef {import(\"estree\").ImportExpression & { options?: Expression | null }} ImportExpression */\n/** @typedef {ImportDeclaration | ExportNamedDeclaration | ExportDefaultDeclaration | ExportAllDeclaration} ModuleDeclaration */\n\n/** @type {string[]} */\nconst EMPTY_ARRAY = [];\nconst ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = 0b01;\nconst ALLOWED_MEMBER_TYPES_EXPRESSION = 0b10;\nconst ALLOWED_MEMBER_TYPES_ALL = 0b11;\n\nconst LEGACY_ASSERT_ATTRIBUTES = Symbol(\"assert\");\n\n/**\n * @param {any} Parser parser\n * @returns {typeof AcornParser} extender acorn parser\n */\nconst importAssertions = Parser =>\n\t/** @type {typeof AcornParser} */ (\n\t\t/** @type {unknown} */ (\n\t\t\tclass extends Parser {\n\t\t\t\tparseWithClause() {\n\t\t\t\t\tconst nodes = [];\n\n\t\t\t\t\tconst isAssertLegacy = this.value === \"assert\";\n\n\t\t\t\t\tif (isAssertLegacy) {\n\t\t\t\t\t\tif (!this.eat(tokTypes.name)) {\n\t\t\t\t\t\t\treturn nodes;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!this.eat(tokTypes._with)) {\n\t\t\t\t\t\treturn nodes;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.expect(tokTypes.braceL);\n\n\t\t\t\t\tconst attributeKeys = {};\n\t\t\t\t\tlet first = true;\n\n\t\t\t\t\twhile (!this.eat(tokTypes.braceR)) {\n\t\t\t\t\t\tif (!first) {\n\t\t\t\t\t\t\tthis.expect(tokTypes.comma);\n\t\t\t\t\t\t\tif (this.afterTrailingComma(tokTypes.braceR)) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst attr = this.parseImportAttribute();\n\t\t\t\t\t\tconst keyName =\n\t\t\t\t\t\t\tattr.key.type === \"Identifier\" ? attr.key.name : attr.key.value;\n\n\t\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(attributeKeys, keyName)) {\n\t\t\t\t\t\t\tthis.raiseRecoverable(\n\t\t\t\t\t\t\t\tattr.key.start,\n\t\t\t\t\t\t\t\t`Duplicate attribute key '${keyName}'`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tattributeKeys[keyName] = true;\n\t\t\t\t\t\tnodes.push(attr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isAssertLegacy) {\n\t\t\t\t\t\tnodes[LEGACY_ASSERT_ATTRIBUTES] = true;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn nodes;\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\t);\n\n// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\nconst parser = AcornParser.extend(importAssertions);\n\n/** @typedef {Record<string, string> & { _isLegacyAssert?: boolean }} ImportAttributes */\n\n/**\n * @param {ImportDeclaration | ExportNamedDeclaration | ExportAllDeclaration | ImportExpression} node node with assertions\n * @returns {ImportAttributes | undefined} import attributes\n */\nconst getImportAttributes = node => {\n\tif (node.type === \"ImportExpression\") {\n\t\tif (\n\t\t\tnode.options &&\n\t\t\tnode.options.type === \"ObjectExpression\" &&\n\t\t\tnode.options.properties[0] &&\n\t\t\tnode.options.properties[0].type === \"Property\" &&\n\t\t\tnode.options.properties[0].key.type === \"Identifier\" &&\n\t\t\t(node.options.properties[0].key.name === \"with\" ||\n\t\t\t\tnode.options.properties[0].key.name === \"assert\") &&\n\t\t\tnode.options.properties[0].value.type === \"ObjectExpression\" &&\n\t\t\tnode.options.properties[0].value.properties.length > 0\n\t\t) {\n\t\t\tconst properties =\n\t\t\t\t/** @type {Property[]} */\n\t\t\t\t(node.options.properties[0].value.properties);\n\t\t\tconst result = /** @type {ImportAttributes} */ ({});\n\t\t\tfor (const property of properties) {\n\t\t\t\tconst key =\n\t\t\t\t\t/** @type {string} */\n\t\t\t\t\t(\n\t\t\t\t\t\tproperty.key.type === \"Identifier\"\n\t\t\t\t\t\t\t? property.key.name\n\t\t\t\t\t\t\t: /** @type {Literal} */ (property.key).value\n\t\t\t\t\t);\n\t\t\t\tresult[key] =\n\t\t\t\t\t/** @type {string} */\n\t\t\t\t\t(/** @type {Literal} */ (property.value).value);\n\t\t\t}\n\t\t\tconst key =\n\t\t\t\tnode.options.properties[0].key.type === \"Identifier\"\n\t\t\t\t\t? node.options.properties[0].key.name\n\t\t\t\t\t: /** @type {Literal} */ (node.options.properties[0].key).value;\n\n\t\t\tif (key === \"assert\") {\n\t\t\t\tresult._isLegacyAssert = true;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (node.attributes === undefined || node.attributes.length === 0) {\n\t\treturn;\n\t}\n\n\tconst result = /** @type {ImportAttributes} */ ({});\n\n\tfor (const attribute of node.attributes) {\n\t\tconst key =\n\t\t\t/** @type {string} */\n\t\t\t(\n\t\t\t\tattribute.key.type === \"Identifier\"\n\t\t\t\t\t? attribute.key.name\n\t\t\t\t\t: attribute.key.value\n\t\t\t);\n\n\t\tresult[key] = /** @type {string} */ (attribute.value.value);\n\t}\n\n\tif (node.attributes[LEGACY_ASSERT_ATTRIBUTES]) {\n\t\tresult._isLegacyAssert = true;\n\t}\n\n\treturn result;\n};\n\nclass VariableInfo {\n\t/**\n\t * @param {ScopeInfo} declaredScope scope in which the variable is declared\n\t * @param {string | true | undefined} freeName which free name the variable aliases, or true when none\n\t * @param {TagInfo | undefined} tagInfo info about tags\n\t */\n\tconstructor(declaredScope, freeName, tagInfo) {\n\t\tthis.declaredScope = declaredScope;\n\t\tthis.freeName = freeName;\n\t\tthis.tagInfo = tagInfo;\n\t}\n}\n\n/** @typedef {string | ScopeInfo | VariableInfo} ExportedVariableInfo */\n/** @typedef {Literal | string | null | undefined} ImportSource */\n/** @typedef {Omit<AcornOptions, \"sourceType\" | \"ecmaVersion\"> & { sourceType: \"module\" | \"script\" | \"auto\", ecmaVersion?: AcornOptions[\"ecmaVersion\"] }} ParseOptions */\n\n/**\n * @typedef {object} TagInfo\n * @property {any} tag\n * @property {any} data\n * @property {TagInfo | undefined} next\n */\n\n/**\n * @typedef {object} ScopeInfo\n * @property {StackedMap<string, VariableInfo | ScopeInfo>} definitions\n * @property {boolean | \"arrow\"} topLevelScope\n * @property {boolean | string} inShorthand\n * @property {boolean} inTaggedTemplateTag\n * @property {boolean} inTry\n * @property {boolean} isStrict\n * @property {boolean} isAsmJs\n */\n\n/** @typedef {[number, number]} Range */\n\n/**\n * @typedef {object} DestructuringAssignmentProperty\n * @property {string} id\n * @property {Range | undefined=} range\n * @property {boolean | string} shorthand\n */\n\n/**\n * Helper function for joining two ranges into a single range. This is useful\n * when working with AST nodes, as it allows you to combine the ranges of child nodes\n * to create the range of the _parent node_.\n * @param {[number, number]} startRange start range to join\n * @param {[number, number]} endRange end range to join\n * @returns {[number, number]} joined range\n * @example\n * ```js\n * \tconst startRange = [0, 5];\n * \tconst endRange = [10, 15];\n * \tconst joinedRange = joinRanges(startRange, endRange);\n * \tconsole.log(joinedRange); // [0, 15]\n * ```\n */\nconst joinRanges = (startRange, endRange) => {\n\tif (!endRange) return startRange;\n\tif (!startRange) return endRange;\n\treturn [startRange[0], endRange[1]];\n};\n\n/**\n * Helper function used to generate a string representation of a\n * [member expression](https://github.com/estree/estree/blob/master/es5.md#memberexpression).\n * @param {string} object object to name\n * @param {string[]} membersReversed reversed list of members\n * @returns {string} member expression as a string\n * @example\n * ```js\n * const membersReversed = [\"property1\", \"property2\", \"property3\"]; // Members parsed from the AST\n * const name = objectAndMembersToName(\"myObject\", membersReversed);\n *\n * console.log(name); // \"myObject.property1.property2.property3\"\n * ```\n */\nconst objectAndMembersToName = (object, membersReversed) => {\n\tlet name = object;\n\tfor (let i = membersReversed.length - 1; i >= 0; i--) {\n\t\tname = `${name}.${membersReversed[i]}`;\n\t}\n\treturn name;\n};\n\n/**\n * Grabs the name of a given expression and returns it as a string or undefined. Has particular\n * handling for [Identifiers](https://github.com/estree/estree/blob/master/es5.md#identifier),\n * [ThisExpressions](https://github.com/estree/estree/blob/master/es5.md#identifier), and\n * [MetaProperties](https://github.com/estree/estree/blob/master/es2015.md#metaproperty) which is\n * specifically for handling the `new.target` meta property.\n * @param {Expression | SpreadElement | Super} expression expression\n * @returns {string | \"this\" | undefined} name or variable info\n */\nconst getRootName = expression => {\n\tswitch (expression.type) {\n\t\tcase \"Identifier\":\n\t\t\treturn expression.name;\n\t\tcase \"ThisExpression\":\n\t\t\treturn \"this\";\n\t\tcase \"MetaProperty\":\n\t\t\treturn `${expression.meta.name}.${expression.property.name}`;\n\t\tdefault:\n\t\t\treturn undefined;\n\t}\n};\n\n/** @type {AcornOptions} */\nconst defaultParserOptions = {\n\tranges: true,\n\tlocations: true,\n\tecmaVersion: \"latest\",\n\tsourceType: \"module\",\n\t// https://github.com/tc39/proposal-hashbang\n\tallowHashBang: true,\n\tonComment: undefined\n};\n\nconst EMPTY_COMMENT_OPTIONS = {\n\toptions: null,\n\terrors: null\n};\n\nclass JavascriptParser extends Parser {\n\t/**\n\t * @param {\"module\" | \"script\" | \"auto\"} sourceType default source type\n\t */\n\tconstructor(sourceType = \"auto\") {\n\t\tsuper();\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {HookMap<SyncBailHook<[UnaryExpression], BasicEvaluatedExpression | null | undefined>>} */\n\t\t\tevaluateTypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[Expression | SpreadElement | PrivateIdentifier], BasicEvaluatedExpression | null | undefined>>} */\n\t\t\tevaluate: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[Identifier | ThisExpression | MemberExpression | MetaProperty], BasicEvaluatedExpression | null | undefined>>} */\n\t\t\tevaluateIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[Identifier | ThisExpression | MemberExpression], BasicEvaluatedExpression | null | undefined>>} */\n\t\t\tevaluateDefinedIdentifier: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[NewExpression], BasicEvaluatedExpression | null | undefined>>} */\n\t\t\tevaluateNewExpression: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[CallExpression], BasicEvaluatedExpression | null | undefined>>} */\n\t\t\tevaluateCallExpression: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[CallExpression, BasicEvaluatedExpression], BasicEvaluatedExpression | null | undefined>>} */\n\t\t\tevaluateCallExpressionMember: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"param\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[Expression | Declaration | PrivateIdentifier, number], boolean | void>>} */\n\t\t\tisPure: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"commentsStartPosition\"])\n\t\t\t),\n\t\t\t/** @type {SyncBailHook<[Statement | ModuleDeclaration], boolean | void>} */\n\t\t\tpreStatement: new SyncBailHook([\"statement\"]),\n\n\t\t\t/** @type {SyncBailHook<[Statement | ModuleDeclaration], boolean | void>} */\n\t\t\tblockPreStatement: new SyncBailHook([\"declaration\"]),\n\t\t\t/** @type {SyncBailHook<[Statement | ModuleDeclaration], boolean | void>} */\n\t\t\tstatement: new SyncBailHook([\"statement\"]),\n\t\t\t/** @type {SyncBailHook<[IfStatement], boolean | void>} */\n\t\t\tstatementIf: new SyncBailHook([\"statement\"]),\n\t\t\t/** @type {SyncBailHook<[Expression, ClassExpression | ClassDeclaration], boolean | void>} */\n\t\t\tclassExtendsExpression: new SyncBailHook([\n\t\t\t\t\"expression\",\n\t\t\t\t\"classDefinition\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[MethodDefinition | PropertyDefinition | StaticBlock, ClassExpression | ClassDeclaration], boolean | void>} */\n\t\t\tclassBodyElement: new SyncBailHook([\"element\", \"classDefinition\"]),\n\t\t\t/** @type {SyncBailHook<[Expression, MethodDefinition | PropertyDefinition, ClassExpression | ClassDeclaration], boolean | void>} */\n\t\t\tclassBodyValue: new SyncBailHook([\n\t\t\t\t\"expression\",\n\t\t\t\t\"element\",\n\t\t\t\t\"classDefinition\"\n\t\t\t]),\n\t\t\t/** @type {HookMap<SyncBailHook<[LabeledStatement], boolean | void>>} */\n\t\t\tlabel: new HookMap(() => new SyncBailHook([\"statement\"])),\n\t\t\t/** @type {SyncBailHook<[ImportDeclaration, ImportSource], boolean | void>} */\n\t\t\timport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\t/** @type {SyncBailHook<[ImportDeclaration, ImportSource, string | null, string], boolean | void>} */\n\t\t\timportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"identifierName\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[ExportDefaultDeclaration | ExportNamedDeclaration], boolean | void>} */\n\t\t\texport: new SyncBailHook([\"statement\"]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, ImportSource], boolean | void>} */\n\t\t\texportImport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\t/** @type {SyncBailHook<[ExportDefaultDeclaration | ExportNamedDeclaration | ExportAllDeclaration, Declaration], boolean | void>} */\n\t\t\texportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\t/** @type {SyncBailHook<[ExportDefaultDeclaration, FunctionDeclaration | ClassDeclaration], boolean | void>} */\n\t\t\texportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\t/** @type {SyncBailHook<[ExportDefaultDeclaration | ExportNamedDeclaration | ExportAllDeclaration, string, string, number | undefined], boolean | void>} */\n\t\t\texportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, ImportSource, string | null, string | null, number | undefined], boolean | void>} */\n\t\t\texportImportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[VariableDeclarator, Statement], boolean | void>} */\n\t\t\tpreDeclarator: new SyncBailHook([\"declarator\", \"statement\"]),\n\t\t\t/** @type {SyncBailHook<[VariableDeclarator, Statement], boolean | void>} */\n\t\t\tdeclarator: new SyncBailHook([\"declarator\", \"statement\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */\n\t\t\tvarDeclaration: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */\n\t\t\tvarDeclarationLet: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */\n\t\t\tvarDeclarationConst: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */\n\t\t\tvarDeclarationVar: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[Identifier], boolean | void>>} */\n\t\t\tpattern: new HookMap(() => new SyncBailHook([\"pattern\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */\n\t\t\tcanRename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */\n\t\t\trename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[AssignmentExpression], boolean | void>>} */\n\t\t\tassign: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[AssignmentExpression, string[]], boolean | void>>} */\n\t\t\tassignMemberChain: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"members\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */\n\t\t\ttypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {SyncBailHook<[ImportExpression], boolean | void>} */\n\t\t\timportCall: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {SyncBailHook<[Expression | ForOfStatement], boolean | void>} */\n\t\t\ttopLevelAwait: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[CallExpression], boolean | void>>} */\n\t\t\tcall: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** Something like \"a.b()\" */\n\t\t\t/** @type {HookMap<SyncBailHook<[CallExpression, string[], boolean[], Range[]], boolean | void>>} */\n\t\t\tcallMemberChain: new HookMap(\n\t\t\t\t() =>\n\t\t\t\t\tnew SyncBailHook([\n\t\t\t\t\t\t\"expression\",\n\t\t\t\t\t\t\"members\",\n\t\t\t\t\t\t\"membersOptionals\",\n\t\t\t\t\t\t\"memberRanges\"\n\t\t\t\t\t])\n\t\t\t),\n\t\t\t/** Something like \"a.b().c.d\" */\n\t\t\t/** @type {HookMap<SyncBailHook<[Expression, string[], CallExpression, string[], Range[]], boolean | void>>} */\n\t\t\tmemberChainOfCallMemberChain: new HookMap(\n\t\t\t\t() =>\n\t\t\t\t\tnew SyncBailHook([\n\t\t\t\t\t\t\"expression\",\n\t\t\t\t\t\t\"calleeMembers\",\n\t\t\t\t\t\t\"callExpression\",\n\t\t\t\t\t\t\"members\",\n\t\t\t\t\t\t\"memberRanges\"\n\t\t\t\t\t])\n\t\t\t),\n\t\t\t/** Something like \"a.b().c.d()\"\" */\n\t\t\t/** @type {HookMap<SyncBailHook<[CallExpression, string[], CallExpression, string[], Range[]], boolean | void>>} */\n\t\t\tcallMemberChainOfCallMemberChain: new HookMap(\n\t\t\t\t() =>\n\t\t\t\t\tnew SyncBailHook([\n\t\t\t\t\t\t\"expression\",\n\t\t\t\t\t\t\"calleeMembers\",\n\t\t\t\t\t\t\"innerCallExpression\",\n\t\t\t\t\t\t\"members\",\n\t\t\t\t\t\t\"memberRanges\"\n\t\t\t\t\t])\n\t\t\t),\n\t\t\t/** @type {SyncBailHook<[ChainExpression], boolean | void>} */\n\t\t\toptionalChaining: new SyncBailHook([\"optionalChaining\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[NewExpression], boolean | void>>} */\n\t\t\tnew: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {SyncBailHook<[BinaryExpression], boolean | void>} */\n\t\t\tbinaryExpression: new SyncBailHook([\"binaryExpression\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */\n\t\t\texpression: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[MemberExpression, string[], boolean[], Range[]], boolean | void>>} */\n\t\t\texpressionMemberChain: new HookMap(\n\t\t\t\t() =>\n\t\t\t\t\tnew SyncBailHook([\n\t\t\t\t\t\t\"expression\",\n\t\t\t\t\t\t\"members\",\n\t\t\t\t\t\t\"membersOptionals\",\n\t\t\t\t\t\t\"memberRanges\"\n\t\t\t\t\t])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[MemberExpression, string[]], boolean | void>>} */\n\t\t\tunhandledExpressionMemberChain: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"members\"])\n\t\t\t),\n\t\t\t/** @type {SyncBailHook<[ConditionalExpression], boolean | void>} */\n\t\t\texpressionConditionalOperator: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {SyncBailHook<[LogicalExpression], boolean | void>} */\n\t\t\texpressionLogicalOperator: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {SyncBailHook<[Program, Comment[]], boolean | void>} */\n\t\t\tprogram: new SyncBailHook([\"ast\", \"comments\"]),\n\t\t\t/** @type {SyncBailHook<[Program, Comment[]], boolean | void>} */\n\t\t\tfinish: new SyncBailHook([\"ast\", \"comments\"])\n\t\t});\n\t\tthis.sourceType = sourceType;\n\t\t/** @type {ScopeInfo} */\n\t\tthis.scope = undefined;\n\t\t/** @type {ParserState} */\n\t\tthis.state = undefined;\n\t\t/** @type {Comment[] | undefined} */\n\t\tthis.comments = undefined;\n\t\t/** @type {Set<number> | undefined} */\n\t\tthis.semicolons = undefined;\n\t\t/** @type {StatementPath | undefined} */\n\t\tthis.statementPath = undefined;\n\t\t/** @type {Statement | ModuleDeclaration | Expression | undefined} */\n\t\tthis.prevStatement = undefined;\n\t\t/** @type {WeakMap<Expression, Set<DestructuringAssignmentProperty>> | undefined} */\n\t\tthis.destructuringAssignmentProperties = undefined;\n\t\tthis.currentTagData = undefined;\n\t\tthis.magicCommentContext = createMagicCommentContext();\n\t\tthis._initializeEvaluating();\n\t}\n\n\t_initializeEvaluating() {\n\t\tthis.hooks.evaluate.for(\"Literal\").tap(\"JavascriptParser\", _expr => {\n\t\t\tconst expr = /** @type {Literal} */ (_expr);\n\n\t\t\tswitch (typeof expr.value) {\n\t\t\t\tcase \"number\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setNumber(expr.value)\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\tcase \"bigint\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBigInt(expr.value)\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(expr.value)\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(expr.value)\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t}\n\t\t\tif (expr.value === null) {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setNull()\n\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t}\n\t\t\tif (expr.value instanceof RegExp) {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setRegExp(expr.value)\n\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"NewExpression\").tap(\"JavascriptParser\", _expr => {\n\t\t\tconst expr = /** @type {NewExpression} */ (_expr);\n\t\t\tconst callee = expr.callee;\n\t\t\tif (callee.type !== \"Identifier\") return;\n\t\t\tif (callee.name !== \"RegExp\") {\n\t\t\t\treturn this.callHooksForName(\n\t\t\t\t\tthis.hooks.evaluateNewExpression,\n\t\t\t\t\tcallee.name,\n\t\t\t\t\texpr\n\t\t\t\t);\n\t\t\t} else if (\n\t\t\t\texpr.arguments.length > 2 ||\n\t\t\t\tthis.getVariableInfo(\"RegExp\") !== \"RegExp\"\n\t\t\t)\n\t\t\t\treturn;\n\n\t\t\tlet regExp;\n\t\t\tconst arg1 = expr.arguments[0];\n\n\t\t\tif (arg1) {\n\t\t\t\tif (arg1.type === \"SpreadElement\") return;\n\n\t\t\t\tconst evaluatedRegExp = this.evaluateExpression(arg1);\n\n\t\t\t\tif (!evaluatedRegExp) return;\n\n\t\t\t\tregExp = evaluatedRegExp.asString();\n\n\t\t\t\tif (!regExp) return;\n\t\t\t} else {\n\t\t\t\treturn (\n\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t// eslint-disable-next-line prefer-regex-literals\n\t\t\t\t\t\t.setRegExp(new RegExp(\"\"))\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tlet flags;\n\t\t\tconst arg2 = expr.arguments[1];\n\n\t\t\tif (arg2) {\n\t\t\t\tif (arg2.type === \"SpreadElement\") return;\n\n\t\t\t\tconst evaluatedFlags = this.evaluateExpression(arg2);\n\n\t\t\t\tif (!evaluatedFlags) return;\n\n\t\t\t\tif (!evaluatedFlags.isUndefined()) {\n\t\t\t\t\tflags = evaluatedFlags.asString();\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tflags === undefined ||\n\t\t\t\t\t\t!BasicEvaluatedExpression.isValidRegExpFlags(flags)\n\t\t\t\t\t)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))\n\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"LogicalExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {LogicalExpression} */ (_expr);\n\n\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\tlet returnRight = false;\n\t\t\t\t/** @type {boolean | undefined} */\n\t\t\t\tlet allowedRight;\n\t\t\t\tif (expr.operator === \"&&\") {\n\t\t\t\t\tconst leftAsBool = left.asBool();\n\t\t\t\t\tif (leftAsBool === false)\n\t\t\t\t\t\treturn left.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t\treturnRight = leftAsBool === true;\n\t\t\t\t\tallowedRight = false;\n\t\t\t\t} else if (expr.operator === \"||\") {\n\t\t\t\t\tconst leftAsBool = left.asBool();\n\t\t\t\t\tif (leftAsBool === true)\n\t\t\t\t\t\treturn left.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t\treturnRight = leftAsBool === false;\n\t\t\t\t\tallowedRight = true;\n\t\t\t\t} else if (expr.operator === \"??\") {\n\t\t\t\t\tconst leftAsNullish = left.asNullish();\n\t\t\t\t\tif (leftAsNullish === false)\n\t\t\t\t\t\treturn left.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t\tif (leftAsNullish !== true) return;\n\t\t\t\t\treturnRight = true;\n\t\t\t\t} else return;\n\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\tif (returnRight) {\n\t\t\t\t\tif (left.couldHaveSideEffects()) right.setSideEffects();\n\t\t\t\t\treturn right.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t}\n\n\t\t\t\tconst asBool = right.asBool();\n\n\t\t\t\tif (allowedRight === true && asBool === true) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range))\n\t\t\t\t\t\t.setTruthy();\n\t\t\t\t} else if (allowedRight === false && asBool === false) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range))\n\t\t\t\t\t\t.setFalsy();\n\t\t\t\t}\n\t\t\t});\n\n\t\t/**\n\t\t * In simple logical cases, we can use valueAsExpression to assist us in evaluating the expression on\n\t\t * either side of a [BinaryExpression](https://github.com/estree/estree/blob/master/es5.md#binaryexpression).\n\t\t * This supports scenarios in webpack like conditionally `import()`'ing modules based on some simple evaluation:\n\t\t *\n\t\t * ```js\n\t\t * if (1 === 3) {\n\t\t *  import(\"./moduleA\"); // webpack will auto evaluate this and not import the modules\n\t\t * }\n\t\t * ```\n\t\t *\n\t\t * Additional scenarios include evaluation of strings inside of dynamic import statements:\n\t\t *\n\t\t * ```js\n\t\t * const foo = \"foo\";\n\t\t * const bar = \"bar\";\n\t\t *\n\t\t * import(\"./\" + foo + bar); // webpack will auto evaluate this into import(\"./foobar\")\n\t\t * ```\n\t\t * @param {boolean | number | bigint | string} value the value to convert to an expression\n\t\t * @param {BinaryExpression | UnaryExpression} expr the expression being evaluated\n\t\t * @param {boolean} sideEffects whether the expression has side effects\n\t\t * @returns {BasicEvaluatedExpression | undefined} the evaluated expression\n\t\t * @example\n\t\t *\n\t\t * ```js\n\t\t * const binaryExpr = new BinaryExpression(\"+\",\n\t\t * \t{ type: \"Literal\", value: 2 },\n\t\t * \t{ type: \"Literal\", value: 3 }\n\t\t * );\n\t\t *\n\t\t * const leftValue = 2;\n\t\t * const rightValue = 3;\n\t\t *\n\t\t * const leftExpr = valueAsExpression(leftValue, binaryExpr.left, false);\n\t\t * const rightExpr = valueAsExpression(rightValue, binaryExpr.right, false);\n\t\t * const result = new BasicEvaluatedExpression()\n\t\t * \t.setNumber(leftExpr.number + rightExpr.number)\n\t\t * \t.setRange(binaryExpr.range);\n\t\t *\n\t\t * console.log(result.number); // Output: 5\n\t\t * ```\n\t\t */\n\t\tconst valueAsExpression = (value, expr, sideEffects) => {\n\t\t\tswitch (typeof value) {\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\tcase \"number\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setNumber(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\tcase \"bigint\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBigInt(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t}\n\t\t};\n\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"BinaryExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {BinaryExpression} */ (_expr);\n\n\t\t\t\t/**\n\t\t\t\t * Evaluates a binary expression if and only if it is a const operation (e.g. 1 + 2, \"a\" + \"b\", etc.).\n\t\t\t\t * @template T\n\t\t\t\t * @param {(leftOperand: T, rightOperand: T) => boolean | number | bigint | string} operandHandler the handler for the operation (e.g. (a, b) => a + b)\n\t\t\t\t * @returns {BasicEvaluatedExpression | undefined} the evaluated expression\n\t\t\t\t */\n\t\t\t\tconst handleConstOperation = operandHandler => {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tif (!left.isCompileTimeValue()) return;\n\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tif (!right.isCompileTimeValue()) return;\n\n\t\t\t\t\tconst result = operandHandler(\n\t\t\t\t\t\tleft.asCompileTimeValue(),\n\t\t\t\t\t\tright.asCompileTimeValue()\n\t\t\t\t\t);\n\t\t\t\t\treturn valueAsExpression(\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\texpr,\n\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * Helper function to determine if two booleans are always different. This is used in `handleStrictEqualityComparison`\n\t\t\t\t * to determine if an expressions boolean or nullish conversion is equal or not.\n\t\t\t\t * @param {boolean} a first boolean to compare\n\t\t\t\t * @param {boolean} b second boolean to compare\n\t\t\t\t * @returns {boolean} true if the two booleans are always different, false otherwise\n\t\t\t\t */\n\t\t\t\tconst isAlwaysDifferent = (a, b) =>\n\t\t\t\t\t(a === true && b === false) || (a === false && b === true);\n\n\t\t\t\t/**\n\t\t\t\t * @param {BasicEvaluatedExpression} left left\n\t\t\t\t * @param {BasicEvaluatedExpression} right right\n\t\t\t\t * @param {BasicEvaluatedExpression} res res\n\t\t\t\t * @param {boolean} eql true for \"===\" and false for \"!==\"\n\t\t\t\t * @returns {BasicEvaluatedExpression | undefined} result\n\t\t\t\t */\n\t\t\t\tconst handleTemplateStringCompare = (left, right, res, eql) => {\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {BasicEvaluatedExpression[]} parts parts\n\t\t\t\t\t * @returns {string} value\n\t\t\t\t\t */\n\t\t\t\t\tconst getPrefix = parts => {\n\t\t\t\t\t\tlet value = \"\";\n\t\t\t\t\t\tfor (const p of parts) {\n\t\t\t\t\t\t\tconst v = p.asString();\n\t\t\t\t\t\t\tif (v !== undefined) value += v;\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t};\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {BasicEvaluatedExpression[]} parts parts\n\t\t\t\t\t * @returns {string} value\n\t\t\t\t\t */\n\t\t\t\t\tconst getSuffix = parts => {\n\t\t\t\t\t\tlet value = \"\";\n\t\t\t\t\t\tfor (let i = parts.length - 1; i >= 0; i--) {\n\t\t\t\t\t\t\tconst v = parts[i].asString();\n\t\t\t\t\t\t\tif (v !== undefined) value = v + value;\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t};\n\t\t\t\t\tconst leftPrefix = getPrefix(\n\t\t\t\t\t\t/** @type {BasicEvaluatedExpression[]} */ (left.parts)\n\t\t\t\t\t);\n\t\t\t\t\tconst rightPrefix = getPrefix(\n\t\t\t\t\t\t/** @type {BasicEvaluatedExpression[]} */ (right.parts)\n\t\t\t\t\t);\n\t\t\t\t\tconst leftSuffix = getSuffix(\n\t\t\t\t\t\t/** @type {BasicEvaluatedExpression[]} */ (left.parts)\n\t\t\t\t\t);\n\t\t\t\t\tconst rightSuffix = getSuffix(\n\t\t\t\t\t\t/** @type {BasicEvaluatedExpression[]} */ (right.parts)\n\t\t\t\t\t);\n\t\t\t\t\tconst lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);\n\t\t\t\t\tconst lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);\n\t\t\t\t\tconst prefixMismatch =\n\t\t\t\t\t\tlenPrefix > 0 &&\n\t\t\t\t\t\tleftPrefix.slice(0, lenPrefix) !== rightPrefix.slice(0, lenPrefix);\n\t\t\t\t\tconst suffixMismatch =\n\t\t\t\t\t\tlenSuffix > 0 &&\n\t\t\t\t\t\tleftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix);\n\t\t\t\t\tif (prefixMismatch || suffixMismatch) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * Helper function to handle BinaryExpressions using strict equality comparisons (e.g. \"===\" and \"!==\").\n\t\t\t\t * @param {boolean} eql true for \"===\" and false for \"!==\"\n\t\t\t\t * @returns {BasicEvaluatedExpression | undefined} the evaluated expression\n\t\t\t\t */\n\t\t\t\tconst handleStrictEqualityComparison = eql => {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\t\tres.setRange(/** @type {Range} */ (expr.range));\n\n\t\t\t\t\tconst leftConst = left.isCompileTimeValue();\n\t\t\t\t\tconst rightConst = right.isCompileTimeValue();\n\n\t\t\t\t\tif (leftConst && rightConst) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(\n\t\t\t\t\t\t\t\teql ===\n\t\t\t\t\t\t\t\t\t(left.asCompileTimeValue() === right.asCompileTimeValue())\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (left.isArray() && right.isArray()) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (left.isTemplateString() && right.isTemplateString()) {\n\t\t\t\t\t\treturn handleTemplateStringCompare(left, right, res, eql);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst leftPrimitive = left.isPrimitiveType();\n\t\t\t\t\tconst rightPrimitive = right.isPrimitiveType();\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t// Primitive !== Object or\n\t\t\t\t\t\t// compile-time object types are never equal to something at runtime\n\t\t\t\t\t\t(leftPrimitive === false &&\n\t\t\t\t\t\t\t(leftConst || rightPrimitive === true)) ||\n\t\t\t\t\t\t(rightPrimitive === false &&\n\t\t\t\t\t\t\t(rightConst || leftPrimitive === true)) ||\n\t\t\t\t\t\t// Different nullish or boolish status also means not equal\n\t\t\t\t\t\tisAlwaysDifferent(\n\t\t\t\t\t\t\t/** @type {boolean} */ (left.asBool()),\n\t\t\t\t\t\t\t/** @type {boolean} */ (right.asBool())\n\t\t\t\t\t\t) ||\n\t\t\t\t\t\tisAlwaysDifferent(\n\t\t\t\t\t\t\t/** @type {boolean} */ (left.asNullish()),\n\t\t\t\t\t\t\t/** @type {boolean} */ (right.asNullish())\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * Helper function to handle BinaryExpressions using abstract equality comparisons (e.g. \"==\" and \"!=\").\n\t\t\t\t * @param {boolean} eql true for \"==\" and false for \"!=\"\n\t\t\t\t * @returns {BasicEvaluatedExpression | undefined} the evaluated expression\n\t\t\t\t */\n\t\t\t\tconst handleAbstractEqualityComparison = eql => {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\t\tres.setRange(/** @type {Range} */ (expr.range));\n\n\t\t\t\t\tconst leftConst = left.isCompileTimeValue();\n\t\t\t\t\tconst rightConst = right.isCompileTimeValue();\n\n\t\t\t\t\tif (leftConst && rightConst) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(\n\t\t\t\t\t\t\t\teql ===\n\t\t\t\t\t\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\t\t\t\t\t\t(left.asCompileTimeValue() == right.asCompileTimeValue())\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (left.isArray() && right.isArray()) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (left.isTemplateString() && right.isTemplateString()) {\n\t\t\t\t\t\treturn handleTemplateStringCompare(left, right, res, eql);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tif (expr.operator === \"+\") {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\t\tif (left.isString()) {\n\t\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t\tres.setString(\n\t\t\t\t\t\t\t\t/** @type {string} */ (left.string) +\n\t\t\t\t\t\t\t\t\t/** @type {string} */ (right.string)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t\tres.setString(/** @type {string} */ (left.string) + right.number);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tright.isWrapped() &&\n\t\t\t\t\t\t\tright.prefix &&\n\t\t\t\t\t\t\tright.prefix.isString()\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// \"left\" + (\"prefix\" + inner + \"postfix\")\n\t\t\t\t\t\t\t// => (\"leftPrefix\" + inner + \"postfix\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(\n\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (left.string) +\n\t\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (right.prefix.string)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t.setRange(\n\t\t\t\t\t\t\t\t\t\tjoinRanges(\n\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (left.range),\n\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (right.prefix.range)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t\t// \"left\" + ([null] + inner + \"postfix\")\n\t\t\t\t\t\t\t// => (\"left\" + inner + \"postfix\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// \"left\" + expr\n\t\t\t\t\t\t\t// => (\"left\" + expr + \"\")\n\t\t\t\t\t\t\tres.setWrapped(left, null, [right]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (left.isNumber()) {\n\t\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t\tres.setString(left.number + /** @type {string} */ (right.string));\n\t\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t\tres.setNumber(\n\t\t\t\t\t\t\t\t/** @type {number} */ (left.number) +\n\t\t\t\t\t\t\t\t\t/** @type {number} */ (right.number)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (left.isBigInt()) {\n\t\t\t\t\t\tif (right.isBigInt()) {\n\t\t\t\t\t\t\tres.setBigInt(\n\t\t\t\t\t\t\t\t/** @type {bigint} */ (left.bigint) +\n\t\t\t\t\t\t\t\t\t/** @type {bigint} */ (right.bigint)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (left.isWrapped()) {\n\t\t\t\t\t\tif (left.postfix && left.postfix.isString() && right.isString()) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + \"right\"\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfixRight\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(\n\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (left.postfix.string) +\n\t\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (right.string)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t.setRange(\n\t\t\t\t\t\t\t\t\t\tjoinRanges(\n\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (left.postfix.range),\n\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (right.range)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tleft.postfix &&\n\t\t\t\t\t\t\tleft.postfix.isString() &&\n\t\t\t\t\t\t\tright.isNumber()\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + 123\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfix123\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(\n\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (left.postfix.string) +\n\t\t\t\t\t\t\t\t\t\t\t/** @type {number} */ (right.number)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t.setRange(\n\t\t\t\t\t\t\t\t\t\tjoinRanges(\n\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (left.postfix.range),\n\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (right.range)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (right.isString()) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + \"right\"\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"right\")\n\t\t\t\t\t\t\tres.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n\t\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + 123\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"123\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(String(right.number))\n\t\t\t\t\t\t\t\t\t.setRange(/** @type {Range} */ (right.range)),\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t\t\t.concat(left.postfix ? [left.postfix] : [])\n\t\t\t\t\t\t\t\t\t\t.concat(right.prefix ? [right.prefix] : [])\n\t\t\t\t\t\t\t\t\t\t.concat(right.wrappedInnerExpressions)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + postfix) + expr\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + postfix + expr + [null])\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions.concat(\n\t\t\t\t\t\t\t\t\t\tleft.postfix ? [left.postfix, right] : [right]\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (right.isString()) {\n\t\t\t\t\t\t// left + \"right\"\n\t\t\t\t\t\t// => ([null] + left + \"right\")\n\t\t\t\t\t\tres.setWrapped(null, right, [left]);\n\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t// left + (prefix + inner + \"postfix\")\n\t\t\t\t\t\t// => ([null] + left + prefix + inner + \"postfix\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t(right.prefix ? [left, right.prefix] : [left]).concat(\n\t\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (left.couldHaveSideEffects() || right.couldHaveSideEffects())\n\t\t\t\t\t\tres.setSideEffects();\n\t\t\t\t\tres.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t\treturn res;\n\t\t\t\t} else if (expr.operator === \"-\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l - r);\n\t\t\t\t} else if (expr.operator === \"*\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l * r);\n\t\t\t\t} else if (expr.operator === \"/\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l / r);\n\t\t\t\t} else if (expr.operator === \"**\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l ** r);\n\t\t\t\t} else if (expr.operator === \"===\") {\n\t\t\t\t\treturn handleStrictEqualityComparison(true);\n\t\t\t\t} else if (expr.operator === \"==\") {\n\t\t\t\t\treturn handleAbstractEqualityComparison(true);\n\t\t\t\t} else if (expr.operator === \"!==\") {\n\t\t\t\t\treturn handleStrictEqualityComparison(false);\n\t\t\t\t} else if (expr.operator === \"!=\") {\n\t\t\t\t\treturn handleAbstractEqualityComparison(false);\n\t\t\t\t} else if (expr.operator === \"&\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l & r);\n\t\t\t\t} else if (expr.operator === \"|\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l | r);\n\t\t\t\t} else if (expr.operator === \"^\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l ^ r);\n\t\t\t\t} else if (expr.operator === \">>>\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l >>> r);\n\t\t\t\t} else if (expr.operator === \">>\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l >> r);\n\t\t\t\t} else if (expr.operator === \"<<\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l << r);\n\t\t\t\t} else if (expr.operator === \"<\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l < r);\n\t\t\t\t} else if (expr.operator === \">\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l > r);\n\t\t\t\t} else if (expr.operator === \"<=\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l <= r);\n\t\t\t\t} else if (expr.operator === \">=\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l >= r);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"UnaryExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {UnaryExpression} */ (_expr);\n\n\t\t\t\t/**\n\t\t\t\t * Evaluates a UnaryExpression if and only if it is a basic const operator (e.g. +a, -a, ~a).\n\t\t\t\t * @template T\n\t\t\t\t * @param {(operand: T) => boolean | number | bigint | string} operandHandler handler for the operand\n\t\t\t\t * @returns {BasicEvaluatedExpression | undefined} evaluated expression\n\t\t\t\t */\n\t\t\t\tconst handleConstOperation = operandHandler => {\n\t\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\t\tif (!argument.isCompileTimeValue()) return;\n\t\t\t\t\tconst result = operandHandler(argument.asCompileTimeValue());\n\t\t\t\t\treturn valueAsExpression(\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\texpr,\n\t\t\t\t\t\targument.couldHaveSideEffects()\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\tif (expr.operator === \"typeof\") {\n\t\t\t\t\tswitch (expr.argument.type) {\n\t\t\t\t\t\tcase \"Identifier\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForName(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\texpr.argument.name,\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"MetaProperty\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForName(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\t/** @type {string} */ (getRootName(expr.argument)),\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"MemberExpression\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForExpression(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\texpr.argument,\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"ChainExpression\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForExpression(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\texpr.argument.expression,\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"FunctionExpression\": {\n\t\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(\"function\")\n\t\t\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst arg = this.evaluateExpression(expr.argument);\n\t\t\t\t\tif (arg.isUnknown()) return;\n\t\t\t\t\tif (arg.isString()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"string\")\n\t\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isWrapped()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"string\")\n\t\t\t\t\t\t\t.setSideEffects()\n\t\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isUndefined()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"undefined\")\n\t\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isNumber()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"number\")\n\t\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isBigInt()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"bigint\")\n\t\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isBoolean()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"boolean\")\n\t\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"object\")\n\t\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isArray()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"object\")\n\t\t\t\t\t\t\t.setSideEffects(arg.couldHaveSideEffects())\n\t\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t\t}\n\t\t\t\t} else if (expr.operator === \"!\") {\n\t\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\t\tconst bool = argument.asBool();\n\t\t\t\t\tif (typeof bool !== \"boolean\") return;\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!bool)\n\t\t\t\t\t\t.setSideEffects(argument.couldHaveSideEffects())\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t} else if (expr.operator === \"~\") {\n\t\t\t\t\treturn handleConstOperation(v => ~v);\n\t\t\t\t} else if (expr.operator === \"+\") {\n\t\t\t\t\t// eslint-disable-next-line no-implicit-coercion\n\t\t\t\t\treturn handleConstOperation(v => +v);\n\t\t\t\t} else if (expr.operator === \"-\") {\n\t\t\t\t\treturn handleConstOperation(v => -v);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluateTypeof\n\t\t\t.for(\"undefined\")\n\t\t\t.tap(\"JavascriptParser\", expr =>\n\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t.setString(\"undefined\")\n\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range))\n\t\t\t);\n\t\tthis.hooks.evaluate.for(\"Identifier\").tap(\"JavascriptParser\", expr => {\n\t\t\tif (/** @type {Identifier} */ (expr).name === \"undefined\") {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setUndefined()\n\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t}\n\t\t});\n\t\t/**\n\t\t * @param {\"Identifier\" | \"ThisExpression\" | \"MemberExpression\"} exprType expression type name\n\t\t * @param {function(Expression | SpreadElement): GetInfoResult | undefined} getInfo get info\n\t\t * @returns {void}\n\t\t */\n\t\tconst tapEvaluateWithVariableInfo = (exprType, getInfo) => {\n\t\t\t/** @type {Expression | undefined} */\n\t\t\tlet cachedExpression;\n\t\t\t/** @type {GetInfoResult | undefined} */\n\t\t\tlet cachedInfo;\n\t\t\tthis.hooks.evaluate.for(exprType).tap(\"JavascriptParser\", expr => {\n\t\t\t\tconst expression =\n\t\t\t\t\t/** @type {Identifier | ThisExpression | MemberExpression} */ (expr);\n\n\t\t\t\tconst info = getInfo(expression);\n\t\t\t\tif (info !== undefined) {\n\t\t\t\t\treturn this.callHooksForInfoWithFallback(\n\t\t\t\t\t\tthis.hooks.evaluateIdentifier,\n\t\t\t\t\t\tinfo.name,\n\t\t\t\t\t\tname => {\n\t\t\t\t\t\t\tcachedExpression = expression;\n\t\t\t\t\t\t\tcachedInfo = info;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tname => {\n\t\t\t\t\t\t\tconst hook = this.hooks.evaluateDefinedIdentifier.get(name);\n\t\t\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\t\t\treturn hook.call(expression);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\texpression\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.hooks.evaluate\n\t\t\t\t.for(exprType)\n\t\t\t\t.tap({ name: \"JavascriptParser\", stage: 100 }, expr => {\n\t\t\t\t\tconst expression =\n\t\t\t\t\t\t/** @type {Identifier | ThisExpression | MemberExpression} */\n\t\t\t\t\t\t(expr);\n\t\t\t\t\tconst info =\n\t\t\t\t\t\tcachedExpression === expression ? cachedInfo : getInfo(expression);\n\t\t\t\t\tif (info !== undefined) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setIdentifier(\n\t\t\t\t\t\t\t\tinfo.name,\n\t\t\t\t\t\t\t\tinfo.rootInfo,\n\t\t\t\t\t\t\t\tinfo.getMembers,\n\t\t\t\t\t\t\t\tinfo.getMembersOptionals,\n\t\t\t\t\t\t\t\tinfo.getMemberRanges\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.setRange(/** @type {Range} */ (expression.range));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tthis.hooks.finish.tap(\"JavascriptParser\", () => {\n\t\t\t\t// Cleanup for GC\n\t\t\t\tcachedExpression = cachedInfo = undefined;\n\t\t\t});\n\t\t};\n\t\ttapEvaluateWithVariableInfo(\"Identifier\", expr => {\n\t\t\tconst info = this.getVariableInfo(/** @type {Identifier} */ (expr).name);\n\t\t\tif (\n\t\t\t\ttypeof info === \"string\" ||\n\t\t\t\t(info instanceof VariableInfo && typeof info.freeName === \"string\")\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\tname: info,\n\t\t\t\t\trootInfo: info,\n\t\t\t\t\tgetMembers: () => [],\n\t\t\t\t\tgetMembersOptionals: () => [],\n\t\t\t\t\tgetMemberRanges: () => []\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\ttapEvaluateWithVariableInfo(\"ThisExpression\", expr => {\n\t\t\tconst info = this.getVariableInfo(\"this\");\n\t\t\tif (\n\t\t\t\ttypeof info === \"string\" ||\n\t\t\t\t(info instanceof VariableInfo && typeof info.freeName === \"string\")\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\tname: info,\n\t\t\t\t\trootInfo: info,\n\t\t\t\t\tgetMembers: () => [],\n\t\t\t\t\tgetMembersOptionals: () => [],\n\t\t\t\t\tgetMemberRanges: () => []\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"MetaProperty\").tap(\"JavascriptParser\", expr => {\n\t\t\tconst metaProperty = /** @type {MetaProperty} */ (expr);\n\n\t\t\treturn this.callHooksForName(\n\t\t\t\tthis.hooks.evaluateIdentifier,\n\t\t\t\t/** @type {string} */ (getRootName(metaProperty)),\n\t\t\t\tmetaProperty\n\t\t\t);\n\t\t});\n\t\ttapEvaluateWithVariableInfo(\"MemberExpression\", expr =>\n\t\t\tthis.getMemberExpressionInfo(\n\t\t\t\t/** @type {MemberExpression} */ (expr),\n\t\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t\t)\n\t\t);\n\n\t\tthis.hooks.evaluate.for(\"CallExpression\").tap(\"JavascriptParser\", _expr => {\n\t\t\tconst expr = /** @type {CallExpression} */ (_expr);\n\t\t\tif (\n\t\t\t\texpr.callee.type === \"MemberExpression\" &&\n\t\t\t\texpr.callee.property.type ===\n\t\t\t\t\t(expr.callee.computed ? \"Literal\" : \"Identifier\")\n\t\t\t) {\n\t\t\t\t// type Super also possible here\n\t\t\t\tconst param = this.evaluateExpression(\n\t\t\t\t\t/** @type {Expression} */ (expr.callee.object)\n\t\t\t\t);\n\t\t\t\tconst property =\n\t\t\t\t\texpr.callee.property.type === \"Literal\"\n\t\t\t\t\t\t? `${expr.callee.property.value}`\n\t\t\t\t\t\t: expr.callee.property.name;\n\t\t\t\tconst hook = this.hooks.evaluateCallExpressionMember.get(property);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\treturn hook.call(expr, param);\n\t\t\t\t}\n\t\t\t} else if (expr.callee.type === \"Identifier\") {\n\t\t\t\treturn this.callHooksForName(\n\t\t\t\t\tthis.hooks.evaluateCallExpression,\n\t\t\t\t\texpr.callee.name,\n\t\t\t\t\texpr\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"indexOf\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length === 0) return;\n\t\t\t\tconst [arg1, arg2] = expr.arguments;\n\t\t\t\tif (arg1.type === \"SpreadElement\") return;\n\t\t\t\tconst arg1Eval = this.evaluateExpression(arg1);\n\t\t\t\tif (!arg1Eval.isString()) return;\n\t\t\t\tconst arg1Value = /** @type {string} */ (arg1Eval.string);\n\n\t\t\t\tlet result;\n\t\t\t\tif (arg2) {\n\t\t\t\t\tif (arg2.type === \"SpreadElement\") return;\n\t\t\t\t\tconst arg2Eval = this.evaluateExpression(arg2);\n\t\t\t\t\tif (!arg2Eval.isNumber()) return;\n\t\t\t\t\tresult = /** @type {string} */ (param.string).indexOf(\n\t\t\t\t\t\targ1Value,\n\t\t\t\t\t\targ2Eval.number\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tresult = /** @type {string} */ (param.string).indexOf(arg1Value);\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setNumber(result)\n\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"replace\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 2) return;\n\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\tif (expr.arguments[1].type === \"SpreadElement\") return;\n\t\t\t\tconst arg1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tconst arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\tif (!arg1.isString() && !arg1.isRegExp()) return;\n\t\t\t\tconst arg1Value = /** @type {string | RegExp} */ (\n\t\t\t\t\targ1.regExp || arg1.string\n\t\t\t\t);\n\t\t\t\tif (!arg2.isString()) return;\n\t\t\t\tconst arg2Value = /** @type {string} */ (arg2.string);\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(\n\t\t\t\t\t\t/** @type {string} */ (param.string).replace(arg1Value, arg2Value)\n\t\t\t\t\t)\n\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t});\n\t\tfor (const fn of [\"substr\", \"substring\", \"slice\"]) {\n\t\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t\t.for(fn)\n\t\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\t\tif (!param.isString()) return;\n\t\t\t\t\tlet arg1;\n\t\t\t\t\tlet result;\n\t\t\t\t\tconst str = /** @type {string} */ (param.string);\n\t\t\t\t\tswitch (expr.arguments.length) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[\n\t\t\t\t\t\t\t\t/** @type {\"substr\" | \"substring\" | \"slice\"} */ (fn)\n\t\t\t\t\t\t\t](/** @type {number} */ (arg1.number));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\t\t\t\tif (expr.arguments[1].type === \"SpreadElement\") return;\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tconst arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tif (!arg2.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[\n\t\t\t\t\t\t\t\t/** @type {\"substr\" | \"substring\" | \"slice\"} */ (fn)\n\t\t\t\t\t\t\t](\n\t\t\t\t\t\t\t\t/** @type {number} */ (arg1.number),\n\t\t\t\t\t\t\t\t/** @type {number} */ (arg2.number)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(result)\n\t\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * @param {\"cooked\" | \"raw\"} kind kind of values to get\n\t\t * @param {TemplateLiteral} templateLiteralExpr TemplateLiteral expr\n\t\t * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n\t\t */\n\t\tconst getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {\n\t\t\t/** @type {BasicEvaluatedExpression[]} */\n\t\t\tconst quasis = [];\n\t\t\t/** @type {BasicEvaluatedExpression[]} */\n\t\t\tconst parts = [];\n\n\t\t\tfor (let i = 0; i < templateLiteralExpr.quasis.length; i++) {\n\t\t\t\tconst quasiExpr = templateLiteralExpr.quasis[i];\n\t\t\t\tconst quasi = quasiExpr.value[kind];\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tconst prevExpr = parts[parts.length - 1];\n\t\t\t\t\tconst expr = this.evaluateExpression(\n\t\t\t\t\t\ttemplateLiteralExpr.expressions[i - 1]\n\t\t\t\t\t);\n\t\t\t\t\tconst exprAsString = expr.asString();\n\t\t\t\t\tif (\n\t\t\t\t\t\ttypeof exprAsString === \"string\" &&\n\t\t\t\t\t\t!expr.couldHaveSideEffects()\n\t\t\t\t\t) {\n\t\t\t\t\t\t// We can merge quasi + expr + quasi when expr\n\t\t\t\t\t\t// is a const string\n\n\t\t\t\t\t\tprevExpr.setString(prevExpr.string + exprAsString + quasi);\n\t\t\t\t\t\tprevExpr.setRange([\n\t\t\t\t\t\t\t/** @type {Range} */ (prevExpr.range)[0],\n\t\t\t\t\t\t\t/** @type {Range} */ (quasiExpr.range)[1]\n\t\t\t\t\t\t]);\n\t\t\t\t\t\t// We unset the expression as it doesn't match to a single expression\n\t\t\t\t\t\tprevExpr.setExpression(undefined);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tparts.push(expr);\n\t\t\t\t}\n\n\t\t\t\tconst part = new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(/** @type {string} */ (quasi))\n\t\t\t\t\t.setRange(/** @type {Range} */ (quasiExpr.range))\n\t\t\t\t\t.setExpression(quasiExpr);\n\t\t\t\tquasis.push(part);\n\t\t\t\tparts.push(part);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tquasis,\n\t\t\t\tparts\n\t\t\t};\n\t\t};\n\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"TemplateLiteral\")\n\t\t\t.tap(\"JavascriptParser\", _node => {\n\t\t\t\tconst node = /** @type {TemplateLiteral} */ (_node);\n\n\t\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\"cooked\", node);\n\t\t\t\tif (parts.length === 1) {\n\t\t\t\t\treturn parts[0].setRange(/** @type {Range} */ (node.range));\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setTemplateString(quasis, parts, \"cooked\")\n\t\t\t\t\t.setRange(/** @type {Range} */ (node.range));\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"TaggedTemplateExpression\")\n\t\t\t.tap(\"JavascriptParser\", _node => {\n\t\t\t\tconst node = /** @type {TaggedTemplateExpression} */ (_node);\n\t\t\t\tconst tag = this.evaluateExpression(node.tag);\n\n\t\t\t\tif (tag.isIdentifier() && tag.identifier === \"String.raw\") {\n\t\t\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\n\t\t\t\t\t\t\"raw\",\n\t\t\t\t\t\tnode.quasi\n\t\t\t\t\t);\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setTemplateString(quasis, parts, \"raw\")\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (node.range));\n\t\t\t\t}\n\t\t\t});\n\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"concat\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString() && !param.isWrapped()) return;\n\t\t\t\tlet stringSuffix = null;\n\t\t\t\tlet hasUnknownParams = false;\n\t\t\t\tconst innerExpressions = [];\n\t\t\t\tfor (let i = expr.arguments.length - 1; i >= 0; i--) {\n\t\t\t\t\tconst arg = expr.arguments[i];\n\t\t\t\t\tif (arg.type === \"SpreadElement\") return;\n\t\t\t\t\tconst argExpr = this.evaluateExpression(arg);\n\t\t\t\t\tif (\n\t\t\t\t\t\thasUnknownParams ||\n\t\t\t\t\t\t(!argExpr.isString() && !argExpr.isNumber())\n\t\t\t\t\t) {\n\t\t\t\t\t\thasUnknownParams = true;\n\t\t\t\t\t\tinnerExpressions.push(argExpr);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t/** @type {string} */\n\t\t\t\t\tconst value = argExpr.isString()\n\t\t\t\t\t\t? /** @type {string} */ (argExpr.string)\n\t\t\t\t\t\t: String(/** @type {number} */ (argExpr.number));\n\n\t\t\t\t\t/** @type {string} */\n\t\t\t\t\tconst newString = value + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\tconst newRange = /** @type {Range} */ ([\n\t\t\t\t\t\t/** @type {Range} */ (argExpr.range)[0],\n\t\t\t\t\t\t/** @type {Range} */ ((stringSuffix || argExpr).range)[1]\n\t\t\t\t\t]);\n\t\t\t\t\tstringSuffix = new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t(stringSuffix && stringSuffix.couldHaveSideEffects()) ||\n\t\t\t\t\t\t\t\targExpr.couldHaveSideEffects()\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.setRange(newRange);\n\t\t\t\t}\n\n\t\t\t\tif (hasUnknownParams) {\n\t\t\t\t\tconst prefix = param.isString() ? param : param.prefix;\n\t\t\t\t\tconst inner =\n\t\t\t\t\t\tparam.isWrapped() && param.wrappedInnerExpressions\n\t\t\t\t\t\t\t? param.wrappedInnerExpressions.concat(innerExpressions.reverse())\n\t\t\t\t\t\t\t: innerExpressions.reverse();\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(prefix, stringSuffix, inner)\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t} else if (param.isWrapped()) {\n\t\t\t\t\tconst postfix = stringSuffix || param.postfix;\n\t\t\t\t\tconst inner = param.wrappedInnerExpressions\n\t\t\t\t\t\t? param.wrappedInnerExpressions.concat(innerExpressions.reverse())\n\t\t\t\t\t\t: innerExpressions.reverse();\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(param.prefix, postfix, inner)\n\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t}\n\t\t\t\tconst newString =\n\t\t\t\t\t/** @type {string} */ (param.string) +\n\t\t\t\t\t(stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(newString)\n\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t(stringSuffix && stringSuffix.couldHaveSideEffects()) ||\n\t\t\t\t\t\t\tparam.couldHaveSideEffects()\n\t\t\t\t\t)\n\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"split\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 1) return;\n\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\tlet result;\n\t\t\t\tconst arg = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tif (arg.isString()) {\n\t\t\t\t\tresult =\n\t\t\t\t\t\t/** @type {string} */\n\t\t\t\t\t\t(param.string).split(/** @type {string} */ (arg.string));\n\t\t\t\t} else if (arg.isRegExp()) {\n\t\t\t\t\tresult = /** @type {string} */ (param.string).split(\n\t\t\t\t\t\t/** @type {RegExp} */ (arg.regExp)\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setArray(result)\n\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"ConditionalExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {ConditionalExpression} */ (_expr);\n\n\t\t\t\tconst condition = this.evaluateExpression(expr.test);\n\t\t\t\tconst conditionValue = condition.asBool();\n\t\t\t\tlet res;\n\t\t\t\tif (conditionValue === undefined) {\n\t\t\t\t\tconst consequent = this.evaluateExpression(expr.consequent);\n\t\t\t\t\tconst alternate = this.evaluateExpression(expr.alternate);\n\t\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\t\tif (consequent.isConditional()) {\n\t\t\t\t\t\tres.setOptions(\n\t\t\t\t\t\t\t/** @type {BasicEvaluatedExpression[]} */ (consequent.options)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres.setOptions([consequent]);\n\t\t\t\t\t}\n\t\t\t\t\tif (alternate.isConditional()) {\n\t\t\t\t\t\tres.addOptions(\n\t\t\t\t\t\t\t/** @type {BasicEvaluatedExpression[]} */ (alternate.options)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres.addOptions([alternate]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tres = this.evaluateExpression(\n\t\t\t\t\t\tconditionValue ? expr.consequent : expr.alternate\n\t\t\t\t\t);\n\t\t\t\t\tif (condition.couldHaveSideEffects()) res.setSideEffects();\n\t\t\t\t}\n\t\t\t\tres.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\treturn res;\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"ArrayExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {ArrayExpression} */ (_expr);\n\n\t\t\t\tconst items = expr.elements.map(\n\t\t\t\t\telement =>\n\t\t\t\t\t\telement !== null &&\n\t\t\t\t\t\telement.type !== \"SpreadElement\" &&\n\t\t\t\t\t\tthis.evaluateExpression(element)\n\t\t\t\t);\n\t\t\t\tif (!items.every(Boolean)) return;\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setItems(/** @type {BasicEvaluatedExpression[]} */ (items))\n\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"ChainExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {ChainExpression} */ (_expr);\n\t\t\t\t/** @type {Expression[]} */\n\t\t\t\tconst optionalExpressionsStack = [];\n\t\t\t\t/** @type {Expression|Super} */\n\t\t\t\tlet next = expr.expression;\n\n\t\t\t\twhile (\n\t\t\t\t\tnext.type === \"MemberExpression\" ||\n\t\t\t\t\tnext.type === \"CallExpression\"\n\t\t\t\t) {\n\t\t\t\t\tif (next.type === \"MemberExpression\") {\n\t\t\t\t\t\tif (next.optional) {\n\t\t\t\t\t\t\t// SuperNode can not be optional\n\t\t\t\t\t\t\toptionalExpressionsStack.push(\n\t\t\t\t\t\t\t\t/** @type {Expression} */ (next.object)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext = next.object;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (next.optional) {\n\t\t\t\t\t\t\t// SuperNode can not be optional\n\t\t\t\t\t\t\toptionalExpressionsStack.push(\n\t\t\t\t\t\t\t\t/** @type {Expression} */ (next.callee)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext = next.callee;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (optionalExpressionsStack.length > 0) {\n\t\t\t\t\tconst expression =\n\t\t\t\t\t\t/** @type {Expression} */\n\t\t\t\t\t\t(optionalExpressionsStack.pop());\n\t\t\t\t\tconst evaluated = this.evaluateExpression(expression);\n\n\t\t\t\t\tif (evaluated.asNullish()) {\n\t\t\t\t\t\treturn evaluated.setRange(/** @type {Range} */ (_expr.range));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this.evaluateExpression(expr.expression);\n\t\t\t});\n\t}\n\n\t/**\n\t * @param {Expression} node node\n\t * @returns {Set<DestructuringAssignmentProperty> | undefined} destructured identifiers\n\t */\n\tdestructuringAssignmentPropertiesFor(node) {\n\t\tif (!this.destructuringAssignmentProperties) return;\n\t\treturn this.destructuringAssignmentProperties.get(node);\n\t}\n\n\t/**\n\t * @param {Expression | SpreadElement} expr expression\n\t * @returns {string | VariableInfoInterface | undefined} identifier\n\t */\n\tgetRenameIdentifier(expr) {\n\t\tconst result = this.evaluateExpression(expr);\n\t\tif (result.isIdentifier()) {\n\t\t\treturn result.identifier;\n\t\t}\n\t}\n\n\t/**\n\t * @param {ClassExpression | ClassDeclaration} classy a class node\n\t * @returns {void}\n\t */\n\twalkClass(classy) {\n\t\tif (\n\t\t\tclassy.superClass &&\n\t\t\t!this.hooks.classExtendsExpression.call(classy.superClass, classy)\n\t\t) {\n\t\t\tthis.walkExpression(classy.superClass);\n\t\t}\n\t\tif (classy.body && classy.body.type === \"ClassBody\") {\n\t\t\tconst scopeParams = [];\n\t\t\t// Add class name in scope for recursive calls\n\t\t\tif (classy.id) {\n\t\t\t\tscopeParams.push(classy.id);\n\t\t\t}\n\t\t\tthis.inClassScope(true, scopeParams, () => {\n\t\t\t\tfor (const classElement of /** @type {TODO} */ (classy.body.body)) {\n\t\t\t\t\tif (!this.hooks.classBodyElement.call(classElement, classy)) {\n\t\t\t\t\t\tif (classElement.computed && classElement.key) {\n\t\t\t\t\t\t\tthis.walkExpression(classElement.key);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (classElement.value) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!this.hooks.classBodyValue.call(\n\t\t\t\t\t\t\t\t\tclassElement.value,\n\t\t\t\t\t\t\t\t\tclassElement,\n\t\t\t\t\t\t\t\t\tclassy\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\t\t\t\t\t\t\tthis.scope.topLevelScope = false;\n\t\t\t\t\t\t\t\tthis.walkExpression(classElement.value);\n\t\t\t\t\t\t\t\tthis.scope.topLevelScope = wasTopLevel;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (classElement.type === \"StaticBlock\") {\n\t\t\t\t\t\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\t\t\t\t\t\tthis.scope.topLevelScope = false;\n\t\t\t\t\t\t\tthis.walkBlockStatement(classElement);\n\t\t\t\t\t\t\tthis.scope.topLevelScope = wasTopLevel;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Pre walking iterates the scope for variable declarations\n\t * @param {(Statement | ModuleDeclaration)[]} statements statements\n\t */\n\tpreWalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.preWalkStatement(statement);\n\t\t}\n\t}\n\n\t/**\n\t * Block pre walking iterates the scope for block variable declarations\n\t * @param {(Statement | ModuleDeclaration)[]} statements statements\n\t */\n\tblockPreWalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.blockPreWalkStatement(statement);\n\t\t}\n\t}\n\n\t/**\n\t * Walking iterates the statements and expressions and processes them\n\t * @param {(Statement | ModuleDeclaration)[]} statements statements\n\t */\n\twalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.walkStatement(statement);\n\t\t}\n\t}\n\n\t/**\n\t * Walking iterates the statements and expressions and processes them\n\t * @param {Statement | ModuleDeclaration} statement statement\n\t */\n\tpreWalkStatement(statement) {\n\t\t/** @type {StatementPath} */\n\t\t(this.statementPath).push(statement);\n\t\tif (this.hooks.preStatement.call(statement)) {\n\t\t\tthis.prevStatement =\n\t\t\t\t/** @type {StatementPath} */\n\t\t\t\t(this.statementPath).pop();\n\t\t\treturn;\n\t\t}\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.preWalkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.preWalkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.preWalkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.preWalkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.preWalkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.preWalkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.preWalkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.preWalkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.preWalkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.preWalkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.preWalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.preWalkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.preWalkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.prevStatement =\n\t\t\t/** @type {StatementPath} */\n\t\t\t(this.statementPath).pop();\n\t}\n\n\t/**\n\t * @param {Statement | ModuleDeclaration} statement statement\n\t */\n\tblockPreWalkStatement(statement) {\n\t\t/** @type {StatementPath} */\n\t\t(this.statementPath).push(statement);\n\t\tif (this.hooks.blockPreStatement.call(statement)) {\n\t\t\tthis.prevStatement =\n\t\t\t\t/** @type {StatementPath} */\n\t\t\t\t(this.statementPath).pop();\n\t\t\treturn;\n\t\t}\n\t\tswitch (statement.type) {\n\t\t\tcase \"ImportDeclaration\":\n\t\t\t\tthis.blockPreWalkImportDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportAllDeclaration\":\n\t\t\t\tthis.blockPreWalkExportAllDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.blockPreWalkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.blockPreWalkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.blockPreWalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.blockPreWalkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExpressionStatement\":\n\t\t\t\tthis.blockPreWalkExpressionStatement(statement);\n\t\t}\n\t\tthis.prevStatement =\n\t\t\t/** @type {StatementPath} */\n\t\t\t(this.statementPath).pop();\n\t}\n\n\t/**\n\t * @param {Statement | ModuleDeclaration} statement statement\n\t */\n\twalkStatement(statement) {\n\t\t/** @type {StatementPath} */\n\t\t(this.statementPath).push(statement);\n\t\tif (this.hooks.statement.call(statement) !== undefined) {\n\t\t\tthis.prevStatement =\n\t\t\t\t/** @type {StatementPath} */\n\t\t\t\t(this.statementPath).pop();\n\t\t\treturn;\n\t\t}\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.walkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.walkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.walkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.walkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.walkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExpressionStatement\":\n\t\t\t\tthis.walkExpressionStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.walkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.walkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.walkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.walkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.walkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.walkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ReturnStatement\":\n\t\t\t\tthis.walkReturnStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.walkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ThrowStatement\":\n\t\t\t\tthis.walkThrowStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.walkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.walkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.walkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.walkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.prevStatement =\n\t\t\t/** @type {StatementPath} */\n\t\t\t(this.statementPath).pop();\n\t}\n\n\t/**\n\t * Walks a statements that is nested within a parent statement\n\t * and can potentially be a non-block statement.\n\t * This enforces the nested statement to never be in ASI position.\n\t * @param {Statement} statement the nested statement\n\t */\n\twalkNestedStatement(statement) {\n\t\tthis.prevStatement = undefined;\n\t\tthis.walkStatement(statement);\n\t}\n\n\t// Real Statements\n\t/**\n\t * @param {BlockStatement} statement block statement\n\t */\n\tpreWalkBlockStatement(statement) {\n\t\tthis.preWalkStatements(statement.body);\n\t}\n\n\t/**\n\t * @param {BlockStatement} statement block statement\n\t */\n\twalkBlockStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tconst body = statement.body;\n\t\t\tconst prev = this.prevStatement;\n\t\t\tthis.blockPreWalkStatements(body);\n\t\t\tthis.prevStatement = prev;\n\t\t\tthis.walkStatements(body);\n\t\t});\n\t}\n\n\t/**\n\t * @param {ExpressionStatement} statement expression statement\n\t */\n\twalkExpressionStatement(statement) {\n\t\tthis.walkExpression(statement.expression);\n\t}\n\n\t/**\n\t * @param {IfStatement} statement if statement\n\t */\n\tpreWalkIfStatement(statement) {\n\t\tthis.preWalkStatement(statement.consequent);\n\t\tif (statement.alternate) {\n\t\t\tthis.preWalkStatement(statement.alternate);\n\t\t}\n\t}\n\n\t/**\n\t * @param {IfStatement} statement if statement\n\t */\n\twalkIfStatement(statement) {\n\t\tconst result = this.hooks.statementIf.call(statement);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(statement.test);\n\t\t\tthis.walkNestedStatement(statement.consequent);\n\t\t\tif (statement.alternate) {\n\t\t\t\tthis.walkNestedStatement(statement.alternate);\n\t\t\t}\n\t\t} else if (result) {\n\t\t\tthis.walkNestedStatement(statement.consequent);\n\t\t} else if (statement.alternate) {\n\t\t\tthis.walkNestedStatement(statement.alternate);\n\t\t}\n\t}\n\n\t/**\n\t * @param {LabeledStatement} statement with statement\n\t */\n\tpreWalkLabeledStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {LabeledStatement} statement with statement\n\t */\n\twalkLabeledStatement(statement) {\n\t\tconst hook = this.hooks.label.get(statement.label.name);\n\t\tif (hook !== undefined) {\n\t\t\tconst result = hook.call(statement);\n\t\t\tif (result === true) return;\n\t\t}\n\t\tthis.walkNestedStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {WithStatement} statement with statement\n\t */\n\tpreWalkWithStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {WithStatement} statement with statement\n\t */\n\twalkWithStatement(statement) {\n\t\tthis.walkExpression(statement.object);\n\t\tthis.walkNestedStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {SwitchStatement} statement switch statement\n\t */\n\tpreWalkSwitchStatement(statement) {\n\t\tthis.preWalkSwitchCases(statement.cases);\n\t}\n\n\t/**\n\t * @param {SwitchStatement} statement switch statement\n\t */\n\twalkSwitchStatement(statement) {\n\t\tthis.walkExpression(statement.discriminant);\n\t\tthis.walkSwitchCases(statement.cases);\n\t}\n\n\t/**\n\t * @param {ReturnStatement | ThrowStatement} statement return or throw statement\n\t */\n\twalkTerminatingStatement(statement) {\n\t\tif (statement.argument) this.walkExpression(statement.argument);\n\t}\n\n\t/**\n\t * @param {ReturnStatement} statement return statement\n\t */\n\twalkReturnStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\t/**\n\t * @param {ThrowStatement} statement return statement\n\t */\n\twalkThrowStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\t/**\n\t * @param {TryStatement} statement try statement\n\t */\n\tpreWalkTryStatement(statement) {\n\t\tthis.preWalkStatement(statement.block);\n\t\tif (statement.handler) this.preWalkCatchClause(statement.handler);\n\t\tif (statement.finalizer) this.preWalkStatement(statement.finalizer);\n\t}\n\n\t/**\n\t * @param {TryStatement} statement try statement\n\t */\n\twalkTryStatement(statement) {\n\t\tif (this.scope.inTry) {\n\t\t\tthis.walkStatement(statement.block);\n\t\t} else {\n\t\t\tthis.scope.inTry = true;\n\t\t\tthis.walkStatement(statement.block);\n\t\t\tthis.scope.inTry = false;\n\t\t}\n\t\tif (statement.handler) this.walkCatchClause(statement.handler);\n\t\tif (statement.finalizer) this.walkStatement(statement.finalizer);\n\t}\n\n\t/**\n\t * @param {WhileStatement} statement while statement\n\t */\n\tpreWalkWhileStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {WhileStatement} statement while statement\n\t */\n\twalkWhileStatement(statement) {\n\t\tthis.walkExpression(statement.test);\n\t\tthis.walkNestedStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {DoWhileStatement} statement do while statement\n\t */\n\tpreWalkDoWhileStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {DoWhileStatement} statement do while statement\n\t */\n\twalkDoWhileStatement(statement) {\n\t\tthis.walkNestedStatement(statement.body);\n\t\tthis.walkExpression(statement.test);\n\t}\n\n\t/**\n\t * @param {ForStatement} statement for statement\n\t */\n\tpreWalkForStatement(statement) {\n\t\tif (statement.init && statement.init.type === \"VariableDeclaration\") {\n\t\t\tthis.preWalkStatement(statement.init);\n\t\t}\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {ForStatement} statement for statement\n\t */\n\twalkForStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.init) {\n\t\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\t\tthis.blockPreWalkVariableDeclaration(statement.init);\n\t\t\t\t\tthis.prevStatement = undefined;\n\t\t\t\t\tthis.walkStatement(statement.init);\n\t\t\t\t} else {\n\t\t\t\t\tthis.walkExpression(statement.init);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (statement.test) {\n\t\t\t\tthis.walkExpression(statement.test);\n\t\t\t}\n\t\t\tif (statement.update) {\n\t\t\t\tthis.walkExpression(statement.update);\n\t\t\t}\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.blockPreWalkStatements(body.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkNestedStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {ForInStatement} statement for statement\n\t */\n\tpreWalkForInStatement(statement) {\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.preWalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {ForInStatement} statement for statement\n\t */\n\twalkForInStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPreWalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.blockPreWalkStatements(body.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkNestedStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {ForOfStatement} statement statement\n\t */\n\tpreWalkForOfStatement(statement) {\n\t\tif (statement.await && this.scope.topLevelScope === true) {\n\t\t\tthis.hooks.topLevelAwait.call(statement);\n\t\t}\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.preWalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\t/**\n\t * @param {ForOfStatement} statement for statement\n\t */\n\twalkForOfStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPreWalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.blockPreWalkStatements(body.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkNestedStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {FunctionDeclaration} statement function declaration\n\t */\n\tpreWalkFunctionDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.defineVariable(statement.id.name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {FunctionDeclaration} statement function declaration\n\t */\n\twalkFunctionDeclaration(statement) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tthis.inFunctionScope(true, statement.params, () => {\n\t\t\tfor (const param of statement.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (statement.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(statement.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(statement.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(statement.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\t/**\n\t * @param {ExpressionStatement} statement expression statement\n\t */\n\tblockPreWalkExpressionStatement(statement) {\n\t\tconst expression = statement.expression;\n\t\tswitch (expression.type) {\n\t\t\tcase \"AssignmentExpression\":\n\t\t\t\tthis.preWalkAssignmentExpression(expression);\n\t\t}\n\t}\n\n\t/**\n\t * @param {AssignmentExpression} expression assignment expression\n\t */\n\tpreWalkAssignmentExpression(expression) {\n\t\tif (\n\t\t\texpression.left.type !== \"ObjectPattern\" ||\n\t\t\t!this.destructuringAssignmentProperties\n\t\t)\n\t\t\treturn;\n\t\tconst keys = this._preWalkObjectPattern(expression.left);\n\t\tif (!keys) return;\n\n\t\t// check multiple assignments\n\t\tif (this.destructuringAssignmentProperties.has(expression)) {\n\t\t\tconst set =\n\t\t\t\t/** @type {Set<DestructuringAssignmentProperty>} */\n\t\t\t\t(this.destructuringAssignmentProperties.get(expression));\n\t\t\tthis.destructuringAssignmentProperties.delete(expression);\n\t\t\tfor (const id of set) keys.add(id);\n\t\t}\n\n\t\tthis.destructuringAssignmentProperties.set(\n\t\t\texpression.right.type === \"AwaitExpression\"\n\t\t\t\t? expression.right.argument\n\t\t\t\t: expression.right,\n\t\t\tkeys\n\t\t);\n\n\t\tif (expression.right.type === \"AssignmentExpression\") {\n\t\t\tthis.preWalkAssignmentExpression(expression.right);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ImportDeclaration} statement statement\n\t */\n\tblockPreWalkImportDeclaration(statement) {\n\t\tconst source = /** @type {ImportSource} */ (statement.source.value);\n\t\tthis.hooks.import.call(statement, source);\n\t\tfor (const specifier of statement.specifiers) {\n\t\t\tconst name = specifier.local.name;\n\t\t\tswitch (specifier.type) {\n\t\t\t\tcase \"ImportDefaultSpecifier\":\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.hooks.importSpecifier.call(statement, source, \"default\", name)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportSpecifier\":\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.hooks.importSpecifier.call(\n\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t/** @type {Identifier} */\n\t\t\t\t\t\t\t(specifier.imported).name ||\n\t\t\t\t\t\t\t\t/** @type {string} */\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t/** @type {Literal} */\n\t\t\t\t\t\t\t\t\t(specifier.imported).value\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportNamespaceSpecifier\":\n\t\t\t\t\tif (!this.hooks.importSpecifier.call(statement, source, null, name)) {\n\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.defineVariable(name);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Declaration} declaration declaration\n\t * @param {OnIdent} onIdent on ident callback\n\t */\n\tenterDeclaration(declaration, onIdent) {\n\t\tswitch (declaration.type) {\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tfor (const declarator of declaration.declarations) {\n\t\t\t\t\tswitch (declarator.type) {\n\t\t\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\t\t\tthis.enterPattern(declarator.id, onIdent);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @param {ExportNamedDeclaration} statement statement\n\t */\n\tblockPreWalkExportNamedDeclaration(statement) {\n\t\tlet source;\n\t\tif (statement.source) {\n\t\t\tsource = /** @type {ImportSource} */ (statement.source.value);\n\t\t\tthis.hooks.exportImport.call(statement, source);\n\t\t} else {\n\t\t\tthis.hooks.export.call(statement);\n\t\t}\n\t\tif (\n\t\t\tstatement.declaration &&\n\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t) {\n\t\t\tconst prev = this.prevStatement;\n\t\t\tthis.preWalkStatement(statement.declaration);\n\t\t\tthis.prevStatement = prev;\n\t\t\tthis.blockPreWalkStatement(statement.declaration);\n\t\t\tlet index = 0;\n\t\t\tthis.enterDeclaration(statement.declaration, def => {\n\t\t\t\tthis.hooks.exportSpecifier.call(statement, def, def, index++);\n\t\t\t});\n\t\t}\n\t\tif (statement.specifiers) {\n\t\t\tfor (\n\t\t\t\tlet specifierIndex = 0;\n\t\t\t\tspecifierIndex < statement.specifiers.length;\n\t\t\t\tspecifierIndex++\n\t\t\t) {\n\t\t\t\tconst specifier = statement.specifiers[specifierIndex];\n\t\t\t\tswitch (specifier.type) {\n\t\t\t\t\tcase \"ExportSpecifier\": {\n\t\t\t\t\t\tconst localName =\n\t\t\t\t\t\t\t/** @type {Identifier} */ (specifier.local).name ||\n\t\t\t\t\t\t\t/** @type {string} */ (\n\t\t\t\t\t\t\t\t/** @type {Literal} */ (specifier.local).value\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tconst name =\n\t\t\t\t\t\t\t/** @type {Identifier} */\n\t\t\t\t\t\t\t(specifier.exported).name ||\n\t\t\t\t\t\t\t/** @type {string} */\n\t\t\t\t\t\t\t(/** @type {Literal} */ (specifier.exported).value);\n\t\t\t\t\t\tif (source) {\n\t\t\t\t\t\t\tthis.hooks.exportImportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\tlocalName,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tlocalName,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {ExportNamedDeclaration} statement the statement\n\t */\n\twalkExportNamedDeclaration(statement) {\n\t\tif (statement.declaration) {\n\t\t\tthis.walkStatement(statement.declaration);\n\t\t}\n\t}\n\n\t/**\n\t * @param {TODO} statement statement\n\t */\n\tblockPreWalkExportDefaultDeclaration(statement) {\n\t\tconst prev = this.prevStatement;\n\t\tthis.preWalkStatement(statement.declaration);\n\t\tthis.prevStatement = prev;\n\t\tthis.blockPreWalkStatement(statement.declaration);\n\t\tif (\n\t\t\t/** @type {FunctionDeclaration | ClassDeclaration} */ (\n\t\t\t\tstatement.declaration\n\t\t\t).id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tconst declaration =\n\t\t\t\t/** @type {FunctionDeclaration | ClassDeclaration} */\n\t\t\t\t(statement.declaration);\n\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\tstatement,\n\t\t\t\tdeclaration.id.name,\n\t\t\t\t\"default\",\n\t\t\t\tundefined\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ExportDefaultDeclaration} statement statement\n\t */\n\twalkExportDefaultDeclaration(statement) {\n\t\tthis.hooks.export.call(statement);\n\t\tif (\n\t\t\t/** @type {FunctionDeclaration | ClassDeclaration} */ (\n\t\t\t\tstatement.declaration\n\t\t\t).id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tconst declaration =\n\t\t\t\t/** @type {FunctionDeclaration | ClassDeclaration} */\n\t\t\t\t(statement.declaration);\n\t\t\tif (!this.hooks.exportDeclaration.call(statement, declaration)) {\n\t\t\t\tthis.walkStatement(declaration);\n\t\t\t}\n\t\t} else {\n\t\t\t// Acorn parses `export default function() {}` as `FunctionDeclaration` and\n\t\t\t// `export default class {}` as `ClassDeclaration`, both with `id = null`.\n\t\t\t// These nodes must be treated as expressions.\n\t\t\tif (\n\t\t\t\tstatement.declaration.type === \"FunctionDeclaration\" ||\n\t\t\t\tstatement.declaration.type === \"ClassDeclaration\"\n\t\t\t) {\n\t\t\t\tthis.walkStatement(\n\t\t\t\t\t/** @type {FunctionDeclaration | ClassDeclaration} */\n\t\t\t\t\t(statement.declaration)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.declaration);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t!this.hooks.exportExpression.call(\n\t\t\t\t\tstatement,\n\t\t\t\t\t/** @type {TODO} */ (statement).declaration\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\tstatement,\n\t\t\t\t\t/** @type {TODO} */ (statement.declaration),\n\t\t\t\t\t\"default\",\n\t\t\t\t\tundefined\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {ExportAllDeclaration} statement statement\n\t */\n\tblockPreWalkExportAllDeclaration(statement) {\n\t\tconst source = /** @type {ImportSource} */ (statement.source.value);\n\t\tconst name = statement.exported\n\t\t\t? /** @type {Identifier} */\n\t\t\t\t(statement.exported).name ||\n\t\t\t\t/** @type {string} */\n\t\t\t\t(/** @type {Literal} */ (statement.exported).value)\n\t\t\t: null;\n\t\tthis.hooks.exportImport.call(statement, source);\n\t\tthis.hooks.exportImportSpecifier.call(statement, source, null, name, 0);\n\t}\n\n\t/**\n\t * @param {VariableDeclaration} statement variable declaration\n\t */\n\tpreWalkVariableDeclaration(statement) {\n\t\tif (statement.kind !== \"var\") return;\n\t\tthis._preWalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n\t}\n\n\t/**\n\t * @param {VariableDeclaration} statement variable declaration\n\t */\n\tblockPreWalkVariableDeclaration(statement) {\n\t\tif (statement.kind === \"var\") return;\n\t\tconst hookMap =\n\t\t\tstatement.kind === \"const\"\n\t\t\t\t? this.hooks.varDeclarationConst\n\t\t\t\t: this.hooks.varDeclarationLet;\n\t\tthis._preWalkVariableDeclaration(statement, hookMap);\n\t}\n\n\t/**\n\t * @param {VariableDeclaration} statement variable declaration\n\t * @param {TODO} hookMap map of hooks\n\t */\n\t_preWalkVariableDeclaration(statement, hookMap) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tthis.preWalkVariableDeclarator(declarator);\n\t\t\t\t\tif (!this.hooks.preDeclarator.call(declarator, statement)) {\n\t\t\t\t\t\tthis.enterPattern(declarator.id, (name, decl) => {\n\t\t\t\t\t\t\tlet hook = hookMap.get(name);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\t\thook = this.hooks.varDeclaration.get(name);\n\t\t\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {ObjectPattern} objectPattern object pattern\n\t * @returns {Set<DestructuringAssignmentProperty> | undefined} set of names or undefined if not all keys are identifiers\n\t */\n\t_preWalkObjectPattern(objectPattern) {\n\t\t/** @type {Set<DestructuringAssignmentProperty>} */\n\t\tconst props = new Set();\n\t\tconst properties = objectPattern.properties;\n\t\tfor (let i = 0; i < properties.length; i++) {\n\t\t\tconst property = properties[i];\n\t\t\tif (property.type !== \"Property\") return;\n\t\t\tif (property.shorthand && property.value.type === \"Identifier\") {\n\t\t\t\tthis.scope.inShorthand = property.value.name;\n\t\t\t}\n\t\t\tconst key = property.key;\n\t\t\tif (key.type === \"Identifier\") {\n\t\t\t\tprops.add({\n\t\t\t\t\tid: key.name,\n\t\t\t\t\trange: key.range,\n\t\t\t\t\tshorthand: this.scope.inShorthand\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst id = this.evaluateExpression(key);\n\t\t\t\tconst str = id.asString();\n\t\t\t\tif (str) {\n\t\t\t\t\tprops.add({\n\t\t\t\t\t\tid: str,\n\t\t\t\t\t\trange: key.range,\n\t\t\t\t\t\tshorthand: this.scope.inShorthand\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// could not evaluate key\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.scope.inShorthand = false;\n\t\t}\n\n\t\treturn props;\n\t}\n\n\t/**\n\t * @param {VariableDeclarator} declarator variable declarator\n\t */\n\tpreWalkVariableDeclarator(declarator) {\n\t\tif (\n\t\t\t!declarator.init ||\n\t\t\tdeclarator.id.type !== \"ObjectPattern\" ||\n\t\t\t!this.destructuringAssignmentProperties\n\t\t)\n\t\t\treturn;\n\t\tconst keys = this._preWalkObjectPattern(declarator.id);\n\n\t\tif (!keys) return;\n\t\tthis.destructuringAssignmentProperties.set(\n\t\t\tdeclarator.init.type === \"AwaitExpression\"\n\t\t\t\t? declarator.init.argument\n\t\t\t\t: declarator.init,\n\t\t\tkeys\n\t\t);\n\n\t\tif (declarator.init.type === \"AssignmentExpression\") {\n\t\t\tthis.preWalkAssignmentExpression(declarator.init);\n\t\t}\n\t}\n\n\t/**\n\t * @param {VariableDeclaration} statement variable declaration\n\t */\n\twalkVariableDeclaration(statement) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tconst renameIdentifier =\n\t\t\t\t\t\tdeclarator.init && this.getRenameIdentifier(declarator.init);\n\t\t\t\t\tif (renameIdentifier && declarator.id.type === \"Identifier\") {\n\t\t\t\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\thook !== undefined &&\n\t\t\t\t\t\t\thook.call(/** @type {Expression} */ (declarator.init))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// renaming with \"var a = b;\"\n\t\t\t\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\thook === undefined ||\n\t\t\t\t\t\t\t\t!hook.call(/** @type {Expression} */ (declarator.init))\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tthis.setVariable(declarator.id.name, renameIdentifier);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!this.hooks.declarator.call(declarator, statement)) {\n\t\t\t\t\t\tthis.walkPattern(declarator.id);\n\t\t\t\t\t\tif (declarator.init) this.walkExpression(declarator.init);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {ClassDeclaration} statement class declaration\n\t */\n\tblockPreWalkClassDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.defineVariable(statement.id.name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ClassDeclaration} statement class declaration\n\t */\n\twalkClassDeclaration(statement) {\n\t\tthis.walkClass(statement);\n\t}\n\n\t/**\n\t * @param {SwitchCase[]} switchCases switch statement\n\t */\n\tpreWalkSwitchCases(switchCases) {\n\t\tfor (let index = 0, len = switchCases.length; index < len; index++) {\n\t\t\tconst switchCase = switchCases[index];\n\t\t\tthis.preWalkStatements(switchCase.consequent);\n\t\t}\n\t}\n\n\t/**\n\t * @param {SwitchCase[]} switchCases switch statement\n\t */\n\twalkSwitchCases(switchCases) {\n\t\tthis.inBlockScope(() => {\n\t\t\tconst len = switchCases.length;\n\n\t\t\t// we need to pre walk all statements first since we can have invalid code\n\t\t\t// import A from \"module\";\n\t\t\t// switch(1) {\n\t\t\t//    case 1:\n\t\t\t//      console.log(A); // should fail at runtime\n\t\t\t//    case 2:\n\t\t\t//      const A = 1;\n\t\t\t// }\n\t\t\tfor (let index = 0; index < len; index++) {\n\t\t\t\tconst switchCase = switchCases[index];\n\n\t\t\t\tif (switchCase.consequent.length > 0) {\n\t\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\t\tthis.blockPreWalkStatements(switchCase.consequent);\n\t\t\t\t\tthis.prevStatement = prev;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let index = 0; index < len; index++) {\n\t\t\t\tconst switchCase = switchCases[index];\n\n\t\t\t\tif (switchCase.test) {\n\t\t\t\t\tthis.walkExpression(switchCase.test);\n\t\t\t\t}\n\t\t\t\tif (switchCase.consequent.length > 0) {\n\t\t\t\t\tthis.walkStatements(switchCase.consequent);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {CatchClause} catchClause catch clause\n\t */\n\tpreWalkCatchClause(catchClause) {\n\t\tthis.preWalkStatement(catchClause.body);\n\t}\n\n\t/**\n\t * @param {CatchClause} catchClause catch clause\n\t */\n\twalkCatchClause(catchClause) {\n\t\tthis.inBlockScope(() => {\n\t\t\t// Error binding is optional in catch clause since ECMAScript 2019\n\t\t\tif (catchClause.param !== null) {\n\t\t\t\tthis.enterPattern(catchClause.param, ident => {\n\t\t\t\t\tthis.defineVariable(ident);\n\t\t\t\t});\n\t\t\t\tthis.walkPattern(catchClause.param);\n\t\t\t}\n\t\t\tconst prev = this.prevStatement;\n\t\t\tthis.blockPreWalkStatement(catchClause.body);\n\t\t\tthis.prevStatement = prev;\n\t\t\tthis.walkStatement(catchClause.body);\n\t\t});\n\t}\n\n\t/**\n\t * @param {Pattern} pattern pattern\n\t */\n\twalkPattern(pattern) {\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.walkArrayPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.walkAssignmentPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.walkObjectPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.walkRestElement(pattern);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @param {AssignmentPattern} pattern assignment pattern\n\t */\n\twalkAssignmentPattern(pattern) {\n\t\tthis.walkExpression(pattern.right);\n\t\tthis.walkPattern(pattern.left);\n\t}\n\n\t/**\n\t * @param {ObjectPattern} pattern pattern\n\t */\n\twalkObjectPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.properties.length; i < len; i++) {\n\t\t\tconst prop = pattern.properties[i];\n\t\t\tif (prop) {\n\t\t\t\tif (prop.type === \"RestElement\") {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (prop.computed) this.walkExpression(prop.key);\n\t\t\t\tif (prop.value) this.walkPattern(prop.value);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {ArrayPattern} pattern array pattern\n\t */\n\twalkArrayPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.elements.length; i < len; i++) {\n\t\t\tconst element = pattern.elements[i];\n\t\t\tif (element) this.walkPattern(element);\n\t\t}\n\t}\n\n\t/**\n\t * @param {RestElement} pattern rest element\n\t */\n\twalkRestElement(pattern) {\n\t\tthis.walkPattern(pattern.argument);\n\t}\n\n\t/**\n\t * @param {(Expression | SpreadElement | null)[]} expressions expressions\n\t */\n\twalkExpressions(expressions) {\n\t\tfor (const expression of expressions) {\n\t\t\tif (expression) {\n\t\t\t\tthis.walkExpression(expression);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {TODO} expression expression\n\t */\n\twalkExpression(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"ArrayExpression\":\n\t\t\t\tthis.walkArrayExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ArrowFunctionExpression\":\n\t\t\t\tthis.walkArrowFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentExpression\":\n\t\t\t\tthis.walkAssignmentExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AwaitExpression\":\n\t\t\t\tthis.walkAwaitExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tthis.walkBinaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"CallExpression\":\n\t\t\t\tthis.walkCallExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ChainExpression\":\n\t\t\t\tthis.walkChainExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassExpression\":\n\t\t\t\tthis.walkClassExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\":\n\t\t\t\tthis.walkConditionalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionExpression\":\n\t\t\t\tthis.walkFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.walkIdentifier(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ImportExpression\":\n\t\t\t\tthis.walkImportExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"LogicalExpression\":\n\t\t\t\tthis.walkLogicalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"MetaProperty\":\n\t\t\t\tthis.walkMetaProperty(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"NewExpression\":\n\t\t\t\tthis.walkNewExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectExpression\":\n\t\t\t\tthis.walkObjectExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SequenceExpression\":\n\t\t\t\tthis.walkSequenceExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SpreadElement\":\n\t\t\t\tthis.walkSpreadElement(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TaggedTemplateExpression\":\n\t\t\t\tthis.walkTaggedTemplateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TemplateLiteral\":\n\t\t\t\tthis.walkTemplateLiteral(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ThisExpression\":\n\t\t\t\tthis.walkThisExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UnaryExpression\":\n\t\t\t\tthis.walkUnaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UpdateExpression\":\n\t\t\t\tthis.walkUpdateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"YieldExpression\":\n\t\t\t\tthis.walkYieldExpression(expression);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @param {AwaitExpression} expression await expression\n\t */\n\twalkAwaitExpression(expression) {\n\t\tif (this.scope.topLevelScope === true)\n\t\t\tthis.hooks.topLevelAwait.call(expression);\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\t/**\n\t * @param {ArrayExpression} expression array expression\n\t */\n\twalkArrayExpression(expression) {\n\t\tif (expression.elements) {\n\t\t\tthis.walkExpressions(expression.elements);\n\t\t}\n\t}\n\n\t/**\n\t * @param {SpreadElement} expression spread element\n\t */\n\twalkSpreadElement(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ObjectExpression} expression object expression\n\t */\n\twalkObjectExpression(expression) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = expression.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = expression.properties[propIndex];\n\t\t\tthis.walkProperty(prop);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Property | SpreadElement} prop property or spread element\n\t */\n\twalkProperty(prop) {\n\t\tif (prop.type === \"SpreadElement\") {\n\t\t\tthis.walkExpression(prop.argument);\n\t\t\treturn;\n\t\t}\n\t\tif (prop.computed) {\n\t\t\tthis.walkExpression(prop.key);\n\t\t}\n\t\tif (prop.shorthand && prop.value && prop.value.type === \"Identifier\") {\n\t\t\tthis.scope.inShorthand = prop.value.name;\n\t\t\tthis.walkIdentifier(prop.value);\n\t\t\tthis.scope.inShorthand = false;\n\t\t} else {\n\t\t\tthis.walkExpression(prop.value);\n\t\t}\n\t}\n\n\t/**\n\t * @param {FunctionExpression} expression arrow function expression\n\t */\n\twalkFunctionExpression(expression) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tconst scopeParams = [...expression.params];\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (expression.id) {\n\t\t\tscopeParams.push(expression.id);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(expression.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\t/**\n\t * @param {ArrowFunctionExpression} expression arrow function expression\n\t */\n\twalkArrowFunctionExpression(expression) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = wasTopLevel ? \"arrow\" : false;\n\t\tthis.inFunctionScope(false, expression.params, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(expression.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\t/**\n\t * @param {SequenceExpression} expression the sequence\n\t */\n\twalkSequenceExpression(expression) {\n\t\tif (!expression.expressions) return;\n\t\t// We treat sequence expressions like statements when they are one statement level\n\t\t// This has some benefits for optimizations that only work on statement level\n\t\tconst currentStatement =\n\t\t\t/** @type {StatementPath} */\n\t\t\t(this.statementPath)[\n\t\t\t\t/** @type {StatementPath} */\n\t\t\t\t(this.statementPath).length - 1\n\t\t\t];\n\t\tif (\n\t\t\tcurrentStatement === expression ||\n\t\t\t(currentStatement.type === \"ExpressionStatement\" &&\n\t\t\t\tcurrentStatement.expression === expression)\n\t\t) {\n\t\t\tconst old =\n\t\t\t\t/** @type {StatementPathItem} */\n\t\t\t\t(/** @type {StatementPath} */ (this.statementPath).pop());\n\t\t\tconst prev = this.prevStatement;\n\t\t\tfor (const expr of expression.expressions) {\n\t\t\t\t/** @type {StatementPath} */\n\t\t\t\t(this.statementPath).push(expr);\n\t\t\t\tthis.walkExpression(expr);\n\t\t\t\tthis.prevStatement =\n\t\t\t\t\t/** @type {StatementPath} */\n\t\t\t\t\t(this.statementPath).pop();\n\t\t\t}\n\t\t\tthis.prevStatement = prev;\n\t\t\t/** @type {StatementPath} */\n\t\t\t(this.statementPath).push(old);\n\t\t} else {\n\t\t\tthis.walkExpressions(expression.expressions);\n\t\t}\n\t}\n\n\t/**\n\t * @param {UpdateExpression} expression the update expression\n\t */\n\twalkUpdateExpression(expression) {\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\t/**\n\t * @param {UnaryExpression} expression the unary expression\n\t */\n\twalkUnaryExpression(expression) {\n\t\tif (expression.operator === \"typeof\") {\n\t\t\tconst result = this.callHooksForExpression(\n\t\t\t\tthis.hooks.typeof,\n\t\t\t\texpression.argument,\n\t\t\t\texpression\n\t\t\t);\n\t\t\tif (result === true) return;\n\t\t\tif (expression.argument.type === \"ChainExpression\") {\n\t\t\t\tconst result = this.callHooksForExpression(\n\t\t\t\t\tthis.hooks.typeof,\n\t\t\t\t\texpression.argument.expression,\n\t\t\t\t\texpression\n\t\t\t\t);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\t/**\n\t * @param {LogicalExpression | BinaryExpression} expression the expression\n\t */\n\twalkLeftRightExpression(expression) {\n\t\tthis.walkExpression(expression.left);\n\t\tthis.walkExpression(expression.right);\n\t}\n\n\t/**\n\t * @param {BinaryExpression} expression the binary expression\n\t */\n\twalkBinaryExpression(expression) {\n\t\tif (this.hooks.binaryExpression.call(expression) === undefined) {\n\t\t\tthis.walkLeftRightExpression(expression);\n\t\t}\n\t}\n\n\t/**\n\t * @param {LogicalExpression} expression the logical expression\n\t */\n\twalkLogicalExpression(expression) {\n\t\tconst result = this.hooks.expressionLogicalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkLeftRightExpression(expression);\n\t\t} else if (result) {\n\t\t\tthis.walkExpression(expression.right);\n\t\t}\n\t}\n\n\t/**\n\t * @param {AssignmentExpression} expression assignment expression\n\t */\n\twalkAssignmentExpression(expression) {\n\t\tif (expression.left.type === \"Identifier\") {\n\t\t\tconst renameIdentifier = this.getRenameIdentifier(expression.right);\n\t\t\tif (\n\t\t\t\trenameIdentifier &&\n\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\tthis.hooks.canRename,\n\t\t\t\t\trenameIdentifier,\n\t\t\t\t\texpression.right\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// renaming \"a = b;\"\n\t\t\t\tif (\n\t\t\t\t\t!this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.rename,\n\t\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t\texpression.right\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tthis.setVariable(\n\t\t\t\t\t\texpression.left.name,\n\t\t\t\t\t\ttypeof renameIdentifier === \"string\"\n\t\t\t\t\t\t\t? this.getVariableInfo(renameIdentifier)\n\t\t\t\t\t\t\t: renameIdentifier\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.enterPattern(expression.left, (name, decl) => {\n\t\t\t\tif (!this.callHooksForName(this.hooks.assign, name, expression)) {\n\t\t\t\t\tthis.walkExpression(expression.left);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tif (expression.left.type.endsWith(\"Pattern\")) {\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.enterPattern(expression.left, (name, decl) => {\n\t\t\t\tif (!this.callHooksForName(this.hooks.assign, name, expression)) {\n\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.walkPattern(expression.left);\n\t\t} else if (expression.left.type === \"MemberExpression\") {\n\t\t\tconst exprName = this.getMemberExpressionInfo(\n\t\t\t\texpression.left,\n\t\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t\t);\n\t\t\tif (\n\t\t\t\texprName &&\n\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\tthis.hooks.assignMemberChain,\n\t\t\t\t\texprName.rootInfo,\n\t\t\t\t\texpression,\n\t\t\t\t\texprName.getMembers()\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.walkExpression(expression.left);\n\t\t} else {\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.walkExpression(expression.left);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ConditionalExpression} expression conditional expression\n\t */\n\twalkConditionalExpression(expression) {\n\t\tconst result = this.hooks.expressionConditionalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(expression.test);\n\t\t\tthis.walkExpression(expression.consequent);\n\t\t\tif (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t} else if (result) {\n\t\t\tthis.walkExpression(expression.consequent);\n\t\t} else if (expression.alternate) {\n\t\t\tthis.walkExpression(expression.alternate);\n\t\t}\n\t}\n\n\t/**\n\t * @param {NewExpression} expression new expression\n\t */\n\twalkNewExpression(expression) {\n\t\tconst result = this.callHooksForExpression(\n\t\t\tthis.hooks.new,\n\t\t\texpression.callee,\n\t\t\texpression\n\t\t);\n\t\tif (result === true) return;\n\t\tthis.walkExpression(expression.callee);\n\t\tif (expression.arguments) {\n\t\t\tthis.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\t/**\n\t * @param {YieldExpression} expression yield expression\n\t */\n\twalkYieldExpression(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\t/**\n\t * @param {TemplateLiteral} expression template literal\n\t */\n\twalkTemplateLiteral(expression) {\n\t\tif (expression.expressions) {\n\t\t\tthis.walkExpressions(expression.expressions);\n\t\t}\n\t}\n\n\t/**\n\t * @param {TaggedTemplateExpression} expression tagged template expression\n\t */\n\twalkTaggedTemplateExpression(expression) {\n\t\tif (expression.tag) {\n\t\t\tthis.scope.inTaggedTemplateTag = true;\n\t\t\tthis.walkExpression(expression.tag);\n\t\t\tthis.scope.inTaggedTemplateTag = false;\n\t\t}\n\t\tif (expression.quasi && expression.quasi.expressions) {\n\t\t\tthis.walkExpressions(expression.quasi.expressions);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ClassExpression} expression the class expression\n\t */\n\twalkClassExpression(expression) {\n\t\tthis.walkClass(expression);\n\t}\n\n\t/**\n\t * @param {ChainExpression} expression expression\n\t */\n\twalkChainExpression(expression) {\n\t\tconst result = this.hooks.optionalChaining.call(expression);\n\n\t\tif (result === undefined) {\n\t\t\tif (expression.expression.type === \"CallExpression\") {\n\t\t\t\tthis.walkCallExpression(expression.expression);\n\t\t\t} else {\n\t\t\t\tthis.walkMemberExpression(expression.expression);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @param {FunctionExpression | ArrowFunctionExpression} functionExpression function expression\n\t * @param {(Expression | SpreadElement)[]} options options\n\t * @param {Expression | SpreadElement | null} currentThis current this\n\t */\n\t_walkIIFE(functionExpression, options, currentThis) {\n\t\t/**\n\t\t * @param {Expression | SpreadElement} argOrThis arg or this\n\t\t * @returns {string | VariableInfoInterface | undefined} var info\n\t\t */\n\t\tconst getVarInfo = argOrThis => {\n\t\t\tconst renameIdentifier = this.getRenameIdentifier(argOrThis);\n\t\t\tif (\n\t\t\t\trenameIdentifier &&\n\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\tthis.hooks.canRename,\n\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t/** @type {Expression} */\n\t\t\t\t\t(argOrThis)\n\t\t\t\t) &&\n\t\t\t\t!this.callHooksForInfo(\n\t\t\t\t\tthis.hooks.rename,\n\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t/** @type {Expression} */\n\t\t\t\t\t(argOrThis)\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn typeof renameIdentifier === \"string\"\n\t\t\t\t\t? /** @type {string} */ (this.getVariableInfo(renameIdentifier))\n\t\t\t\t\t: renameIdentifier;\n\t\t\t}\n\t\t\tthis.walkExpression(argOrThis);\n\t\t};\n\t\tconst { params, type } = functionExpression;\n\t\tconst arrow = type === \"ArrowFunctionExpression\";\n\t\tconst renameThis = currentThis ? getVarInfo(currentThis) : null;\n\t\tconst varInfoForArgs = options.map(getVarInfo);\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = wasTopLevel && arrow ? \"arrow\" : false;\n\t\tconst scopeParams =\n\t\t\t/** @type {(Identifier | string)[]} */\n\t\t\t(params.filter((identifier, idx) => !varInfoForArgs[idx]));\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (\n\t\t\tfunctionExpression.type === \"FunctionExpression\" &&\n\t\t\tfunctionExpression.id\n\t\t) {\n\t\t\tscopeParams.push(functionExpression.id.name);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tif (renameThis && !arrow) {\n\t\t\t\tthis.setVariable(\"this\", renameThis);\n\t\t\t}\n\t\t\tfor (let i = 0; i < varInfoForArgs.length; i++) {\n\t\t\t\tconst varInfo = varInfoForArgs[i];\n\t\t\t\tif (!varInfo) continue;\n\t\t\t\tif (!params[i] || params[i].type !== \"Identifier\") continue;\n\t\t\t\tthis.setVariable(/** @type {Identifier} */ (params[i]).name, varInfo);\n\t\t\t}\n\t\t\tif (functionExpression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(functionExpression.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(functionExpression.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(functionExpression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(functionExpression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\t/**\n\t * @param {ImportExpression} expression import expression\n\t */\n\twalkImportExpression(expression) {\n\t\tconst result = this.hooks.importCall.call(expression);\n\t\tif (result === true) return;\n\n\t\tthis.walkExpression(expression.source);\n\t}\n\n\t/**\n\t * @param {CallExpression} expression expression\n\t */\n\twalkCallExpression(expression) {\n\t\t/**\n\t\t * @param {FunctionExpression | ArrowFunctionExpression} fn function\n\t\t * @returns {boolean} true when simple function\n\t\t */\n\t\tconst isSimpleFunction = fn =>\n\t\t\tfn.params.every(p => p.type === \"Identifier\");\n\t\tif (\n\t\t\texpression.callee.type === \"MemberExpression\" &&\n\t\t\texpression.callee.object.type.endsWith(\"FunctionExpression\") &&\n\t\t\t!expression.callee.computed &&\n\t\t\t// eslint-disable-next-line no-warning-comments\n\t\t\t// @ts-ignore\n\t\t\t// TODO check me and handle more cases\n\t\t\t(expression.callee.property.name === \"call\" ||\n\t\t\t\t// eslint-disable-next-line no-warning-comments\n\t\t\t\t// @ts-ignore\n\t\t\t\texpression.callee.property.name === \"bind\") &&\n\t\t\texpression.arguments.length > 0 &&\n\t\t\tisSimpleFunction(\n\t\t\t\t/** @type {FunctionExpression | ArrowFunctionExpression} */\n\t\t\t\t(expression.callee.object)\n\t\t\t)\n\t\t) {\n\t\t\t// (function(…) { }.call/bind(?, …))\n\t\t\tthis._walkIIFE(\n\t\t\t\t/** @type {FunctionExpression | ArrowFunctionExpression} */\n\t\t\t\t(expression.callee.object),\n\t\t\t\texpression.arguments.slice(1),\n\t\t\t\texpression.arguments[0]\n\t\t\t);\n\t\t} else if (\n\t\t\texpression.callee.type.endsWith(\"FunctionExpression\") &&\n\t\t\tisSimpleFunction(\n\t\t\t\t/** @type {FunctionExpression | ArrowFunctionExpression} */\n\t\t\t\t(expression.callee)\n\t\t\t)\n\t\t) {\n\t\t\t// (function(…) { }(…))\n\t\t\tthis._walkIIFE(\n\t\t\t\t/** @type {FunctionExpression | ArrowFunctionExpression} */\n\t\t\t\t(expression.callee),\n\t\t\t\texpression.arguments,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else {\n\t\t\tif (expression.callee.type === \"MemberExpression\") {\n\t\t\t\tconst exprInfo = this.getMemberExpressionInfo(\n\t\t\t\t\texpression.callee,\n\t\t\t\t\tALLOWED_MEMBER_TYPES_CALL_EXPRESSION\n\t\t\t\t);\n\t\t\t\tif (exprInfo && exprInfo.type === \"call\") {\n\t\t\t\t\tconst result = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.callMemberChainOfCallMemberChain,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprInfo.getCalleeMembers(),\n\t\t\t\t\t\texprInfo.call,\n\t\t\t\t\t\texprInfo.getMembers(),\n\t\t\t\t\t\texprInfo.getMemberRanges()\n\t\t\t\t\t);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst callee = this.evaluateExpression(\n\t\t\t\t/** @type {TODO} */ (expression.callee)\n\t\t\t);\n\t\t\tif (callee.isIdentifier()) {\n\t\t\t\tconst result1 = this.callHooksForInfo(\n\t\t\t\t\tthis.hooks.callMemberChain,\n\t\t\t\t\t/** @type {NonNullable<BasicEvaluatedExpression[\"rootInfo\"]>} */\n\t\t\t\t\t(callee.rootInfo),\n\t\t\t\t\texpression,\n\t\t\t\t\t/** @type {NonNullable<BasicEvaluatedExpression[\"getMembers\"]>} */\n\t\t\t\t\t(callee.getMembers)(),\n\t\t\t\t\tcallee.getMembersOptionals\n\t\t\t\t\t\t? callee.getMembersOptionals()\n\t\t\t\t\t\t: /** @type {NonNullable<BasicEvaluatedExpression[\"getMembers\"]>} */\n\t\t\t\t\t\t\t(callee.getMembers)().map(() => false),\n\t\t\t\t\tcallee.getMemberRanges ? callee.getMemberRanges() : []\n\t\t\t\t);\n\t\t\t\tif (result1 === true) return;\n\t\t\t\tconst result2 = this.callHooksForInfo(\n\t\t\t\t\tthis.hooks.call,\n\t\t\t\t\t/** @type {NonNullable<BasicEvaluatedExpression[\"identifier\"]>} */\n\t\t\t\t\t(callee.identifier),\n\t\t\t\t\texpression\n\t\t\t\t);\n\t\t\t\tif (result2 === true) return;\n\t\t\t}\n\n\t\t\tif (expression.callee) {\n\t\t\t\tif (expression.callee.type === \"MemberExpression\") {\n\t\t\t\t\t// because of call context we need to walk the call context as expression\n\t\t\t\t\tthis.walkExpression(expression.callee.object);\n\t\t\t\t\tif (expression.callee.computed === true)\n\t\t\t\t\t\tthis.walkExpression(expression.callee.property);\n\t\t\t\t} else {\n\t\t\t\t\tthis.walkExpression(expression.callee);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (expression.arguments) this.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\t/**\n\t * @param {MemberExpression} expression member expression\n\t */\n\twalkMemberExpression(expression) {\n\t\tconst exprInfo = this.getMemberExpressionInfo(\n\t\t\texpression,\n\t\t\tALLOWED_MEMBER_TYPES_ALL\n\t\t);\n\t\tif (exprInfo) {\n\t\t\tswitch (exprInfo.type) {\n\t\t\t\tcase \"expression\": {\n\t\t\t\t\tconst result1 = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.expression,\n\t\t\t\t\t\texprInfo.name,\n\t\t\t\t\t\texpression\n\t\t\t\t\t);\n\t\t\t\t\tif (result1 === true) return;\n\t\t\t\t\tconst members = exprInfo.getMembers();\n\t\t\t\t\tconst membersOptionals = exprInfo.getMembersOptionals();\n\t\t\t\t\tconst memberRanges = exprInfo.getMemberRanges();\n\t\t\t\t\tconst result2 = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.expressionMemberChain,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\tmembers,\n\t\t\t\t\t\tmembersOptionals,\n\t\t\t\t\t\tmemberRanges\n\t\t\t\t\t);\n\t\t\t\t\tif (result2 === true) return;\n\t\t\t\t\tthis.walkMemberExpressionWithExpressionName(\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprInfo.name,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\tmembers.slice(),\n\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\t\t\t\tthis.hooks.unhandledExpressionMemberChain,\n\t\t\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\t\t\texpression,\n\t\t\t\t\t\t\t\tmembers\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcase \"call\": {\n\t\t\t\t\tconst result = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.memberChainOfCallMemberChain,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprInfo.getCalleeMembers(),\n\t\t\t\t\t\texprInfo.call,\n\t\t\t\t\t\texprInfo.getMembers(),\n\t\t\t\t\t\texprInfo.getMemberRanges()\n\t\t\t\t\t);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t\t// Fast skip over the member chain as we already called memberChainOfCallMemberChain\n\t\t\t\t\t// and call computed property are literals anyway\n\t\t\t\t\tthis.walkExpression(exprInfo.call);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.object);\n\t\tif (expression.computed === true) this.walkExpression(expression.property);\n\t}\n\n\t/**\n\t * @param {TODO} expression member expression\n\t * @param {string} name name\n\t * @param {string | VariableInfo} rootInfo root info\n\t * @param {string[]} members members\n\t * @param {TODO} onUnhandled on unhandled callback\n\t */\n\twalkMemberExpressionWithExpressionName(\n\t\texpression,\n\t\tname,\n\t\trootInfo,\n\t\tmembers,\n\t\tonUnhandled\n\t) {\n\t\tif (expression.object.type === \"MemberExpression\") {\n\t\t\t// optimize the case where expression.object is a MemberExpression too.\n\t\t\t// we can keep info here when calling walkMemberExpression directly\n\t\t\tconst property =\n\t\t\t\texpression.property.name || `${expression.property.value}`;\n\t\t\tname = name.slice(0, -property.length - 1);\n\t\t\tmembers.pop();\n\t\t\tconst result = this.callHooksForInfo(\n\t\t\t\tthis.hooks.expression,\n\t\t\t\tname,\n\t\t\t\texpression.object\n\t\t\t);\n\t\t\tif (result === true) return;\n\t\t\tthis.walkMemberExpressionWithExpressionName(\n\t\t\t\texpression.object,\n\t\t\t\tname,\n\t\t\t\trootInfo,\n\t\t\t\tmembers,\n\t\t\t\tonUnhandled\n\t\t\t);\n\t\t} else if (!onUnhandled || !onUnhandled()) {\n\t\t\tthis.walkExpression(expression.object);\n\t\t}\n\t\tif (expression.computed === true) this.walkExpression(expression.property);\n\t}\n\n\t/**\n\t * @param {ThisExpression} expression this expression\n\t */\n\twalkThisExpression(expression) {\n\t\tthis.callHooksForName(this.hooks.expression, \"this\", expression);\n\t}\n\n\t/**\n\t * @param {Identifier} expression identifier\n\t */\n\twalkIdentifier(expression) {\n\t\tthis.callHooksForName(this.hooks.expression, expression.name, expression);\n\t}\n\n\t/**\n\t * @param {MetaProperty} metaProperty meta property\n\t */\n\twalkMetaProperty(metaProperty) {\n\t\tthis.hooks.expression.for(getRootName(metaProperty)).call(metaProperty);\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {Expression | Super} expr expression\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R | undefined} result of hook\n\t */\n\tcallHooksForExpression(hookMap, expr, ...args) {\n\t\treturn this.callHooksForExpressionWithFallback(\n\t\t\thookMap,\n\t\t\texpr,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {Expression | Super} expr expression info\n\t * @param {(function(string, string | ScopeInfo | VariableInfo, function(): string[]): any) | undefined} fallback callback when variable in not handled by hooks\n\t * @param {(function(string): any) | undefined} defined callback when variable is defined\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R | undefined} result of hook\n\t */\n\tcallHooksForExpressionWithFallback(\n\t\thookMap,\n\t\texpr,\n\t\tfallback,\n\t\tdefined,\n\t\t...args\n\t) {\n\t\tconst exprName = this.getMemberExpressionInfo(\n\t\t\texpr,\n\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t);\n\t\tif (exprName !== undefined) {\n\t\t\tconst members = exprName.getMembers();\n\t\t\treturn this.callHooksForInfoWithFallback(\n\t\t\t\thookMap,\n\t\t\t\tmembers.length === 0 ? exprName.rootInfo : exprName.name,\n\t\t\t\tfallback &&\n\t\t\t\t\t(name => fallback(name, exprName.rootInfo, exprName.getMembers)),\n\t\t\t\tdefined && (() => defined(exprName.name)),\n\t\t\t\t...args\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {string} name key in map\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R | undefined} result of hook\n\t */\n\tcallHooksForName(hookMap, name, ...args) {\n\t\treturn this.callHooksForNameWithFallback(\n\t\t\thookMap,\n\t\t\tname,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks that should be called\n\t * @param {ExportedVariableInfo} info variable info\n\t * @param  {AsArray<T>} args args for the hook\n\t * @returns {R | undefined} result of hook\n\t */\n\tcallHooksForInfo(hookMap, info, ...args) {\n\t\treturn this.callHooksForInfoWithFallback(\n\t\t\thookMap,\n\t\t\tinfo,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {ExportedVariableInfo} info variable info\n\t * @param {(function(string): any) | undefined} fallback callback when variable in not handled by hooks\n\t * @param {(function(string=): any) | undefined} defined callback when variable is defined\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R | undefined} result of hook\n\t */\n\tcallHooksForInfoWithFallback(hookMap, info, fallback, defined, ...args) {\n\t\tlet name;\n\t\tif (typeof info === \"string\") {\n\t\t\tname = info;\n\t\t} else {\n\t\t\tif (!(info instanceof VariableInfo)) {\n\t\t\t\tif (defined !== undefined) {\n\t\t\t\t\treturn defined();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet tagInfo = info.tagInfo;\n\t\t\twhile (tagInfo !== undefined) {\n\t\t\t\tconst hook = hookMap.get(tagInfo.tag);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tthis.currentTagData = tagInfo.data;\n\t\t\t\t\tconst result = hook.call(...args);\n\t\t\t\t\tthis.currentTagData = undefined;\n\t\t\t\t\tif (result !== undefined) return result;\n\t\t\t\t}\n\t\t\t\ttagInfo = tagInfo.next;\n\t\t\t}\n\t\t\tif (info.freeName === true) {\n\t\t\t\tif (defined !== undefined) {\n\t\t\t\t\treturn defined();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tname = info.freeName;\n\t\t}\n\t\tconst hook = hookMap.get(name);\n\t\tif (hook !== undefined) {\n\t\t\tconst result = hook.call(...args);\n\t\t\tif (result !== undefined) return result;\n\t\t}\n\t\tif (fallback !== undefined) {\n\t\t\treturn fallback(/** @type {string} */ (name));\n\t\t}\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {string} name key in map\n\t * @param {(function(string): any) | undefined} fallback callback when variable in not handled by hooks\n\t * @param {(function(): any) | undefined} defined callback when variable is defined\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R | undefined} result of hook\n\t */\n\tcallHooksForNameWithFallback(hookMap, name, fallback, defined, ...args) {\n\t\treturn this.callHooksForInfoWithFallback(\n\t\t\thookMap,\n\t\t\tthis.getVariableInfo(name),\n\t\t\tfallback,\n\t\t\tdefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated\n\t * @param {any} params scope params\n\t * @param {function(): void} fn inner function\n\t * @returns {void}\n\t */\n\tinScope(params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tinTaggedTemplateTag: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild()\n\t\t};\n\n\t\tthis.undefineVariable(\"this\");\n\n\t\tthis.enterPatterns(params, ident => {\n\t\t\tthis.defineVariable(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\t/**\n\t * @param {boolean} hasThis true, when this is defined\n\t * @param {Identifier[]} params scope params\n\t * @param {function(): void} fn inner function\n\t * @returns {void}\n\t */\n\tinClassScope(hasThis, params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tinTaggedTemplateTag: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild()\n\t\t};\n\n\t\tif (hasThis) {\n\t\t\tthis.undefineVariable(\"this\");\n\t\t}\n\n\t\tthis.enterPatterns(params, ident => {\n\t\t\tthis.defineVariable(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\t/**\n\t * @param {boolean} hasThis true, when this is defined\n\t * @param {(Pattern | string)[]} params scope params\n\t * @param {function(): void} fn inner function\n\t * @returns {void}\n\t */\n\tinFunctionScope(hasThis, params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tinTaggedTemplateTag: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild()\n\t\t};\n\n\t\tif (hasThis) {\n\t\t\tthis.undefineVariable(\"this\");\n\t\t}\n\n\t\tthis.enterPatterns(params, ident => {\n\t\t\tthis.defineVariable(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\t/**\n\t * @param {function(): void} fn inner function\n\t * @returns {void}\n\t */\n\tinBlockScope(fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: oldScope.inTry,\n\t\t\tinShorthand: false,\n\t\t\tinTaggedTemplateTag: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild()\n\t\t};\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\t/**\n\t * @param {Array<Directive | Statement | ModuleDeclaration>} statements statements\n\t */\n\tdetectMode(statements) {\n\t\tconst isLiteral =\n\t\t\tstatements.length >= 1 &&\n\t\t\tstatements[0].type === \"ExpressionStatement\" &&\n\t\t\tstatements[0].expression.type === \"Literal\";\n\t\tif (\n\t\t\tisLiteral &&\n\t\t\t/** @type {Literal} */\n\t\t\t(/** @type {ExpressionStatement} */ (statements[0]).expression).value ===\n\t\t\t\t\"use strict\"\n\t\t) {\n\t\t\tthis.scope.isStrict = true;\n\t\t}\n\t\tif (\n\t\t\tisLiteral &&\n\t\t\t/** @type {Literal} */\n\t\t\t(/** @type {ExpressionStatement} */ (statements[0]).expression).value ===\n\t\t\t\t\"use asm\"\n\t\t) {\n\t\t\tthis.scope.isAsmJs = true;\n\t\t}\n\t}\n\n\t/**\n\t * @param {(string | Pattern | Property)[]} patterns patterns\n\t * @param {OnIdentString} onIdent on ident callback\n\t */\n\tenterPatterns(patterns, onIdent) {\n\t\tfor (const pattern of patterns) {\n\t\t\tif (typeof pattern !== \"string\") {\n\t\t\t\tthis.enterPattern(pattern, onIdent);\n\t\t\t} else if (pattern) {\n\t\t\t\tonIdent(pattern);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Pattern | Property} pattern pattern\n\t * @param {OnIdent} onIdent on ident callback\n\t */\n\tenterPattern(pattern, onIdent) {\n\t\tif (!pattern) return;\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.enterArrayPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.enterAssignmentPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.enterIdentifier(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.enterObjectPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.enterRestElement(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Property\":\n\t\t\t\tif (pattern.shorthand && pattern.value.type === \"Identifier\") {\n\t\t\t\t\tthis.scope.inShorthand = pattern.value.name;\n\t\t\t\t\tthis.enterIdentifier(pattern.value, onIdent);\n\t\t\t\t\tthis.scope.inShorthand = false;\n\t\t\t\t} else {\n\t\t\t\t\tthis.enterPattern(/** @type {Pattern} */ (pattern.value), onIdent);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Identifier} pattern identifier pattern\n\t * @param {OnIdent} onIdent callback\n\t */\n\tenterIdentifier(pattern, onIdent) {\n\t\tif (!this.callHooksForName(this.hooks.pattern, pattern.name, pattern)) {\n\t\t\tonIdent(pattern.name, pattern);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ObjectPattern} pattern object pattern\n\t * @param {OnIdent} onIdent callback\n\t */\n\tenterObjectPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = pattern.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = pattern.properties[propIndex];\n\t\t\tthis.enterPattern(prop, onIdent);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ArrayPattern} pattern object pattern\n\t * @param {OnIdent} onIdent callback\n\t */\n\tenterArrayPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet elementIndex = 0, len = pattern.elements.length;\n\t\t\telementIndex < len;\n\t\t\telementIndex++\n\t\t) {\n\t\t\tconst element = pattern.elements[elementIndex];\n\n\t\t\tif (element) {\n\t\t\t\tthis.enterPattern(element, onIdent);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {RestElement} pattern object pattern\n\t * @param {OnIdent} onIdent callback\n\t */\n\tenterRestElement(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.argument, onIdent);\n\t}\n\n\t/**\n\t * @param {AssignmentPattern} pattern object pattern\n\t * @param {OnIdent} onIdent callback\n\t */\n\tenterAssignmentPattern(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.left, onIdent);\n\t}\n\n\t/**\n\t * @param {Expression | SpreadElement | PrivateIdentifier} expression expression node\n\t * @returns {BasicEvaluatedExpression} evaluation result\n\t */\n\tevaluateExpression(expression) {\n\t\ttry {\n\t\t\tconst hook = this.hooks.evaluate.get(expression.type);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result !== undefined && result !== null) {\n\t\t\t\t\tresult.setExpression(expression);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.warn(err);\n\t\t\t// ignore error\n\t\t}\n\t\treturn new BasicEvaluatedExpression()\n\t\t\t.setRange(/** @type {Range} */ (expression.range))\n\t\t\t.setExpression(expression);\n\t}\n\n\t/**\n\t * @param {Expression} expression expression\n\t * @returns {string} parsed string\n\t */\n\tparseString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tthis.parseString(/** @type {Expression} */ (expression.left)) +\n\t\t\t\t\t\tthis.parseString(expression.right)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"Literal\":\n\t\t\t\treturn String(expression.value);\n\t\t}\n\t\tthrow new Error(\n\t\t\t`${expression.type} is not supported as parameter for require`\n\t\t);\n\t}\n\n\t/**\n\t * @param {Expression} expression expression\n\t * @returns {{ range?: Range, value: string, code: boolean, conditional: TODO }} result\n\t */\n\tparseCalculatedString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\tconst left = this.parseCalculatedString(\n\t\t\t\t\t\t/** @type {Expression} */\n\t\t\t\t\t\t(expression.left)\n\t\t\t\t\t);\n\t\t\t\t\tconst right = this.parseCalculatedString(expression.right);\n\t\t\t\t\tif (left.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: left.range,\n\t\t\t\t\t\t\tvalue: left.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (right.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [\n\t\t\t\t\t\t\t\t/** @type {Range} */\n\t\t\t\t\t\t\t\t(left.range)[0],\n\t\t\t\t\t\t\t\tright.range\n\t\t\t\t\t\t\t\t\t? right.range[1]\n\t\t\t\t\t\t\t\t\t: /** @type {Range} */ (left.range)[1]\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\trange: [\n\t\t\t\t\t\t\t/** @type {Range} */\n\t\t\t\t\t\t\t(left.range)[0],\n\t\t\t\t\t\t\t/** @type {Range} */\n\t\t\t\t\t\t\t(right.range)[1]\n\t\t\t\t\t\t],\n\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\tcode: false,\n\t\t\t\t\t\tconditional: false\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\": {\n\t\t\t\tconst consequent = this.parseCalculatedString(expression.consequent);\n\t\t\t\tconst alternate = this.parseCalculatedString(expression.alternate);\n\t\t\t\tconst items = [];\n\t\t\t\tif (consequent.conditional) {\n\t\t\t\t\titems.push(...consequent.conditional);\n\t\t\t\t} else if (!consequent.code) {\n\t\t\t\t\titems.push(consequent);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (alternate.conditional) {\n\t\t\t\t\titems.push(...alternate.conditional);\n\t\t\t\t} else if (!alternate.code) {\n\t\t\t\t\titems.push(alternate);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\trange: undefined,\n\t\t\t\t\tvalue: \"\",\n\t\t\t\t\tcode: true,\n\t\t\t\t\tconditional: items\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase \"Literal\":\n\t\t\t\treturn {\n\t\t\t\t\trange: expression.range,\n\t\t\t\t\tvalue: String(expression.value),\n\t\t\t\t\tcode: false,\n\t\t\t\t\tconditional: false\n\t\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\trange: undefined,\n\t\t\tvalue: \"\",\n\t\t\tcode: true,\n\t\t\tconditional: false\n\t\t};\n\t}\n\n\t/**\n\t * @param {string | Buffer | PreparsedAst} source the source to parse\n\t * @param {ParserState} state the parser state\n\t * @returns {ParserState} the parser state\n\t */\n\tparse(source, state) {\n\t\tlet ast;\n\t\t/** @type {import(\"acorn\").Comment[]} */\n\t\tlet comments;\n\t\tconst semicolons = new Set();\n\t\tif (source === null) {\n\t\t\tthrow new Error(\"source must not be null\");\n\t\t}\n\t\tif (Buffer.isBuffer(source)) {\n\t\t\tsource = source.toString(\"utf-8\");\n\t\t}\n\t\tif (typeof source === \"object\") {\n\t\t\tast = /** @type {Program} */ (source);\n\t\t\tcomments = source.comments;\n\t\t} else {\n\t\t\tcomments = [];\n\t\t\tast = JavascriptParser._parse(source, {\n\t\t\t\tsourceType: this.sourceType,\n\t\t\t\tonComment: comments,\n\t\t\t\tonInsertedSemicolon: pos => semicolons.add(pos)\n\t\t\t});\n\t\t}\n\n\t\tconst oldScope = this.scope;\n\t\tconst oldState = this.state;\n\t\tconst oldComments = this.comments;\n\t\tconst oldSemicolons = this.semicolons;\n\t\tconst oldStatementPath = this.statementPath;\n\t\tconst oldPrevStatement = this.prevStatement;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: true,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tinTaggedTemplateTag: false,\n\t\t\tisStrict: false,\n\t\t\tisAsmJs: false,\n\t\t\tdefinitions: new StackedMap()\n\t\t};\n\t\t/** @type {ParserState} */\n\t\tthis.state = state;\n\t\tthis.comments = comments;\n\t\tthis.semicolons = semicolons;\n\t\tthis.statementPath = [];\n\t\tthis.prevStatement = undefined;\n\t\tif (this.hooks.program.call(ast, comments) === undefined) {\n\t\t\tthis.destructuringAssignmentProperties = new WeakMap();\n\t\t\tthis.detectMode(ast.body);\n\t\t\tthis.preWalkStatements(ast.body);\n\t\t\tthis.prevStatement = undefined;\n\t\t\tthis.blockPreWalkStatements(ast.body);\n\t\t\tthis.prevStatement = undefined;\n\t\t\tthis.walkStatements(ast.body);\n\t\t\tthis.destructuringAssignmentProperties = undefined;\n\t\t}\n\t\tthis.hooks.finish.call(ast, comments);\n\t\tthis.scope = oldScope;\n\t\t/** @type {ParserState} */\n\t\tthis.state = oldState;\n\t\tthis.comments = oldComments;\n\t\tthis.semicolons = oldSemicolons;\n\t\tthis.statementPath = oldStatementPath;\n\t\tthis.prevStatement = oldPrevStatement;\n\t\treturn state;\n\t}\n\n\t/**\n\t * @param {string} source source code\n\t * @returns {BasicEvaluatedExpression} evaluation result\n\t */\n\tevaluate(source) {\n\t\tconst ast = JavascriptParser._parse(`(${source})`, {\n\t\t\tsourceType: this.sourceType,\n\t\t\tlocations: false\n\t\t});\n\t\tif (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n\t\t\tthrow new Error(\"evaluate: Source is not a expression\");\n\t\t}\n\t\treturn this.evaluateExpression(ast.body[0].expression);\n\t}\n\n\t/**\n\t * @param {Expression | Declaration | PrivateIdentifier | null | undefined} expr an expression\n\t * @param {number} commentsStartPos source position from which annotation comments are checked\n\t * @returns {boolean} true, when the expression is pure\n\t */\n\tisPure(expr, commentsStartPos) {\n\t\tif (!expr) return true;\n\t\tconst result = this.hooks.isPure\n\t\t\t.for(expr.type)\n\t\t\t.call(expr, commentsStartPos);\n\t\tif (typeof result === \"boolean\") return result;\n\t\tswitch (expr.type) {\n\t\t\t// TODO handle more cases\n\t\t\tcase \"ClassDeclaration\":\n\t\t\tcase \"ClassExpression\": {\n\t\t\t\tif (expr.body.type !== \"ClassBody\") return false;\n\t\t\t\tif (\n\t\t\t\t\texpr.superClass &&\n\t\t\t\t\t!this.isPure(expr.superClass, /** @type {Range} */ (expr.range)[0])\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tconst items =\n\t\t\t\t\t/** @type {TODO[]} */\n\t\t\t\t\t(expr.body.body);\n\t\t\t\treturn items.every(item => {\n\t\t\t\t\tif (\n\t\t\t\t\t\titem.computed &&\n\t\t\t\t\t\titem.key &&\n\t\t\t\t\t\t!this.isPure(item.key, item.range[0])\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\titem.static &&\n\t\t\t\t\t\titem.value &&\n\t\t\t\t\t\t!this.isPure(\n\t\t\t\t\t\t\titem.value,\n\t\t\t\t\t\t\titem.key ? item.key.range[1] : item.range[0]\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (item.type === \"StaticBlock\") {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\texpr.superClass &&\n\t\t\t\t\t\titem.type === \"MethodDefinition\" &&\n\t\t\t\t\t\titem.kind === \"constructor\"\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\tcase \"FunctionExpression\":\n\t\t\tcase \"ArrowFunctionExpression\":\n\t\t\tcase \"ThisExpression\":\n\t\t\tcase \"Literal\":\n\t\t\tcase \"TemplateLiteral\":\n\t\t\tcase \"Identifier\":\n\t\t\tcase \"PrivateIdentifier\":\n\t\t\t\treturn true;\n\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\treturn expr.declarations.every(decl =>\n\t\t\t\t\tthis.isPure(decl.init, /** @type {Range} */ (decl.range)[0])\n\t\t\t\t);\n\n\t\t\tcase \"ConditionalExpression\":\n\t\t\t\treturn (\n\t\t\t\t\tthis.isPure(expr.test, commentsStartPos) &&\n\t\t\t\t\tthis.isPure(\n\t\t\t\t\t\texpr.consequent,\n\t\t\t\t\t\t/** @type {Range} */ (expr.test.range)[1]\n\t\t\t\t\t) &&\n\t\t\t\t\tthis.isPure(\n\t\t\t\t\t\texpr.alternate,\n\t\t\t\t\t\t/** @type {Range} */ (expr.consequent.range)[1]\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\tcase \"LogicalExpression\":\n\t\t\t\treturn (\n\t\t\t\t\tthis.isPure(expr.left, commentsStartPos) &&\n\t\t\t\t\tthis.isPure(expr.right, /** @type {Range} */ (expr.left.range)[1])\n\t\t\t\t);\n\n\t\t\tcase \"SequenceExpression\":\n\t\t\t\treturn expr.expressions.every(expr => {\n\t\t\t\t\tconst pureFlag = this.isPure(expr, commentsStartPos);\n\t\t\t\t\tcommentsStartPos = /** @type {Range} */ (expr.range)[1];\n\t\t\t\t\treturn pureFlag;\n\t\t\t\t});\n\n\t\t\tcase \"CallExpression\": {\n\t\t\t\tconst pureFlag =\n\t\t\t\t\t/** @type {Range} */ (expr.range)[0] - commentsStartPos > 12 &&\n\t\t\t\t\tthis.getComments([\n\t\t\t\t\t\tcommentsStartPos,\n\t\t\t\t\t\t/** @type {Range} */ (expr.range)[0]\n\t\t\t\t\t]).some(\n\t\t\t\t\t\tcomment =>\n\t\t\t\t\t\t\tcomment.type === \"Block\" &&\n\t\t\t\t\t\t\t/^\\s*(#|@)__PURE__\\s*$/.test(comment.value)\n\t\t\t\t\t);\n\t\t\t\tif (!pureFlag) return false;\n\t\t\t\tcommentsStartPos = /** @type {Range} */ (expr.callee.range)[1];\n\t\t\t\treturn expr.arguments.every(arg => {\n\t\t\t\t\tif (arg.type === \"SpreadElement\") return false;\n\t\t\t\t\tconst pureFlag = this.isPure(arg, commentsStartPos);\n\t\t\t\t\tcommentsStartPos = /** @type {Range} */ (arg.range)[1];\n\t\t\t\t\treturn pureFlag;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tconst evaluated = this.evaluateExpression(expr);\n\t\treturn !evaluated.couldHaveSideEffects();\n\t}\n\n\t/**\n\t * @param {Range} range range\n\t * @returns {Comment[]} comments in the range\n\t */\n\tgetComments(range) {\n\t\tconst [rangeStart, rangeEnd] = range;\n\t\t/**\n\t\t * @param {Comment} comment comment\n\t\t * @param {number} needle needle\n\t\t * @returns {number} compared\n\t\t */\n\t\tconst compare = (comment, needle) =>\n\t\t\t/** @type {Range} */ (comment.range)[0] - needle;\n\t\tconst comments = /** @type {Comment[]} */ (this.comments);\n\t\tlet idx = binarySearchBounds.ge(comments, rangeStart, compare);\n\t\t/** @type {Comment[]} */\n\t\tconst commentsInRange = [];\n\t\twhile (\n\t\t\tcomments[idx] &&\n\t\t\t/** @type {Range} */ (comments[idx].range)[1] <= rangeEnd\n\t\t) {\n\t\t\tcommentsInRange.push(comments[idx]);\n\t\t\tidx++;\n\t\t}\n\n\t\treturn commentsInRange;\n\t}\n\n\t/**\n\t * @param {number} pos source code position\n\t * @returns {boolean} true when a semicolon has been inserted before this position, false if not\n\t */\n\tisAsiPosition(pos) {\n\t\tconst currentStatement =\n\t\t\t/** @type {StatementPath} */\n\t\t\t(this.statementPath)[\n\t\t\t\t/** @type {StatementPath} */\n\t\t\t\t(this.statementPath).length - 1\n\t\t\t];\n\t\tif (currentStatement === undefined) throw new Error(\"Not in statement\");\n\t\tconst range = /** @type {Range} */ (currentStatement.range);\n\n\t\treturn (\n\t\t\t// Either asking directly for the end position of the current statement\n\t\t\t(range[1] === pos &&\n\t\t\t\t/** @type {Set<number>} */ (this.semicolons).has(pos)) ||\n\t\t\t// Or asking for the start position of the current statement,\n\t\t\t// here we have to check multiple things\n\t\t\t(range[0] === pos &&\n\t\t\t\t// is there a previous statement which might be relevant?\n\t\t\t\tthis.prevStatement !== undefined &&\n\t\t\t\t// is the end position of the previous statement an ASI position?\n\t\t\t\t/** @type {Set<number>} */ (this.semicolons).has(\n\t\t\t\t\t/** @type {Range} */ (this.prevStatement.range)[1]\n\t\t\t\t))\n\t\t);\n\t}\n\n\t/**\n\t * @param {number} pos source code position\n\t * @returns {void}\n\t */\n\tsetAsiPosition(pos) {\n\t\t/** @type {Set<number>} */ (this.semicolons).add(pos);\n\t}\n\n\t/**\n\t * @param {number} pos source code position\n\t * @returns {void}\n\t */\n\tunsetAsiPosition(pos) {\n\t\t/** @type {Set<number>} */ (this.semicolons).delete(pos);\n\t}\n\n\t/**\n\t * @param {Expression} expr expression\n\t * @returns {boolean} true, when the expression is a statement level expression\n\t */\n\tisStatementLevelExpression(expr) {\n\t\tconst currentStatement =\n\t\t\t/** @type {StatementPath} */\n\t\t\t(this.statementPath)[\n\t\t\t\t/** @type {StatementPath} */\n\t\t\t\t(this.statementPath).length - 1\n\t\t\t];\n\t\treturn (\n\t\t\texpr === currentStatement ||\n\t\t\t(currentStatement.type === \"ExpressionStatement\" &&\n\t\t\t\tcurrentStatement.expression === expr)\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} name name\n\t * @param {symbol} tag tag info\n\t * @returns {TODO} tag data\n\t */\n\tgetTagData(name, tag) {\n\t\tconst info = this.scope.definitions.get(name);\n\t\tif (info instanceof VariableInfo) {\n\t\t\tlet tagInfo = info.tagInfo;\n\t\t\twhile (tagInfo !== undefined) {\n\t\t\t\tif (tagInfo.tag === tag) return tagInfo.data;\n\t\t\t\ttagInfo = tagInfo.next;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} name name\n\t * @param {symbol} tag tag info\n\t * @param {TODO=} data data\n\t */\n\ttagVariable(name, tag, data) {\n\t\tconst oldInfo = this.scope.definitions.get(name);\n\t\t/** @type {VariableInfo} */\n\t\tlet newInfo;\n\t\tif (oldInfo === undefined) {\n\t\t\tnewInfo = new VariableInfo(this.scope, name, {\n\t\t\t\ttag,\n\t\t\t\tdata,\n\t\t\t\tnext: undefined\n\t\t\t});\n\t\t} else if (oldInfo instanceof VariableInfo) {\n\t\t\tnewInfo = new VariableInfo(oldInfo.declaredScope, oldInfo.freeName, {\n\t\t\t\ttag,\n\t\t\t\tdata,\n\t\t\t\tnext: oldInfo.tagInfo\n\t\t\t});\n\t\t} else {\n\t\t\tnewInfo = new VariableInfo(oldInfo, true, {\n\t\t\t\ttag,\n\t\t\t\tdata,\n\t\t\t\tnext: undefined\n\t\t\t});\n\t\t}\n\t\tthis.scope.definitions.set(name, newInfo);\n\t}\n\n\t/**\n\t * @param {string} name variable name\n\t */\n\tdefineVariable(name) {\n\t\tconst oldInfo = this.scope.definitions.get(name);\n\t\t// Don't redefine variable in same scope to keep existing tags\n\t\tif (oldInfo instanceof VariableInfo && oldInfo.declaredScope === this.scope)\n\t\t\treturn;\n\t\tthis.scope.definitions.set(name, this.scope);\n\t}\n\n\t/**\n\t * @param {string} name variable name\n\t */\n\tundefineVariable(name) {\n\t\tthis.scope.definitions.delete(name);\n\t}\n\n\t/**\n\t * @param {string} name variable name\n\t * @returns {boolean} true, when variable is defined\n\t */\n\tisVariableDefined(name) {\n\t\tconst info = this.scope.definitions.get(name);\n\t\tif (info === undefined) return false;\n\t\tif (info instanceof VariableInfo) {\n\t\t\treturn info.freeName === true;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {string} name variable name\n\t * @returns {string | ExportedVariableInfo} info for this variable\n\t */\n\tgetVariableInfo(name) {\n\t\tconst value = this.scope.definitions.get(name);\n\t\tif (value === undefined) {\n\t\t\treturn name;\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * @param {string} name variable name\n\t * @param {string | ExportedVariableInfo} variableInfo new info for this variable\n\t * @returns {void}\n\t */\n\tsetVariable(name, variableInfo) {\n\t\tif (typeof variableInfo === \"string\") {\n\t\t\tif (variableInfo === name) {\n\t\t\t\tthis.scope.definitions.delete(name);\n\t\t\t} else {\n\t\t\t\tthis.scope.definitions.set(\n\t\t\t\t\tname,\n\t\t\t\t\tnew VariableInfo(this.scope, variableInfo, undefined)\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.scope.definitions.set(name, variableInfo);\n\t\t}\n\t}\n\n\t/**\n\t * @param {TagInfo} tagInfo tag info\n\t * @returns {VariableInfo} variable info\n\t */\n\tevaluatedVariable(tagInfo) {\n\t\treturn new VariableInfo(this.scope, undefined, tagInfo);\n\t}\n\n\t/**\n\t * @param {Range} range range of the comment\n\t * @returns {{ options: Record<string, any> | null, errors: (Error & { comment: Comment })[] | null }} result\n\t */\n\tparseCommentOptions(range) {\n\t\tconst comments = this.getComments(range);\n\t\tif (comments.length === 0) {\n\t\t\treturn EMPTY_COMMENT_OPTIONS;\n\t\t}\n\t\t/** @type {Record<string, EXPECTED_ANY> } */\n\t\tconst options = {};\n\t\t/** @type {(Error & { comment: Comment })[]} */\n\t\tconst errors = [];\n\t\tfor (const comment of comments) {\n\t\t\tconst { value } = comment;\n\t\t\tif (value && webpackCommentRegExp.test(value)) {\n\t\t\t\t// try compile only if webpack options comment is present\n\t\t\t\ttry {\n\t\t\t\t\tfor (let [key, val] of Object.entries(\n\t\t\t\t\t\tvm.runInContext(\n\t\t\t\t\t\t\t`(function(){return {${value}};})()`,\n\t\t\t\t\t\t\tthis.magicCommentContext\n\t\t\t\t\t\t)\n\t\t\t\t\t)) {\n\t\t\t\t\t\tif (typeof val === \"object\" && val !== null) {\n\t\t\t\t\t\t\tval =\n\t\t\t\t\t\t\t\tval.constructor.name === \"RegExp\"\n\t\t\t\t\t\t\t\t\t? new RegExp(val)\n\t\t\t\t\t\t\t\t\t: JSON.parse(JSON.stringify(val));\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptions[key] = val;\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\tconst newErr = new Error(String(/** @type {Error} */ (err).message));\n\t\t\t\t\tnewErr.stack = String(/** @type {Error} */ (err).stack);\n\t\t\t\t\tObject.assign(newErr, { comment });\n\t\t\t\t\terrors.push(/** @type {(Error & { comment: Comment })} */ (newErr));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { options, errors };\n\t}\n\n\t/**\n\t * @param {Expression | Super} expression a member expression\n\t * @returns {{ members: string[], object: Expression | Super, membersOptionals: boolean[], memberRanges: Range[] }} member names (reverse order) and remaining object\n\t */\n\textractMemberExpressionChain(expression) {\n\t\t/** @type {Node} */\n\t\tlet expr = expression;\n\t\tconst members = [];\n\t\tconst membersOptionals = [];\n\t\tconst memberRanges = [];\n\t\twhile (expr.type === \"MemberExpression\") {\n\t\t\tif (expr.computed) {\n\t\t\t\tif (expr.property.type !== \"Literal\") break;\n\t\t\t\tmembers.push(`${expr.property.value}`); // the literal\n\t\t\t\tmemberRanges.push(/** @type {Range} */ (expr.object.range)); // the range of the expression fragment before the literal\n\t\t\t} else {\n\t\t\t\tif (expr.property.type !== \"Identifier\") break;\n\t\t\t\tmembers.push(expr.property.name); // the identifier\n\t\t\t\tmemberRanges.push(/** @type {Range} */ (expr.object.range)); // the range of the expression fragment before the identifier\n\t\t\t}\n\t\t\tmembersOptionals.push(expr.optional);\n\t\t\texpr = expr.object;\n\t\t}\n\n\t\treturn {\n\t\t\tmembers,\n\t\t\tmembersOptionals,\n\t\t\tmemberRanges,\n\t\t\tobject: expr\n\t\t};\n\t}\n\n\t/**\n\t * @param {string} varName variable name\n\t * @returns {{name: string, info: VariableInfo | string} | undefined} name of the free variable and variable info for that\n\t */\n\tgetFreeInfoFromVariable(varName) {\n\t\tconst info = this.getVariableInfo(varName);\n\t\tlet name;\n\t\tif (info instanceof VariableInfo) {\n\t\t\tname = info.freeName;\n\t\t\tif (typeof name !== \"string\") return;\n\t\t} else if (typeof info !== \"string\") {\n\t\t\treturn;\n\t\t} else {\n\t\t\tname = info;\n\t\t}\n\t\treturn { info, name };\n\t}\n\n\t/** @typedef {{ type: \"call\", call: CallExpression, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () => string[], name: string, getMembers: () => string[], getMembersOptionals: () => boolean[], getMemberRanges: () => Range[]}} CallExpressionInfo */\n\t/** @typedef {{ type: \"expression\", rootInfo: string | VariableInfo, name: string, getMembers: () => string[], getMembersOptionals: () => boolean[], getMemberRanges: () => Range[]}} ExpressionExpressionInfo */\n\n\t/**\n\t * @param {Expression | Super} expression a member expression\n\t * @param {number} allowedTypes which types should be returned, presented in bit mask\n\t * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info\n\t */\n\tgetMemberExpressionInfo(expression, allowedTypes) {\n\t\tconst { object, members, membersOptionals, memberRanges } =\n\t\t\tthis.extractMemberExpressionChain(expression);\n\t\tswitch (object.type) {\n\t\t\tcase \"CallExpression\": {\n\t\t\t\tif ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0) return;\n\t\t\t\tlet callee = object.callee;\n\t\t\t\tlet rootMembers = EMPTY_ARRAY;\n\t\t\t\tif (callee.type === \"MemberExpression\") {\n\t\t\t\t\t({ object: callee, members: rootMembers } =\n\t\t\t\t\t\tthis.extractMemberExpressionChain(callee));\n\t\t\t\t}\n\t\t\t\tconst rootName = getRootName(callee);\n\t\t\t\tif (!rootName) return;\n\t\t\t\tconst result = this.getFreeInfoFromVariable(rootName);\n\t\t\t\tif (!result) return;\n\t\t\t\tconst { info: rootInfo, name: resolvedRoot } = result;\n\t\t\t\tconst calleeName = objectAndMembersToName(resolvedRoot, rootMembers);\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"call\",\n\t\t\t\t\tcall: object,\n\t\t\t\t\tcalleeName,\n\t\t\t\t\trootInfo,\n\t\t\t\t\tgetCalleeMembers: memoize(() => rootMembers.reverse()),\n\t\t\t\t\tname: objectAndMembersToName(`${calleeName}()`, members),\n\t\t\t\t\tgetMembers: memoize(() => members.reverse()),\n\t\t\t\t\tgetMembersOptionals: memoize(() => membersOptionals.reverse()),\n\t\t\t\t\tgetMemberRanges: memoize(() => memberRanges.reverse())\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase \"Identifier\":\n\t\t\tcase \"MetaProperty\":\n\t\t\tcase \"ThisExpression\": {\n\t\t\t\tif ((allowedTypes & ALLOWED_MEMBER_TYPES_EXPRESSION) === 0) return;\n\t\t\t\tconst rootName = getRootName(object);\n\t\t\t\tif (!rootName) return;\n\n\t\t\t\tconst result = this.getFreeInfoFromVariable(rootName);\n\t\t\t\tif (!result) return;\n\t\t\t\tconst { info: rootInfo, name: resolvedRoot } = result;\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"expression\",\n\t\t\t\t\tname: objectAndMembersToName(resolvedRoot, members),\n\t\t\t\t\trootInfo,\n\t\t\t\t\tgetMembers: memoize(() => members.reverse()),\n\t\t\t\t\tgetMembersOptionals: memoize(() => membersOptionals.reverse()),\n\t\t\t\t\tgetMemberRanges: memoize(() => memberRanges.reverse())\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {MemberExpression} expression an expression\n\t * @returns {{ name: string, rootInfo: ExportedVariableInfo, getMembers: () => string[]} | undefined} name info\n\t */\n\tgetNameForExpression(expression) {\n\t\treturn this.getMemberExpressionInfo(\n\t\t\texpression,\n\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} code source code\n\t * @param {ParseOptions} options parsing options\n\t * @returns {Program} parsed ast\n\t */\n\tstatic _parse(code, options) {\n\t\tconst type = options ? options.sourceType : \"module\";\n\t\t/** @type {AcornOptions} */\n\t\tconst parserOptions = {\n\t\t\t...defaultParserOptions,\n\t\t\tallowReturnOutsideFunction: type === \"script\",\n\t\t\t...options,\n\t\t\tsourceType: type === \"auto\" ? \"module\" : type\n\t\t};\n\n\t\t/** @type {import(\"acorn\").Program | undefined} */\n\t\tlet ast;\n\t\tlet error;\n\t\tlet threw = false;\n\t\ttry {\n\t\t\tast = parser.parse(code, parserOptions);\n\t\t} catch (err) {\n\t\t\terror = err;\n\t\t\tthrew = true;\n\t\t}\n\n\t\tif (threw && type === \"auto\") {\n\t\t\tparserOptions.sourceType = \"script\";\n\t\t\tif (!(\"allowReturnOutsideFunction\" in options)) {\n\t\t\t\tparserOptions.allowReturnOutsideFunction = true;\n\t\t\t}\n\t\t\tif (Array.isArray(parserOptions.onComment)) {\n\t\t\t\tparserOptions.onComment.length = 0;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tast = parser.parse(code, parserOptions);\n\t\t\t\tthrew = false;\n\t\t\t} catch (_err) {\n\t\t\t\t// we use the error from first parse try\n\t\t\t\t// so nothing to do here\n\t\t\t}\n\t\t}\n\n\t\tif (threw) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn /** @type {Program} */ (ast);\n\t}\n}\n\nmodule.exports = JavascriptParser;\nmodule.exports.ALLOWED_MEMBER_TYPES_ALL = ALLOWED_MEMBER_TYPES_ALL;\nmodule.exports.ALLOWED_MEMBER_TYPES_EXPRESSION =\n\tALLOWED_MEMBER_TYPES_EXPRESSION;\nmodule.exports.ALLOWED_MEMBER_TYPES_CALL_EXPRESSION =\n\tALLOWED_MEMBER_TYPES_CALL_EXPRESSION;\nmodule.exports.getImportAttributes = getImportAttributes;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}