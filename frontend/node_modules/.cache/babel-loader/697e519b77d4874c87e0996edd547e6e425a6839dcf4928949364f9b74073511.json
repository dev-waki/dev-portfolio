{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst util = require(\"util\");\nconst {\n  WEBPACK_MODULE_TYPE_RUNTIME\n} = require(\"../ModuleTypeConstants\");\nconst ModuleDependency = require(\"../dependencies/ModuleDependency\");\nconst formatLocation = require(\"../formatLocation\");\nconst {\n  LogType\n} = require(\"../logging/Logger\");\nconst AggressiveSplittingPlugin = require(\"../optimize/AggressiveSplittingPlugin\");\nconst SizeLimitsPlugin = require(\"../performance/SizeLimitsPlugin\");\nconst {\n  countIterable\n} = require(\"../util/IterableHelpers\");\nconst {\n  compareLocations,\n  compareChunksById,\n  compareNumbers,\n  compareIds,\n  concatComparators,\n  compareSelect,\n  compareModulesByIdentifier\n} = require(\"../util/comparators\");\nconst {\n  makePathsRelative,\n  parseResource\n} = require(\"../util/identifier\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Chunk\").ChunkId} ChunkId */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../ChunkGroup\").OriginRecord} OriginRecord */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compilation\").Asset} Asset */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compilation\").NormalizedStatsOptions} NormalizedStatsOptions */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../ChunkGraph\").ModuleId} ModuleId */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Module\").BuildInfo} BuildInfo */\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n/** @typedef {import(\"../ModuleProfile\")} ModuleProfile */\n/** @typedef {import(\"../RequestShortener\")} RequestShortener */\n/** @typedef {import(\"../WebpackError\")} WebpackError */\n/** @typedef {import(\"../TemplatedPathPlugin\").TemplatePath} TemplatePath */\n/**\n * @template T\n * @typedef {import(\"../util/comparators\").Comparator<T>} Comparator<T>\n */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n/**\n * @template T, R\n * @typedef {import(\"../util/smartGrouping\").GroupConfig<T, R>} GroupConfig\n */\n/** @typedef {import(\"./StatsFactory\")} StatsFactory */\n/** @typedef {import(\"./StatsFactory\").StatsFactoryContext} StatsFactoryContext */\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsCompilation} StatsCompilation */\n/**\n * @typedef {object} KnownStatsCompilation\n * @property {any=} env\n * @property {string=} name\n * @property {string=} hash\n * @property {string=} version\n * @property {number=} time\n * @property {number=} builtAt\n * @property {boolean=} needAdditionalPass\n * @property {string=} publicPath\n * @property {string=} outputPath\n * @property {Record<string, string[]>=} assetsByChunkName\n * @property {StatsAsset[]=} assets\n * @property {number=} filteredAssets\n * @property {StatsChunk[]=} chunks\n * @property {StatsModule[]=} modules\n * @property {number=} filteredModules\n * @property {Record<string, StatsChunkGroup>=} entrypoints\n * @property {Record<string, StatsChunkGroup>=} namedChunkGroups\n * @property {StatsError[]=} errors\n * @property {number=} errorsCount\n * @property {StatsError[]=} warnings\n * @property {number=} warningsCount\n * @property {StatsCompilation[]=} children\n * @property {Record<string, StatsLogging>=} logging\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsLogging} StatsLogging */\n/**\n * @typedef {object} KnownStatsLogging\n * @property {StatsLoggingEntry[]} entries\n * @property {number} filteredEntries\n * @property {boolean} debug\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsLoggingEntry} StatsLoggingEntry */\n/**\n * @typedef {object} KnownStatsLoggingEntry\n * @property {string} type\n * @property {string=} message\n * @property {string[]=} trace\n * @property {StatsLoggingEntry[]=} children\n * @property {any[]=} args\n * @property {number=} time\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsAsset} StatsAsset */\n/**\n * @typedef {object} KnownStatsAsset\n * @property {string} type\n * @property {string} name\n * @property {AssetInfo} info\n * @property {number} size\n * @property {boolean} emitted\n * @property {boolean} comparedForEmit\n * @property {boolean} cached\n * @property {StatsAsset[]=} related\n * @property {(string|number)[]=} chunkNames\n * @property {(string|number)[]=} chunkIdHints\n * @property {(string|number)[]=} chunks\n * @property {(string|number)[]=} auxiliaryChunkNames\n * @property {(string|number)[]=} auxiliaryChunks\n * @property {(string|number)[]=} auxiliaryChunkIdHints\n * @property {number=} filteredRelated\n * @property {boolean=} isOverSizeLimit\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsChunkGroup} StatsChunkGroup */\n/**\n * @typedef {object} KnownStatsChunkGroup\n * @property {(string | null)=} name\n * @property {(string | number)[]=} chunks\n * @property {({ name: string, size?: number })[]=} assets\n * @property {number=} filteredAssets\n * @property {number=} assetsSize\n * @property {({ name: string, size?: number })[]=} auxiliaryAssets\n * @property {number=} filteredAuxiliaryAssets\n * @property {number=} auxiliaryAssetsSize\n * @property {{ [x: string]: StatsChunkGroup[] }=} children\n * @property {{ [x: string]: string[] }=} childAssets\n * @property {boolean=} isOverSizeLimit\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsModule} StatsModule */\n/**\n * @typedef {object} KnownStatsModule\n * @property {string=} type\n * @property {string=} moduleType\n * @property {(string | null)=} layer\n * @property {string=} identifier\n * @property {string=} name\n * @property {(string | null)=} nameForCondition\n * @property {number=} index\n * @property {number=} preOrderIndex\n * @property {number=} index2\n * @property {number=} postOrderIndex\n * @property {number=} size\n * @property {{ [x: string]: number }=} sizes\n * @property {boolean=} cacheable\n * @property {boolean=} built\n * @property {boolean=} codeGenerated\n * @property {boolean=} buildTimeExecuted\n * @property {boolean=} cached\n * @property {boolean=} optional\n * @property {boolean=} orphan\n * @property {string | number=} id\n * @property {string | number | null=} issuerId\n * @property {(string | number)[]=} chunks\n * @property {(string | number)[]=} assets\n * @property {boolean=} dependent\n * @property {(string | null)=} issuer\n * @property {(string | null)=} issuerName\n * @property {StatsModuleIssuer[]=} issuerPath\n * @property {boolean=} failed\n * @property {number=} errors\n * @property {number=} warnings\n * @property {StatsProfile=} profile\n * @property {StatsModuleReason[]=} reasons\n * @property {(boolean | null | string[])=} usedExports\n * @property {(string[] | null)=} providedExports\n * @property {string[]=} optimizationBailout\n * @property {(number | null)=} depth\n * @property {StatsModule[]=} modules\n * @property {number=} filteredModules\n * @property {ReturnType<Source[\"source\"]>=} source\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsProfile} StatsProfile */\n/**\n * @typedef {object} KnownStatsProfile\n * @property {number} total\n * @property {number} resolving\n * @property {number} restoring\n * @property {number} building\n * @property {number} integration\n * @property {number} storing\n * @property {number} additionalResolving\n * @property {number} additionalIntegration\n * @property {number} factory\n * @property {number} dependencies\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsModuleIssuer} StatsModuleIssuer */\n/**\n * @typedef {object} KnownStatsModuleIssuer\n * @property {string} identifier\n * @property {string} name\n * @property {(string|number)=} id\n * @property {StatsProfile} profile\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsModuleReason} StatsModuleReason */\n/**\n * @typedef {object} KnownStatsModuleReason\n * @property {string | null} moduleIdentifier\n * @property {string | null} module\n * @property {string | null} moduleName\n * @property {string | null} resolvedModuleIdentifier\n * @property {string | null} resolvedModule\n * @property {string | null} type\n * @property {boolean} active\n * @property {string | null} explanation\n * @property {string | null} userRequest\n * @property {(string | null)=} loc\n * @property {(string | number | null)=} moduleId\n * @property {(string | number | null)=} resolvedModuleId\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsChunk} StatsChunk */\n/**\n * @typedef {object} KnownStatsChunk\n * @property {boolean} rendered\n * @property {boolean} initial\n * @property {boolean} entry\n * @property {boolean} recorded\n * @property {string=} reason\n * @property {number} size\n * @property {Record<string, number>} sizes\n * @property {string[]} names\n * @property {string[]} idHints\n * @property {string[]=} runtime\n * @property {string[]} files\n * @property {string[]} auxiliaryFiles\n * @property {string} hash\n * @property {Record<string, (string|number)[]>} childrenByOrder\n * @property {(string|number)=} id\n * @property {(string|number)[]=} siblings\n * @property {(string|number)[]=} parents\n * @property {(string|number)[]=} children\n * @property {StatsModule[]=} modules\n * @property {number=} filteredModules\n * @property {StatsChunkOrigin[]=} origins\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsChunkOrigin} StatsChunkOrigin */\n/**\n * @typedef {object} KnownStatsChunkOrigin\n * @property {string} module\n * @property {string} moduleIdentifier\n * @property {string} moduleName\n * @property {string} loc\n * @property {string} request\n * @property {(string | number)=} moduleId\n */\n\n/** @typedef { Record<string, EXPECTED_ANY> & KnownStatsModuleTraceItem} StatsModuleTraceItem */\n/**\n * @typedef {object} KnownStatsModuleTraceItem\n * @property {string=} originIdentifier\n * @property {string=} originName\n * @property {string=} moduleIdentifier\n * @property {string=} moduleName\n * @property {StatsModuleTraceDependency[]=} dependencies\n * @property {(string|number)=} originId\n * @property {(string|number)=} moduleId\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsModuleTraceDependency} StatsModuleTraceDependency */\n/**\n * @typedef {object} KnownStatsModuleTraceDependency\n * @property {string=} loc\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsError} StatsError */\n/**\n * @typedef {object} KnownStatsError\n * @property {string} message\n * @property {string=} chunkName\n * @property {boolean=} chunkEntry\n * @property {boolean=} chunkInitial\n * @property {string=} file\n * @property {string=} moduleIdentifier\n * @property {string=} moduleName\n * @property {string=} loc\n * @property {ChunkId=} chunkId\n * @property {string|number=} moduleId\n * @property {StatsModuleTraceItem[]=} moduleTrace\n * @property {any=} details\n * @property {string=} stack\n */\n\n/** @typedef {Asset & { type: string, related: PreprocessedAsset[] | undefined }} PreprocessedAsset */\n\n/**\n * @template T\n * @template O\n * @typedef {Record<string, (object: O, data: T, context: StatsFactoryContext, options: NormalizedStatsOptions, factory: StatsFactory) => void>} ExtractorsByOption\n */\n\n/**\n * @typedef {object} SimpleExtractors\n * @property {ExtractorsByOption<Compilation, StatsCompilation>} compilation\n * @property {ExtractorsByOption<PreprocessedAsset, StatsAsset>} asset\n * @property {ExtractorsByOption<PreprocessedAsset, StatsAsset>} asset$visible\n * @property {ExtractorsByOption<{ name: string, chunkGroup: ChunkGroup }, StatsChunkGroup>} chunkGroup\n * @property {ExtractorsByOption<Module, StatsModule>} module\n * @property {ExtractorsByOption<Module, StatsModule>} module$visible\n * @property {ExtractorsByOption<Module, StatsModuleIssuer>} moduleIssuer\n * @property {ExtractorsByOption<ModuleProfile, StatsProfile>} profile\n * @property {ExtractorsByOption<ModuleGraphConnection, StatsModuleReason>} moduleReason\n * @property {ExtractorsByOption<Chunk, StatsChunk>} chunk\n * @property {ExtractorsByOption<OriginRecord, StatsChunkOrigin>} chunkOrigin\n * @property {ExtractorsByOption<WebpackError, StatsError>} error\n * @property {ExtractorsByOption<WebpackError, StatsError>} warning\n * @property {ExtractorsByOption<{ origin: Module, module: Module }, StatsModuleTraceItem>} moduleTraceItem\n * @property {ExtractorsByOption<Dependency, StatsModuleTraceDependency>} moduleTraceDependency\n */\n\n/**\n * @template T\n * @template I\n * @param {Iterable<T>} items items to select from\n * @param {function(T): Iterable<I>} selector selector function to select values from item\n * @returns {I[]} array of values\n */\nconst uniqueArray = (items, selector) => {\n  /** @type {Set<I>} */\n  const set = new Set();\n  for (const item of items) {\n    for (const i of selector(item)) {\n      set.add(i);\n    }\n  }\n  return Array.from(set);\n};\n\n/**\n * @template T\n * @template I\n * @param {Iterable<T>} items items to select from\n * @param {function(T): Iterable<I>} selector selector function to select values from item\n * @param {Comparator<I>} comparator comparator function\n * @returns {I[]} array of values\n */\nconst uniqueOrderedArray = (items, selector, comparator) => uniqueArray(items, selector).sort(comparator);\n\n/** @template T @template R @typedef {{ [P in keyof T]: R }} MappedValues<T, R> */\n\n/**\n * @template {object} T\n * @template {object} R\n * @param {T} obj object to be mapped\n * @param {function(T[keyof T], keyof T): R} fn mapping function\n * @returns {MappedValues<T, R>} mapped object\n */\nconst mapObject = (obj, fn) => {\n  const newObj = Object.create(null);\n  for (const key of Object.keys(obj)) {\n    newObj[key] = fn(obj[(/** @type {keyof T} */key)], /** @type {keyof T} */key);\n  }\n  return newObj;\n};\n\n/**\n * @param {Compilation} compilation the compilation\n * @param {function(Compilation, string): any[]} getItems get items\n * @returns {number} total number\n */\nconst countWithChildren = (compilation, getItems) => {\n  let count = getItems(compilation, \"\").length;\n  for (const child of compilation.children) {\n    count += countWithChildren(child, (c, type) => getItems(c, `.children[].compilation${type}`));\n  }\n  return count;\n};\n\n/** @type {ExtractorsByOption<WebpackError | string, StatsError>} */\nconst EXTRACT_ERROR = {\n  _: (object, error, context, {\n    requestShortener\n  }) => {\n    // TODO webpack 6 disallow strings in the errors/warnings list\n    if (typeof error === \"string\") {\n      object.message = error;\n    } else {\n      if (error.chunk) {\n        object.chunkName = error.chunk.name;\n        object.chunkEntry = error.chunk.hasRuntime();\n        object.chunkInitial = error.chunk.canBeInitial();\n      }\n      if (error.file) {\n        object.file = error.file;\n      }\n      if (error.module) {\n        object.moduleIdentifier = error.module.identifier();\n        object.moduleName = error.module.readableIdentifier(requestShortener);\n      }\n      if (error.loc) {\n        object.loc = formatLocation(error.loc);\n      }\n      object.message = error.message;\n    }\n  },\n  ids: (object, error, {\n    compilation: {\n      chunkGraph\n    }\n  }) => {\n    if (typeof error !== \"string\") {\n      if (error.chunk) {\n        object.chunkId = /** @type {ChunkId} */error.chunk.id;\n      }\n      if (error.module) {\n        object.moduleId = /** @type {ModuleId} */\n        chunkGraph.getModuleId(error.module);\n      }\n    }\n  },\n  moduleTrace: (object, error, context, options, factory) => {\n    if (typeof error !== \"string\" && error.module) {\n      const {\n        type,\n        compilation: {\n          moduleGraph\n        }\n      } = context;\n      /** @type {Set<Module>} */\n      const visitedModules = new Set();\n      const moduleTrace = [];\n      let current = error.module;\n      while (current) {\n        if (visitedModules.has(current)) break; // circular (technically impossible, but how knows)\n        visitedModules.add(current);\n        const origin = moduleGraph.getIssuer(current);\n        if (!origin) break;\n        moduleTrace.push({\n          origin,\n          module: current\n        });\n        current = origin;\n      }\n      object.moduleTrace = factory.create(`${type}.moduleTrace`, moduleTrace, context);\n    }\n  },\n  errorDetails: (object, error, {\n    type,\n    compilation,\n    cachedGetErrors,\n    cachedGetWarnings\n  }, {\n    errorDetails\n  }) => {\n    if (typeof error !== \"string\" && (errorDetails === true || type.endsWith(\".error\") && cachedGetErrors(compilation).length < 3)) {\n      object.details = error.details;\n    }\n  },\n  errorStack: (object, error) => {\n    if (typeof error !== \"string\") {\n      object.stack = error.stack;\n    }\n  }\n};\n\n/** @type {SimpleExtractors} */\nconst SIMPLE_EXTRACTORS = {\n  compilation: {\n    _: (object, compilation, context, options) => {\n      if (!context.makePathsRelative) {\n        context.makePathsRelative = makePathsRelative.bindContextCache(compilation.compiler.context, compilation.compiler.root);\n      }\n      if (!context.cachedGetErrors) {\n        const map = new WeakMap();\n        context.cachedGetErrors = compilation => map.get(compilation) ||\n        // eslint-disable-next-line no-sequences\n        (errors => (map.set(compilation, errors), errors))(compilation.getErrors());\n      }\n      if (!context.cachedGetWarnings) {\n        const map = new WeakMap();\n        context.cachedGetWarnings = compilation => map.get(compilation) ||\n        // eslint-disable-next-line no-sequences\n        (warnings => (map.set(compilation, warnings), warnings))(compilation.getWarnings());\n      }\n      if (compilation.name) {\n        object.name = compilation.name;\n      }\n      if (compilation.needAdditionalPass) {\n        object.needAdditionalPass = true;\n      }\n      const {\n        logging,\n        loggingDebug,\n        loggingTrace\n      } = options;\n      if (logging || loggingDebug && loggingDebug.length > 0) {\n        const util = require(\"util\");\n        object.logging = {};\n        let acceptedTypes;\n        let collapsedGroups = false;\n        switch (logging) {\n          case \"error\":\n            acceptedTypes = new Set([LogType.error]);\n            break;\n          case \"warn\":\n            acceptedTypes = new Set([LogType.error, LogType.warn]);\n            break;\n          case \"info\":\n            acceptedTypes = new Set([LogType.error, LogType.warn, LogType.info]);\n            break;\n          case \"log\":\n            acceptedTypes = new Set([LogType.error, LogType.warn, LogType.info, LogType.log, LogType.group, LogType.groupEnd, LogType.groupCollapsed, LogType.clear]);\n            break;\n          case \"verbose\":\n            acceptedTypes = new Set([LogType.error, LogType.warn, LogType.info, LogType.log, LogType.group, LogType.groupEnd, LogType.groupCollapsed, LogType.profile, LogType.profileEnd, LogType.time, LogType.status, LogType.clear]);\n            collapsedGroups = true;\n            break;\n          default:\n            acceptedTypes = new Set();\n            break;\n        }\n        const cachedMakePathsRelative = makePathsRelative.bindContextCache(options.context, compilation.compiler.root);\n        let depthInCollapsedGroup = 0;\n        for (const [origin, logEntries] of compilation.logging) {\n          const debugMode = loggingDebug.some(fn => fn(origin));\n          if (logging === false && !debugMode) continue;\n          /** @type {KnownStatsLoggingEntry[]} */\n          const groupStack = [];\n          /** @type {KnownStatsLoggingEntry[]} */\n          const rootList = [];\n          let currentList = rootList;\n          let processedLogEntries = 0;\n          for (const entry of logEntries) {\n            let type = entry.type;\n            if (!debugMode && !acceptedTypes.has(type)) continue;\n\n            // Expand groups in verbose and debug modes\n            if (type === LogType.groupCollapsed && (debugMode || collapsedGroups)) type = LogType.group;\n            if (depthInCollapsedGroup === 0) {\n              processedLogEntries++;\n            }\n            if (type === LogType.groupEnd) {\n              groupStack.pop();\n              currentList = groupStack.length > 0 ? (/** @type {KnownStatsLoggingEntry[]} */\n              groupStack[groupStack.length - 1].children) : rootList;\n              if (depthInCollapsedGroup > 0) depthInCollapsedGroup--;\n              continue;\n            }\n            let message;\n            if (entry.type === LogType.time) {\n              const [label, first, second] = /** @type {[string, number, number]} */\n              entry.args;\n              message = `${label}: ${first * 1000 + second / 1000000} ms`;\n            } else if (entry.args && entry.args.length > 0) {\n              message = util.format(entry.args[0], ...entry.args.slice(1));\n            }\n            /** @type {KnownStatsLoggingEntry} */\n            const newEntry = {\n              ...entry,\n              type,\n              message,\n              trace: loggingTrace ? entry.trace : undefined,\n              children: type === LogType.group || type === LogType.groupCollapsed ? [] : undefined\n            };\n            currentList.push(newEntry);\n            if (newEntry.children) {\n              groupStack.push(newEntry);\n              currentList = newEntry.children;\n              if (depthInCollapsedGroup > 0) {\n                depthInCollapsedGroup++;\n              } else if (type === LogType.groupCollapsed) {\n                depthInCollapsedGroup = 1;\n              }\n            }\n          }\n          let name = cachedMakePathsRelative(origin).replace(/\\|/g, \" \");\n          if (name in object.logging) {\n            let i = 1;\n            while (`${name}#${i}` in object.logging) {\n              i++;\n            }\n            name = `${name}#${i}`;\n          }\n          object.logging[name] = {\n            entries: rootList,\n            filteredEntries: logEntries.length - processedLogEntries,\n            debug: debugMode\n          };\n        }\n      }\n    },\n    hash: (object, compilation) => {\n      object.hash = /** @type {string} */compilation.hash;\n    },\n    version: object => {\n      object.version = require(\"../../package.json\").version;\n    },\n    env: (object, compilation, context, {\n      _env\n    }) => {\n      object.env = _env;\n    },\n    timings: (object, compilation) => {\n      object.time = /** @type {number} */compilation.endTime - (/** @type {number} */compilation.startTime);\n    },\n    builtAt: (object, compilation) => {\n      object.builtAt = /** @type {number} */compilation.endTime;\n    },\n    publicPath: (object, compilation) => {\n      object.publicPath = compilation.getPath(/** @type {TemplatePath} */\n      compilation.outputOptions.publicPath);\n    },\n    outputPath: (object, compilation) => {\n      object.outputPath = /** @type {string} */\n      compilation.outputOptions.path;\n    },\n    assets: (object, compilation, context, options, factory) => {\n      const {\n        type\n      } = context;\n      /** @type {Map<string, Chunk[]>} */\n      const compilationFileToChunks = new Map();\n      /** @type {Map<string, Chunk[]>} */\n      const compilationAuxiliaryFileToChunks = new Map();\n      for (const chunk of compilation.chunks) {\n        for (const file of chunk.files) {\n          let array = compilationFileToChunks.get(file);\n          if (array === undefined) {\n            array = [];\n            compilationFileToChunks.set(file, array);\n          }\n          array.push(chunk);\n        }\n        for (const file of chunk.auxiliaryFiles) {\n          let array = compilationAuxiliaryFileToChunks.get(file);\n          if (array === undefined) {\n            array = [];\n            compilationAuxiliaryFileToChunks.set(file, array);\n          }\n          array.push(chunk);\n        }\n      }\n      /** @type {Map<string, PreprocessedAsset>} */\n      const assetMap = new Map();\n      /** @type {Set<PreprocessedAsset>} */\n      const assets = new Set();\n      for (const asset of compilation.getAssets()) {\n        /** @type {PreprocessedAsset} */\n        const item = {\n          ...asset,\n          type: \"asset\",\n          related: undefined\n        };\n        assets.add(item);\n        assetMap.set(asset.name, item);\n      }\n      for (const item of assetMap.values()) {\n        const related = item.info.related;\n        if (!related) continue;\n        for (const type of Object.keys(related)) {\n          const relatedEntry = related[type];\n          const deps = Array.isArray(relatedEntry) ? relatedEntry : [relatedEntry];\n          for (const dep of deps) {\n            const depItem = assetMap.get(dep);\n            if (!depItem) continue;\n            assets.delete(depItem);\n            depItem.type = type;\n            item.related = item.related || [];\n            item.related.push(depItem);\n          }\n        }\n      }\n      object.assetsByChunkName = {};\n      for (const [file, chunks] of compilationFileToChunks) {\n        for (const chunk of chunks) {\n          const name = chunk.name;\n          if (!name) continue;\n          if (!Object.prototype.hasOwnProperty.call(object.assetsByChunkName, name)) {\n            object.assetsByChunkName[name] = [];\n          }\n          object.assetsByChunkName[name].push(file);\n        }\n      }\n      const groupedAssets = factory.create(`${type}.assets`, Array.from(assets), {\n        ...context,\n        compilationFileToChunks,\n        compilationAuxiliaryFileToChunks\n      });\n      const limited = spaceLimited(groupedAssets, /** @type {number} */options.assetsSpace);\n      object.assets = limited.children;\n      object.filteredAssets = limited.filteredChildren;\n    },\n    chunks: (object, compilation, context, options, factory) => {\n      const {\n        type\n      } = context;\n      object.chunks = factory.create(`${type}.chunks`, Array.from(compilation.chunks), context);\n    },\n    modules: (object, compilation, context, options, factory) => {\n      const {\n        type\n      } = context;\n      const array = Array.from(compilation.modules);\n      const groupedModules = factory.create(`${type}.modules`, array, context);\n      const limited = spaceLimited(groupedModules, options.modulesSpace);\n      object.modules = limited.children;\n      object.filteredModules = limited.filteredChildren;\n    },\n    entrypoints: (object, compilation, context, {\n      entrypoints,\n      chunkGroups,\n      chunkGroupAuxiliary,\n      chunkGroupChildren\n    }, factory) => {\n      const {\n        type\n      } = context;\n      const array = Array.from(compilation.entrypoints, ([key, value]) => ({\n        name: key,\n        chunkGroup: value\n      }));\n      if (entrypoints === \"auto\" && !chunkGroups) {\n        if (array.length > 5) return;\n        if (!chunkGroupChildren && array.every(({\n          chunkGroup\n        }) => {\n          if (chunkGroup.chunks.length !== 1) return false;\n          const chunk = chunkGroup.chunks[0];\n          return chunk.files.size === 1 && (!chunkGroupAuxiliary || chunk.auxiliaryFiles.size === 0);\n        })) {\n          return;\n        }\n      }\n      object.entrypoints = factory.create(`${type}.entrypoints`, array, context);\n    },\n    chunkGroups: (object, compilation, context, options, factory) => {\n      const {\n        type\n      } = context;\n      const array = Array.from(compilation.namedChunkGroups, ([key, value]) => ({\n        name: key,\n        chunkGroup: value\n      }));\n      object.namedChunkGroups = factory.create(`${type}.namedChunkGroups`, array, context);\n    },\n    errors: (object, compilation, context, options, factory) => {\n      const {\n        type,\n        cachedGetErrors\n      } = context;\n      const rawErrors = cachedGetErrors(compilation);\n      const factorizedErrors = factory.create(`${type}.errors`, cachedGetErrors(compilation), context);\n      let filtered = 0;\n      if (options.errorDetails === \"auto\" && rawErrors.length >= 3) {\n        filtered = rawErrors.map(e => typeof e !== \"string\" && e.details).filter(Boolean).length;\n      }\n      if (options.errorDetails === true || !Number.isFinite(options.errorsSpace)) {\n        object.errors = factorizedErrors;\n        if (filtered) object.filteredErrorDetailsCount = filtered;\n        return;\n      }\n      const [errors, filteredBySpace] = errorsSpaceLimit(factorizedErrors, /** @type {number} */\n      options.errorsSpace);\n      object.filteredErrorDetailsCount = filtered + filteredBySpace;\n      object.errors = errors;\n    },\n    errorsCount: (object, compilation, {\n      cachedGetErrors\n    }) => {\n      object.errorsCount = countWithChildren(compilation, c => cachedGetErrors(c));\n    },\n    warnings: (object, compilation, context, options, factory) => {\n      const {\n        type,\n        cachedGetWarnings\n      } = context;\n      const rawWarnings = factory.create(`${type}.warnings`, cachedGetWarnings(compilation), context);\n      let filtered = 0;\n      if (options.errorDetails === \"auto\") {\n        filtered = cachedGetWarnings(compilation).map(e => typeof e !== \"string\" && e.details).filter(Boolean).length;\n      }\n      if (options.errorDetails === true || !Number.isFinite(options.warningsSpace)) {\n        object.warnings = rawWarnings;\n        if (filtered) object.filteredWarningDetailsCount = filtered;\n        return;\n      }\n      const [warnings, filteredBySpace] = errorsSpaceLimit(rawWarnings, /** @type {number} */\n      options.warningsSpace);\n      object.filteredWarningDetailsCount = filtered + filteredBySpace;\n      object.warnings = warnings;\n    },\n    warningsCount: (object, compilation, context, {\n      warningsFilter\n    }, factory) => {\n      const {\n        type,\n        cachedGetWarnings\n      } = context;\n      object.warningsCount = countWithChildren(compilation, (c, childType) => {\n        if (!warningsFilter && /** @type {((warning: StatsError, textValue: string) => boolean)[]} */\n        warningsFilter.length === 0) return cachedGetWarnings(c);\n        return factory.create(`${type}${childType}.warnings`, cachedGetWarnings(c), context).filter(\n        /**\n         * @param {TODO} warning warning\n         * @returns {boolean} result\n         */\n        warning => {\n          const warningString = Object.keys(warning).map(key => `${warning[(/** @type {keyof KnownStatsError} */key)]}`).join(\"\\n\");\n          return !warningsFilter.some(filter => filter(warning, warningString));\n        });\n      });\n    },\n    children: (object, compilation, context, options, factory) => {\n      const {\n        type\n      } = context;\n      object.children = factory.create(`${type}.children`, compilation.children, context);\n    }\n  },\n  asset: {\n    _: (object, asset, context, options, factory) => {\n      const {\n        compilation\n      } = context;\n      object.type = asset.type;\n      object.name = asset.name;\n      object.size = asset.source.size();\n      object.emitted = compilation.emittedAssets.has(asset.name);\n      object.comparedForEmit = compilation.comparedForEmitAssets.has(asset.name);\n      const cached = !object.emitted && !object.comparedForEmit;\n      object.cached = cached;\n      object.info = asset.info;\n      if (!cached || options.cachedAssets) {\n        Object.assign(object, factory.create(`${context.type}$visible`, asset, context));\n      }\n    }\n  },\n  asset$visible: {\n    _: (object, asset, {\n      compilation,\n      compilationFileToChunks,\n      compilationAuxiliaryFileToChunks\n    }) => {\n      const chunks = compilationFileToChunks.get(asset.name) || [];\n      const auxiliaryChunks = compilationAuxiliaryFileToChunks.get(asset.name) || [];\n      object.chunkNames = uniqueOrderedArray(chunks, c => c.name ? [c.name] : [], compareIds);\n      object.chunkIdHints = uniqueOrderedArray(chunks, c => Array.from(c.idNameHints), compareIds);\n      object.auxiliaryChunkNames = uniqueOrderedArray(auxiliaryChunks, c => c.name ? [c.name] : [], compareIds);\n      object.auxiliaryChunkIdHints = uniqueOrderedArray(auxiliaryChunks, c => Array.from(c.idNameHints), compareIds);\n      object.filteredRelated = asset.related ? asset.related.length : undefined;\n    },\n    relatedAssets: (object, asset, context, options, factory) => {\n      const {\n        type\n      } = context;\n      object.related = factory.create(`${type.slice(0, -8)}.related`, asset.related || [], context);\n      object.filteredRelated = asset.related ? asset.related.length - /** @type {StatsAsset[]} */object.related.length : undefined;\n    },\n    ids: (object, asset, {\n      compilationFileToChunks,\n      compilationAuxiliaryFileToChunks\n    }) => {\n      const chunks = compilationFileToChunks.get(asset.name) || [];\n      const auxiliaryChunks = compilationAuxiliaryFileToChunks.get(asset.name) || [];\n      object.chunks = uniqueOrderedArray(chunks, c => (/** @type {ChunkId[]} */c.ids), compareIds);\n      object.auxiliaryChunks = uniqueOrderedArray(auxiliaryChunks, c => (/** @type {ChunkId[]} */c.ids), compareIds);\n    },\n    performance: (object, asset) => {\n      object.isOverSizeLimit = SizeLimitsPlugin.isOverSizeLimit(asset.source);\n    }\n  },\n  chunkGroup: {\n    _: (object, {\n      name,\n      chunkGroup\n    }, {\n      compilation,\n      compilation: {\n        moduleGraph,\n        chunkGraph\n      }\n    }, {\n      ids,\n      chunkGroupAuxiliary,\n      chunkGroupChildren,\n      chunkGroupMaxAssets\n    }) => {\n      const children = chunkGroupChildren && chunkGroup.getChildrenByOrders(moduleGraph, chunkGraph);\n      /**\n       * @param {string} name Name\n       * @returns {{ name: string, size: number }} Asset object\n       */\n      const toAsset = name => {\n        const asset = compilation.getAsset(name);\n        return {\n          name,\n          size: (/** @type {number} */asset ? asset.info.size : -1)\n        };\n      };\n      /** @type {(total: number, asset: { size: number }) => number} */\n      const sizeReducer = (total, {\n        size\n      }) => total + size;\n      const assets = uniqueArray(chunkGroup.chunks, c => c.files).map(toAsset);\n      const auxiliaryAssets = uniqueOrderedArray(chunkGroup.chunks, c => c.auxiliaryFiles, compareIds).map(toAsset);\n      const assetsSize = assets.reduce(sizeReducer, 0);\n      const auxiliaryAssetsSize = auxiliaryAssets.reduce(sizeReducer, 0);\n      /** @type {KnownStatsChunkGroup} */\n      const statsChunkGroup = {\n        name,\n        chunks: ids ? (/** @type {ChunkId[]} */chunkGroup.chunks.map(c => c.id)) : undefined,\n        assets: assets.length <= chunkGroupMaxAssets ? assets : undefined,\n        filteredAssets: assets.length <= chunkGroupMaxAssets ? 0 : assets.length,\n        assetsSize,\n        auxiliaryAssets: chunkGroupAuxiliary && auxiliaryAssets.length <= chunkGroupMaxAssets ? auxiliaryAssets : undefined,\n        filteredAuxiliaryAssets: chunkGroupAuxiliary && auxiliaryAssets.length <= chunkGroupMaxAssets ? 0 : auxiliaryAssets.length,\n        auxiliaryAssetsSize,\n        children: children ? mapObject(children, groups => groups.map(group => {\n          const assets = uniqueArray(group.chunks, c => c.files).map(toAsset);\n          const auxiliaryAssets = uniqueOrderedArray(group.chunks, c => c.auxiliaryFiles, compareIds).map(toAsset);\n\n          /** @type {KnownStatsChunkGroup} */\n          const childStatsChunkGroup = {\n            name: group.name,\n            chunks: ids ? (/** @type {ChunkId[]} */\n            group.chunks.map(c => c.id)) : undefined,\n            assets: assets.length <= chunkGroupMaxAssets ? assets : undefined,\n            filteredAssets: assets.length <= chunkGroupMaxAssets ? 0 : assets.length,\n            auxiliaryAssets: chunkGroupAuxiliary && auxiliaryAssets.length <= chunkGroupMaxAssets ? auxiliaryAssets : undefined,\n            filteredAuxiliaryAssets: chunkGroupAuxiliary && auxiliaryAssets.length <= chunkGroupMaxAssets ? 0 : auxiliaryAssets.length\n          };\n          return childStatsChunkGroup;\n        })) : undefined,\n        childAssets: children ? mapObject(children, groups => {\n          /** @type {Set<string>} */\n          const set = new Set();\n          for (const group of groups) {\n            for (const chunk of group.chunks) {\n              for (const asset of chunk.files) {\n                set.add(asset);\n              }\n            }\n          }\n          return Array.from(set);\n        }) : undefined\n      };\n      Object.assign(object, statsChunkGroup);\n    },\n    performance: (object, {\n      chunkGroup\n    }) => {\n      object.isOverSizeLimit = SizeLimitsPlugin.isOverSizeLimit(chunkGroup);\n    }\n  },\n  module: {\n    _: (object, module, context, options, factory) => {\n      const {\n        type\n      } = context;\n      const compilation = /** @type {Compilation} */context.compilation;\n      const built = compilation.builtModules.has(module);\n      const codeGenerated = compilation.codeGeneratedModules.has(module);\n      const buildTimeExecuted = compilation.buildTimeExecutedModules.has(module);\n      /** @type {{[x: string]: number}} */\n      const sizes = {};\n      for (const sourceType of module.getSourceTypes()) {\n        sizes[sourceType] = module.size(sourceType);\n      }\n      /** @type {KnownStatsModule} */\n      const statsModule = {\n        type: \"module\",\n        moduleType: module.type,\n        layer: module.layer,\n        size: module.size(),\n        sizes,\n        built,\n        codeGenerated,\n        buildTimeExecuted,\n        cached: !built && !codeGenerated\n      };\n      Object.assign(object, statsModule);\n      if (built || codeGenerated || options.cachedModules) {\n        Object.assign(object, factory.create(`${type}$visible`, module, context));\n      }\n    }\n  },\n  module$visible: {\n    _: (object, module, context, {\n      requestShortener\n    }, factory) => {\n      const {\n        type,\n        rootModules\n      } = context;\n      const compilation = /** @type {Compilation} */context.compilation;\n      const {\n        moduleGraph\n      } = compilation;\n      /** @type {Module[]} */\n      const path = [];\n      const issuer = moduleGraph.getIssuer(module);\n      let current = issuer;\n      while (current) {\n        path.push(current);\n        current = moduleGraph.getIssuer(current);\n      }\n      path.reverse();\n      const profile = moduleGraph.getProfile(module);\n      const errors = module.getErrors();\n      const errorsCount = errors !== undefined ? countIterable(errors) : 0;\n      const warnings = module.getWarnings();\n      const warningsCount = warnings !== undefined ? countIterable(warnings) : 0;\n      /** @type {{[x: string]: number}} */\n      const sizes = {};\n      for (const sourceType of module.getSourceTypes()) {\n        sizes[sourceType] = module.size(sourceType);\n      }\n      /** @type {KnownStatsModule} */\n      const statsModule = {\n        identifier: module.identifier(),\n        name: module.readableIdentifier(requestShortener),\n        nameForCondition: module.nameForCondition(),\n        index: (/** @type {number} */moduleGraph.getPreOrderIndex(module)),\n        preOrderIndex: (/** @type {number} */\n        moduleGraph.getPreOrderIndex(module)),\n        index2: (/** @type {number} */moduleGraph.getPostOrderIndex(module)),\n        postOrderIndex: (/** @type {number} */\n        moduleGraph.getPostOrderIndex(module)),\n        cacheable: /** @type {BuildInfo} */module.buildInfo.cacheable,\n        optional: module.isOptional(moduleGraph),\n        orphan: !type.endsWith(\"module.modules[].module$visible\") && compilation.chunkGraph.getNumberOfModuleChunks(module) === 0,\n        dependent: rootModules ? !rootModules.has(module) : undefined,\n        issuer: issuer && issuer.identifier(),\n        issuerName: issuer && issuer.readableIdentifier(requestShortener),\n        issuerPath: issuer && factory.create(`${type.slice(0, -8)}.issuerPath`, path, context),\n        failed: errorsCount > 0,\n        errors: errorsCount,\n        warnings: warningsCount\n      };\n      Object.assign(object, statsModule);\n      if (profile) {\n        object.profile = factory.create(`${type.slice(0, -8)}.profile`, profile, context);\n      }\n    },\n    ids: (object, module, {\n      compilation: {\n        chunkGraph,\n        moduleGraph\n      }\n    }) => {\n      object.id = /** @type {ModuleId} */chunkGraph.getModuleId(module);\n      const issuer = moduleGraph.getIssuer(module);\n      object.issuerId = issuer && chunkGraph.getModuleId(issuer);\n      object.chunks = /** @type {ChunkId[]} */\n\n      Array.from(chunkGraph.getOrderedModuleChunksIterable(module, compareChunksById), chunk => chunk.id);\n    },\n    moduleAssets: (object, module) => {\n      object.assets = /** @type {BuildInfo} */module.buildInfo.assets ? Object.keys(/** @type {BuildInfo} */module.buildInfo.assets) : [];\n    },\n    reasons: (object, module, context, options, factory) => {\n      const {\n        type,\n        compilation: {\n          moduleGraph\n        }\n      } = context;\n      const groupsReasons = factory.create(`${type.slice(0, -8)}.reasons`, Array.from(moduleGraph.getIncomingConnections(module)), context);\n      const limited = spaceLimited(groupsReasons, /** @type {number} */\n      options.reasonsSpace);\n      object.reasons = limited.children;\n      object.filteredReasons = limited.filteredChildren;\n    },\n    usedExports: (object, module, {\n      runtime,\n      compilation: {\n        moduleGraph\n      }\n    }) => {\n      const usedExports = moduleGraph.getUsedExports(module, runtime);\n      if (usedExports === null) {\n        object.usedExports = null;\n      } else if (typeof usedExports === \"boolean\") {\n        object.usedExports = usedExports;\n      } else {\n        object.usedExports = Array.from(usedExports);\n      }\n    },\n    providedExports: (object, module, {\n      compilation: {\n        moduleGraph\n      }\n    }) => {\n      const providedExports = moduleGraph.getProvidedExports(module);\n      object.providedExports = Array.isArray(providedExports) ? providedExports : null;\n    },\n    optimizationBailout: (object, module, {\n      compilation: {\n        moduleGraph\n      }\n    }, {\n      requestShortener\n    }) => {\n      object.optimizationBailout = moduleGraph.getOptimizationBailout(module).map(item => {\n        if (typeof item === \"function\") return item(requestShortener);\n        return item;\n      });\n    },\n    depth: (object, module, {\n      compilation: {\n        moduleGraph\n      }\n    }) => {\n      object.depth = moduleGraph.getDepth(module);\n    },\n    nestedModules: (object, module, context, options, factory) => {\n      const {\n        type\n      } = context;\n      const innerModules = /** @type {Module & { modules?: Module[] }} */module.modules;\n      if (Array.isArray(innerModules)) {\n        const groupedModules = factory.create(`${type.slice(0, -8)}.modules`, innerModules, context);\n        const limited = spaceLimited(groupedModules, options.nestedModulesSpace);\n        object.modules = limited.children;\n        object.filteredModules = limited.filteredChildren;\n      }\n    },\n    source: (object, module) => {\n      const originalSource = module.originalSource();\n      if (originalSource) {\n        object.source = originalSource.source();\n      }\n    }\n  },\n  profile: {\n    _: (object, profile) => {\n      /** @type {KnownStatsProfile} */\n      const statsProfile = {\n        total: profile.factory + profile.restoring + profile.integration + profile.building + profile.storing,\n        resolving: profile.factory,\n        restoring: profile.restoring,\n        building: profile.building,\n        integration: profile.integration,\n        storing: profile.storing,\n        additionalResolving: profile.additionalFactories,\n        additionalIntegration: profile.additionalIntegration,\n        // TODO remove this in webpack 6\n        factory: profile.factory,\n        // TODO remove this in webpack 6\n        dependencies: profile.additionalFactories\n      };\n      Object.assign(object, statsProfile);\n    }\n  },\n  moduleIssuer: {\n    _: (object, module, context, {\n      requestShortener\n    }, factory) => {\n      const {\n        type\n      } = context;\n      const compilation = /** @type {Compilation} */context.compilation;\n      const {\n        moduleGraph\n      } = compilation;\n      const profile = moduleGraph.getProfile(module);\n      /** @type {Partial<KnownStatsModuleIssuer>} */\n      const statsModuleIssuer = {\n        identifier: module.identifier(),\n        name: module.readableIdentifier(requestShortener)\n      };\n      Object.assign(object, statsModuleIssuer);\n      if (profile) {\n        object.profile = factory.create(`${type}.profile`, profile, context);\n      }\n    },\n    ids: (object, module, {\n      compilation: {\n        chunkGraph\n      }\n    }) => {\n      object.id = /** @type {ModuleId} */chunkGraph.getModuleId(module);\n    }\n  },\n  moduleReason: {\n    _: (object, reason, {\n      runtime\n    }, {\n      requestShortener\n    }) => {\n      const dep = reason.dependency;\n      const moduleDep = dep && dep instanceof ModuleDependency ? dep : undefined;\n      /** @type {KnownStatsModuleReason} */\n      const statsModuleReason = {\n        moduleIdentifier: reason.originModule ? reason.originModule.identifier() : null,\n        module: reason.originModule ? reason.originModule.readableIdentifier(requestShortener) : null,\n        moduleName: reason.originModule ? reason.originModule.readableIdentifier(requestShortener) : null,\n        resolvedModuleIdentifier: reason.resolvedOriginModule ? reason.resolvedOriginModule.identifier() : null,\n        resolvedModule: reason.resolvedOriginModule ? reason.resolvedOriginModule.readableIdentifier(requestShortener) : null,\n        type: reason.dependency ? reason.dependency.type : null,\n        active: reason.isActive(runtime),\n        explanation: reason.explanation,\n        userRequest: moduleDep && moduleDep.userRequest || null\n      };\n      Object.assign(object, statsModuleReason);\n      if (reason.dependency) {\n        const locInfo = formatLocation(reason.dependency.loc);\n        if (locInfo) {\n          object.loc = locInfo;\n        }\n      }\n    },\n    ids: (object, reason, {\n      compilation: {\n        chunkGraph\n      }\n    }) => {\n      object.moduleId = reason.originModule ? chunkGraph.getModuleId(reason.originModule) : null;\n      object.resolvedModuleId = reason.resolvedOriginModule ? chunkGraph.getModuleId(reason.resolvedOriginModule) : null;\n    }\n  },\n  chunk: {\n    _: (object, chunk, {\n      makePathsRelative,\n      compilation: {\n        chunkGraph\n      }\n    }) => {\n      const childIdByOrder = chunk.getChildIdsByOrders(chunkGraph);\n\n      /** @type {KnownStatsChunk} */\n      const statsChunk = {\n        rendered: chunk.rendered,\n        initial: chunk.canBeInitial(),\n        entry: chunk.hasRuntime(),\n        recorded: AggressiveSplittingPlugin.wasChunkRecorded(chunk),\n        reason: chunk.chunkReason,\n        size: chunkGraph.getChunkModulesSize(chunk),\n        sizes: chunkGraph.getChunkModulesSizes(chunk),\n        names: chunk.name ? [chunk.name] : [],\n        idHints: Array.from(chunk.idNameHints),\n        runtime: chunk.runtime === undefined ? undefined : typeof chunk.runtime === \"string\" ? [makePathsRelative(chunk.runtime)] : Array.from(chunk.runtime.sort(), makePathsRelative),\n        files: Array.from(chunk.files),\n        auxiliaryFiles: Array.from(chunk.auxiliaryFiles).sort(compareIds),\n        hash: (/** @type {string} */chunk.renderedHash),\n        childrenByOrder: childIdByOrder\n      };\n      Object.assign(object, statsChunk);\n    },\n    ids: (object, chunk) => {\n      object.id = /** @type {ChunkId} */chunk.id;\n    },\n    chunkRelations: (object, chunk, {\n      compilation: {\n        chunkGraph\n      }\n    }) => {\n      /** @type {Set<string|number>} */\n      const parents = new Set();\n      /** @type {Set<string|number>} */\n      const children = new Set();\n      /** @type {Set<string|number>} */\n      const siblings = new Set();\n      for (const chunkGroup of chunk.groupsIterable) {\n        for (const parentGroup of chunkGroup.parentsIterable) {\n          for (const chunk of parentGroup.chunks) {\n            parents.add(/** @type {ChunkId} */chunk.id);\n          }\n        }\n        for (const childGroup of chunkGroup.childrenIterable) {\n          for (const chunk of childGroup.chunks) {\n            children.add(/** @type {ChunkId} */chunk.id);\n          }\n        }\n        for (const sibling of chunkGroup.chunks) {\n          if (sibling !== chunk) siblings.add(/** @type {ChunkId} */sibling.id);\n        }\n      }\n      object.siblings = Array.from(siblings).sort(compareIds);\n      object.parents = Array.from(parents).sort(compareIds);\n      object.children = Array.from(children).sort(compareIds);\n    },\n    chunkModules: (object, chunk, context, options, factory) => {\n      const {\n        type,\n        compilation: {\n          chunkGraph\n        }\n      } = context;\n      const array = chunkGraph.getChunkModules(chunk);\n      const groupedModules = factory.create(`${type}.modules`, array, {\n        ...context,\n        runtime: chunk.runtime,\n        rootModules: new Set(chunkGraph.getChunkRootModules(chunk))\n      });\n      const limited = spaceLimited(groupedModules, options.chunkModulesSpace);\n      object.modules = limited.children;\n      object.filteredModules = limited.filteredChildren;\n    },\n    chunkOrigins: (object, chunk, context, options, factory) => {\n      const {\n        type,\n        compilation: {\n          chunkGraph\n        }\n      } = context;\n      /** @type {Set<string>} */\n      const originsKeySet = new Set();\n      const origins = [];\n      for (const g of chunk.groupsIterable) {\n        origins.push(...g.origins);\n      }\n      const array = origins.filter(origin => {\n        const key = [origin.module ? chunkGraph.getModuleId(origin.module) : undefined, formatLocation(origin.loc), origin.request].join();\n        if (originsKeySet.has(key)) return false;\n        originsKeySet.add(key);\n        return true;\n      });\n      object.origins = factory.create(`${type}.origins`, array, context);\n    }\n  },\n  chunkOrigin: {\n    _: (object, origin, context, {\n      requestShortener\n    }) => {\n      /** @type {KnownStatsChunkOrigin} */\n      const statsChunkOrigin = {\n        module: origin.module ? origin.module.identifier() : \"\",\n        moduleIdentifier: origin.module ? origin.module.identifier() : \"\",\n        moduleName: origin.module ? origin.module.readableIdentifier(requestShortener) : \"\",\n        loc: formatLocation(origin.loc),\n        request: origin.request\n      };\n      Object.assign(object, statsChunkOrigin);\n    },\n    ids: (object, origin, {\n      compilation: {\n        chunkGraph\n      }\n    }) => {\n      object.moduleId = origin.module ? (/** @type {ModuleId} */chunkGraph.getModuleId(origin.module)) : undefined;\n    }\n  },\n  error: EXTRACT_ERROR,\n  warning: EXTRACT_ERROR,\n  moduleTraceItem: {\n    _: (object, {\n      origin,\n      module\n    }, context, {\n      requestShortener\n    }, factory) => {\n      const {\n        type,\n        compilation: {\n          moduleGraph\n        }\n      } = context;\n      object.originIdentifier = origin.identifier();\n      object.originName = origin.readableIdentifier(requestShortener);\n      object.moduleIdentifier = module.identifier();\n      object.moduleName = module.readableIdentifier(requestShortener);\n      const dependencies = Array.from(moduleGraph.getIncomingConnections(module)).filter(c => c.resolvedOriginModule === origin && c.dependency).map(c => c.dependency);\n      object.dependencies = factory.create(`${type}.dependencies`, Array.from(new Set(dependencies)), context);\n    },\n    ids: (object, {\n      origin,\n      module\n    }, {\n      compilation: {\n        chunkGraph\n      }\n    }) => {\n      object.originId = /** @type {ModuleId} */\n      chunkGraph.getModuleId(origin);\n      object.moduleId = /** @type {ModuleId} */\n      chunkGraph.getModuleId(module);\n    }\n  },\n  moduleTraceDependency: {\n    _: (object, dependency) => {\n      object.loc = formatLocation(dependency.loc);\n    }\n  }\n};\n\n/** @type {Record<string, Record<string, (thing: any, context: StatsFactoryContext, options: NormalizedStatsOptions) => boolean | undefined>>} */\nconst FILTER = {\n  \"module.reasons\": {\n    \"!orphanModules\": (reason, {\n      compilation: {\n        chunkGraph\n      }\n    }) => {\n      if (reason.originModule && chunkGraph.getNumberOfModuleChunks(reason.originModule) === 0) {\n        return false;\n      }\n    }\n  }\n};\n\n/** @type {Record<string, Record<string, (thing: KnownStatsError, context: StatsFactoryContext, options: NormalizedStatsOptions) => boolean | undefined>>} */\nconst FILTER_RESULTS = {\n  \"compilation.warnings\": {\n    warningsFilter: util.deprecate((warning, context, {\n      warningsFilter\n    }) => {\n      const warningString = Object.keys(warning).map(key => `${warning[(/** @type {keyof KnownStatsError} */key)]}`).join(\"\\n\");\n      return !warningsFilter.some(filter => filter(warning, warningString));\n    }, \"config.stats.warningsFilter is deprecated in favor of config.ignoreWarnings\", \"DEP_WEBPACK_STATS_WARNINGS_FILTER\")\n  }\n};\n\n/** @type {Record<string, (comparators: Function[], context: StatsFactoryContext) => void>} */\nconst MODULES_SORTER = {\n  _: (comparators, {\n    compilation: {\n      moduleGraph\n    }\n  }) => {\n    comparators.push(compareSelect(\n    /**\n     * @param {Module} m module\n     * @returns {number | null} depth\n     */\n    m => moduleGraph.getDepth(m), compareNumbers), compareSelect(\n    /**\n     * @param {Module} m module\n     * @returns {number | null} index\n     */\n    m => moduleGraph.getPreOrderIndex(m), compareNumbers), compareSelect(\n    /**\n     * @param {Module} m module\n     * @returns {string} identifier\n     */\n    m => m.identifier(), compareIds));\n  }\n};\n\n/** @type {Record<string, Record<string, (comparators: Function[], context: StatsFactoryContext) => void>>} */\nconst SORTERS = {\n  \"compilation.chunks\": {\n    _: comparators => {\n      comparators.push(compareSelect(c => c.id, compareIds));\n    }\n  },\n  \"compilation.modules\": MODULES_SORTER,\n  \"chunk.rootModules\": MODULES_SORTER,\n  \"chunk.modules\": MODULES_SORTER,\n  \"module.modules\": MODULES_SORTER,\n  \"module.reasons\": {\n    _: (comparators, {\n      compilation: {\n        chunkGraph\n      }\n    }) => {\n      comparators.push(compareSelect(x => x.originModule, compareModulesByIdentifier));\n      comparators.push(compareSelect(x => x.resolvedOriginModule, compareModulesByIdentifier));\n      comparators.push(compareSelect(x => x.dependency, concatComparators(compareSelect(\n      /**\n       * @param {Dependency} x dependency\n       * @returns {DependencyLocation} location\n       */\n      x => x.loc, compareLocations), compareSelect(x => x.type, compareIds))));\n    }\n  },\n  \"chunk.origins\": {\n    _: (comparators, {\n      compilation: {\n        chunkGraph\n      }\n    }) => {\n      comparators.push(compareSelect(origin => origin.module ? chunkGraph.getModuleId(origin.module) : undefined, compareIds), compareSelect(origin => formatLocation(origin.loc), compareIds), compareSelect(origin => origin.request, compareIds));\n    }\n  }\n};\n\n/**\n * @template T\n * @typedef {T & { children: Children<T>[] | undefined, filteredChildren?: number }} Children\n */\n\n/**\n * @template T\n * @param {Children<T>} item item\n * @returns {number} item size\n */\nconst getItemSize = item =>\n// Each item takes 1 line\n// + the size of the children\n// + 1 extra line when it has children and filteredChildren\n!item.children ? 1 : item.filteredChildren ? 2 + getTotalSize(item.children) : 1 + getTotalSize(item.children);\n\n/**\n * @template T\n * @param {Children<T>[]} children children\n * @returns {number} total size\n */\nconst getTotalSize = children => {\n  let size = 0;\n  for (const child of children) {\n    size += getItemSize(child);\n  }\n  return size;\n};\n\n/**\n * @template T\n * @param {Children<T>[]} children children\n * @returns {number} total items\n */\nconst getTotalItems = children => {\n  let count = 0;\n  for (const child of children) {\n    if (!child.children && !child.filteredChildren) {\n      count++;\n    } else {\n      if (child.children) count += getTotalItems(child.children);\n      if (child.filteredChildren) count += child.filteredChildren;\n    }\n  }\n  return count;\n};\n\n/**\n * @template T\n * @param {Children<T>[]} children children\n * @returns {Children<T>[]} collapsed children\n */\nconst collapse = children => {\n  // After collapse each child must take exactly one line\n  const newChildren = [];\n  for (const child of children) {\n    if (child.children) {\n      let filteredChildren = child.filteredChildren || 0;\n      filteredChildren += getTotalItems(child.children);\n      newChildren.push({\n        ...child,\n        children: undefined,\n        filteredChildren\n      });\n    } else {\n      newChildren.push(child);\n    }\n  }\n  return newChildren;\n};\n\n/**\n * @template T\n * @param {Children<T>[]} itemsAndGroups item and groups\n * @param {number} max max\n * @param {boolean=} filteredChildrenLineReserved filtered children line reserved\n * @returns {Children<T>} result\n */\nconst spaceLimited = (itemsAndGroups, max, filteredChildrenLineReserved = false) => {\n  if (max < 1) {\n    return /** @type {Children<T>} */{\n      children: undefined,\n      filteredChildren: getTotalItems(itemsAndGroups)\n    };\n  }\n  /** @type {Children<T>[] | undefined} */\n  let children;\n  /** @type {number | undefined} */\n  let filteredChildren;\n  // This are the groups, which take 1+ lines each\n  /** @type {Children<T>[] | undefined} */\n  const groups = [];\n  // The sizes of the groups are stored in groupSizes\n  /** @type {number[]} */\n  const groupSizes = [];\n  // This are the items, which take 1 line each\n  const items = [];\n  // The total of group sizes\n  let groupsSize = 0;\n  for (const itemOrGroup of itemsAndGroups) {\n    // is item\n    if (!itemOrGroup.children && !itemOrGroup.filteredChildren) {\n      items.push(itemOrGroup);\n    } else {\n      groups.push(itemOrGroup);\n      const size = getItemSize(itemOrGroup);\n      groupSizes.push(size);\n      groupsSize += size;\n    }\n  }\n  if (groupsSize + items.length <= max) {\n    // The total size in the current state fits into the max\n    // keep all\n    children = groups.length > 0 ? groups.concat(items) : items;\n  } else if (groups.length === 0) {\n    // slice items to max\n    // inner space marks that lines for filteredChildren already reserved\n    const limit = max - (filteredChildrenLineReserved ? 0 : 1);\n    filteredChildren = items.length - limit;\n    items.length = limit;\n    children = items;\n  } else {\n    // limit is the size when all groups are collapsed\n    const limit = groups.length + (filteredChildrenLineReserved || items.length === 0 ? 0 : 1);\n    if (limit < max) {\n      // calculate how much we are over the size limit\n      // this allows to approach the limit faster\n      let oversize;\n      // If each group would take 1 line the total would be below the maximum\n      // collapse some groups, keep items\n      while ((oversize = groupsSize + items.length + (filteredChildren && !filteredChildrenLineReserved ? 1 : 0) - max) > 0) {\n        // Find the maximum group and process only this one\n        const maxGroupSize = Math.max(...groupSizes);\n        if (maxGroupSize < items.length) {\n          filteredChildren = items.length;\n          items.length = 0;\n          continue;\n        }\n        for (let i = 0; i < groups.length; i++) {\n          if (groupSizes[i] === maxGroupSize) {\n            const group = groups[i];\n            // run this algorithm recursively and limit the size of the children to\n            // current size - oversize / number of groups\n            // So it should always end up being smaller\n            const headerSize = group.filteredChildren ? 2 : 1;\n            const limited = spaceLimited(/** @type {Children<T>} */group.children, maxGroupSize -\n            // we should use ceil to always feet in max\n            Math.ceil(oversize / groups.length) -\n            // we substitute size of group head\n            headerSize, headerSize === 2);\n            groups[i] = {\n              ...group,\n              children: limited.children,\n              filteredChildren: limited.filteredChildren ? (group.filteredChildren || 0) + limited.filteredChildren : group.filteredChildren\n            };\n            const newSize = getItemSize(groups[i]);\n            groupsSize -= maxGroupSize - newSize;\n            groupSizes[i] = newSize;\n            break;\n          }\n        }\n      }\n      children = groups.concat(items);\n    } else if (limit === max) {\n      // If we have only enough space to show one line per group and one line for the filtered items\n      // collapse all groups and items\n      children = collapse(groups);\n      filteredChildren = items.length;\n    } else {\n      // If we have no space\n      // collapse complete group\n      filteredChildren = getTotalItems(itemsAndGroups);\n    }\n  }\n  return /** @type {Children<T>} */{\n    children,\n    filteredChildren\n  };\n};\n\n/**\n * @param {StatsError[]} errors errors\n * @param {number} max max\n * @returns {[StatsError[], number]} error space limit\n */\nconst errorsSpaceLimit = (errors, max) => {\n  let filtered = 0;\n  // Can not fit into limit\n  // print only messages\n  if (errors.length + 1 >= max) return [errors.map(error => {\n    if (typeof error === \"string\" || !error.details) return error;\n    filtered++;\n    return {\n      ...error,\n      details: \"\"\n    };\n  }), filtered];\n  let fullLength = errors.length;\n  let result = errors;\n  let i = 0;\n  for (; i < errors.length; i++) {\n    const error = errors[i];\n    if (typeof error !== \"string\" && error.details) {\n      const splitted = error.details.split(\"\\n\");\n      const len = splitted.length;\n      fullLength += len;\n      if (fullLength > max) {\n        result = i > 0 ? errors.slice(0, i) : [];\n        const overLimit = fullLength - max + 1;\n        const error = errors[i++];\n        result.push({\n          ...error,\n          details: error.details.split(\"\\n\").slice(0, -overLimit).join(\"\\n\"),\n          filteredDetails: overLimit\n        });\n        filtered = errors.length - i;\n        for (; i < errors.length; i++) {\n          const error = errors[i];\n          if (typeof error === \"string\" || !error.details) result.push(error);\n          result.push({\n            ...error,\n            details: \"\"\n          });\n        }\n        break;\n      } else if (fullLength === max) {\n        result = errors.slice(0, ++i);\n        filtered = errors.length - i;\n        for (; i < errors.length; i++) {\n          const error = errors[i];\n          if (typeof error === \"string\" || !error.details) result.push(error);\n          result.push({\n            ...error,\n            details: \"\"\n          });\n        }\n        break;\n      }\n    }\n  }\n  return [result, filtered];\n};\n\n/**\n * @template {{ size: number }} T\n * @template {{ size: number }} R\n * @param {(R | T)[]} children children\n * @param {T[]} assets assets\n * @returns {{ size: number }} asset size\n */\nconst assetGroup = (children, assets) => {\n  let size = 0;\n  for (const asset of children) {\n    size += asset.size;\n  }\n  return {\n    size\n  };\n};\n\n/**\n * @template {{ size: number, sizes: Record<string, number> }} T\n * @param {Children<T>[]} children children\n * @param {KnownStatsModule[]} modules modules\n * @returns {{ size: number, sizes: Record<string, number>}} size and sizes\n */\nconst moduleGroup = (children, modules) => {\n  let size = 0;\n  /** @type {Record<string, number>} */\n  const sizes = {};\n  for (const module of children) {\n    size += module.size;\n    for (const key of Object.keys(module.sizes)) {\n      sizes[key] = (sizes[key] || 0) + module.sizes[key];\n    }\n  }\n  return {\n    size,\n    sizes\n  };\n};\n\n/**\n * @template {{ active: boolean }} T\n * @param {Children<T>[]} children children\n * @param {KnownStatsModuleReason[]} reasons reasons\n * @returns {{ active: boolean }} reason group\n */\nconst reasonGroup = (children, reasons) => {\n  let active = false;\n  for (const reason of children) {\n    active = active || reason.active;\n  }\n  return {\n    active\n  };\n};\nconst GROUP_EXTENSION_REGEXP = /(\\.[^.]+?)(?:\\?|(?: \\+ \\d+ modules?)?$)/;\nconst GROUP_PATH_REGEXP = /(.+)[/\\\\][^/\\\\]+?(?:\\?|(?: \\+ \\d+ modules?)?$)/;\n\n/** @typedef {Record<string, (groupConfigs: GroupConfig<KnownStatsAsset, TODO>[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>} AssetsGroupers */\n\n/** @type {AssetsGroupers} */\nconst ASSETS_GROUPERS = {\n  _: (groupConfigs, context, options) => {\n    /**\n     * @param {keyof KnownStatsAsset} name name\n     * @param {boolean=} exclude need exclude?\n     */\n    const groupByFlag = (name, exclude) => {\n      groupConfigs.push({\n        getKeys: asset => asset[name] ? [\"1\"] : undefined,\n        getOptions: () => ({\n          groupChildren: !exclude,\n          force: exclude\n        }),\n        createGroup: (key, children, assets) => exclude ? {\n          type: \"assets by status\",\n          [name]: Boolean(key),\n          filteredChildren: assets.length,\n          ...assetGroup(children, assets)\n        } : {\n          type: \"assets by status\",\n          [name]: Boolean(key),\n          children,\n          ...assetGroup(children, assets)\n        }\n      });\n    };\n    const {\n      groupAssetsByEmitStatus,\n      groupAssetsByPath,\n      groupAssetsByExtension\n    } = options;\n    if (groupAssetsByEmitStatus) {\n      groupByFlag(\"emitted\");\n      groupByFlag(\"comparedForEmit\");\n      groupByFlag(\"isOverSizeLimit\");\n    }\n    if (groupAssetsByEmitStatus || !options.cachedAssets) {\n      groupByFlag(\"cached\", !options.cachedAssets);\n    }\n    if (groupAssetsByPath || groupAssetsByExtension) {\n      groupConfigs.push({\n        getKeys: asset => {\n          const extensionMatch = groupAssetsByExtension && GROUP_EXTENSION_REGEXP.exec(asset.name);\n          const extension = extensionMatch ? extensionMatch[1] : \"\";\n          const pathMatch = groupAssetsByPath && GROUP_PATH_REGEXP.exec(asset.name);\n          const path = pathMatch ? pathMatch[1].split(/[/\\\\]/) : [];\n          const keys = [];\n          if (groupAssetsByPath) {\n            keys.push(\".\");\n            if (extension) keys.push(path.length ? `${path.join(\"/\")}/*${extension}` : `*${extension}`);\n            while (path.length > 0) {\n              keys.push(`${path.join(\"/\")}/`);\n              path.pop();\n            }\n          } else if (extension) {\n            keys.push(`*${extension}`);\n          }\n          return keys;\n        },\n        createGroup: (key, children, assets) => ({\n          type: groupAssetsByPath ? \"assets by path\" : \"assets by extension\",\n          name: key,\n          children,\n          ...assetGroup(children, assets)\n        })\n      });\n    }\n  },\n  groupAssetsByInfo: (groupConfigs, context, options) => {\n    /**\n     * @param {string} name name\n     */\n    const groupByAssetInfoFlag = name => {\n      groupConfigs.push({\n        getKeys: asset => asset.info && asset.info[name] ? [\"1\"] : undefined,\n        createGroup: (key, children, assets) => ({\n          type: \"assets by info\",\n          info: {\n            [name]: Boolean(key)\n          },\n          children,\n          ...assetGroup(children, assets)\n        })\n      });\n    };\n    groupByAssetInfoFlag(\"immutable\");\n    groupByAssetInfoFlag(\"development\");\n    groupByAssetInfoFlag(\"hotModuleReplacement\");\n  },\n  groupAssetsByChunk: (groupConfigs, context, options) => {\n    /**\n     * @param {keyof KnownStatsAsset} name name\n     */\n    const groupByNames = name => {\n      groupConfigs.push({\n        getKeys: asset => (/** @type {string[]} */asset[name]),\n        createGroup: (key, children, assets) => ({\n          type: \"assets by chunk\",\n          [name]: [key],\n          children,\n          ...assetGroup(children, assets)\n        })\n      });\n    };\n    groupByNames(\"chunkNames\");\n    groupByNames(\"auxiliaryChunkNames\");\n    groupByNames(\"chunkIdHints\");\n    groupByNames(\"auxiliaryChunkIdHints\");\n  },\n  excludeAssets: (groupConfigs, context, {\n    excludeAssets\n  }) => {\n    groupConfigs.push({\n      getKeys: asset => {\n        const ident = asset.name;\n        const excluded = excludeAssets.some(fn => fn(ident, asset));\n        if (excluded) return [\"excluded\"];\n      },\n      getOptions: () => ({\n        groupChildren: false,\n        force: true\n      }),\n      createGroup: (key, children, assets) => ({\n        type: \"hidden assets\",\n        filteredChildren: assets.length,\n        ...assetGroup(children, assets)\n      })\n    });\n  }\n};\n\n/** @typedef {Record<string, (groupConfigs: GroupConfig<KnownStatsModule, TODO>[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>} ModulesGroupers */\n\n/** @type {function(\"module\" | \"chunk\" | \"root-of-chunk\" | \"nested\"): ModulesGroupers} */\nconst MODULES_GROUPERS = type => ({\n  _: (groupConfigs, context, options) => {\n    /**\n     * @param {keyof KnownStatsModule} name name\n     * @param {string} type type\n     * @param {boolean=} exclude need exclude?\n     */\n    const groupByFlag = (name, type, exclude) => {\n      groupConfigs.push({\n        getKeys: module => module[name] ? [\"1\"] : undefined,\n        getOptions: () => ({\n          groupChildren: !exclude,\n          force: exclude\n        }),\n        createGroup: (key, children, modules) => ({\n          type,\n          [name]: Boolean(key),\n          ...(exclude ? {\n            filteredChildren: modules.length\n          } : {\n            children\n          }),\n          ...moduleGroup(children, modules)\n        })\n      });\n    };\n    const {\n      groupModulesByCacheStatus,\n      groupModulesByLayer,\n      groupModulesByAttributes,\n      groupModulesByType,\n      groupModulesByPath,\n      groupModulesByExtension\n    } = options;\n    if (groupModulesByAttributes) {\n      groupByFlag(\"errors\", \"modules with errors\");\n      groupByFlag(\"warnings\", \"modules with warnings\");\n      groupByFlag(\"assets\", \"modules with assets\");\n      groupByFlag(\"optional\", \"optional modules\");\n    }\n    if (groupModulesByCacheStatus) {\n      groupByFlag(\"cacheable\", \"cacheable modules\");\n      groupByFlag(\"built\", \"built modules\");\n      groupByFlag(\"codeGenerated\", \"code generated modules\");\n    }\n    if (groupModulesByCacheStatus || !options.cachedModules) {\n      groupByFlag(\"cached\", \"cached modules\", !options.cachedModules);\n    }\n    if (groupModulesByAttributes || !options.orphanModules) {\n      groupByFlag(\"orphan\", \"orphan modules\", !options.orphanModules);\n    }\n    if (groupModulesByAttributes || !options.dependentModules) {\n      groupByFlag(\"dependent\", \"dependent modules\", !options.dependentModules);\n    }\n    if (groupModulesByType || !options.runtimeModules) {\n      groupConfigs.push({\n        getKeys: module => {\n          if (!module.moduleType) return;\n          if (groupModulesByType) {\n            return [module.moduleType.split(\"/\", 1)[0]];\n          } else if (module.moduleType === WEBPACK_MODULE_TYPE_RUNTIME) {\n            return [WEBPACK_MODULE_TYPE_RUNTIME];\n          }\n        },\n        getOptions: key => {\n          const exclude = key === WEBPACK_MODULE_TYPE_RUNTIME && !options.runtimeModules;\n          return {\n            groupChildren: !exclude,\n            force: exclude\n          };\n        },\n        createGroup: (key, children, modules) => {\n          const exclude = key === WEBPACK_MODULE_TYPE_RUNTIME && !options.runtimeModules;\n          return {\n            type: `${key} modules`,\n            moduleType: key,\n            ...(exclude ? {\n              filteredChildren: modules.length\n            } : {\n              children\n            }),\n            ...moduleGroup(children, modules)\n          };\n        }\n      });\n    }\n    if (groupModulesByLayer) {\n      groupConfigs.push({\n        getKeys: module => (/** @type {string[]} */[module.layer]),\n        createGroup: (key, children, modules) => ({\n          type: \"modules by layer\",\n          layer: key,\n          children,\n          ...moduleGroup(children, modules)\n        })\n      });\n    }\n    if (groupModulesByPath || groupModulesByExtension) {\n      groupConfigs.push({\n        getKeys: module => {\n          if (!module.name) return;\n          const resource = parseResource(/** @type {string} */module.name.split(\"!\").pop()).path;\n          const dataUrl = /^data:[^,;]+/.exec(resource);\n          if (dataUrl) return [dataUrl[0]];\n          const extensionMatch = groupModulesByExtension && GROUP_EXTENSION_REGEXP.exec(resource);\n          const extension = extensionMatch ? extensionMatch[1] : \"\";\n          const pathMatch = groupModulesByPath && GROUP_PATH_REGEXP.exec(resource);\n          const path = pathMatch ? pathMatch[1].split(/[/\\\\]/) : [];\n          const keys = [];\n          if (groupModulesByPath) {\n            if (extension) keys.push(path.length ? `${path.join(\"/\")}/*${extension}` : `*${extension}`);\n            while (path.length > 0) {\n              keys.push(`${path.join(\"/\")}/`);\n              path.pop();\n            }\n          } else if (extension) {\n            keys.push(`*${extension}`);\n          }\n          return keys;\n        },\n        createGroup: (key, children, modules) => {\n          const isDataUrl = key.startsWith(\"data:\");\n          return {\n            type: isDataUrl ? \"modules by mime type\" : groupModulesByPath ? \"modules by path\" : \"modules by extension\",\n            name: isDataUrl ? key.slice(/* 'data:'.length */5) : key,\n            children,\n            ...moduleGroup(children, modules)\n          };\n        }\n      });\n    }\n  },\n  excludeModules: (groupConfigs, context, {\n    excludeModules\n  }) => {\n    groupConfigs.push({\n      getKeys: module => {\n        const name = module.name;\n        if (name) {\n          const excluded = excludeModules.some(fn => fn(name, module, type));\n          if (excluded) return [\"1\"];\n        }\n      },\n      getOptions: () => ({\n        groupChildren: false,\n        force: true\n      }),\n      createGroup: (key, children, modules) => ({\n        type: \"hidden modules\",\n        filteredChildren: children.length,\n        ...moduleGroup(children, modules)\n      })\n    });\n  }\n});\n\n/** @typedef {Record<string, (groupConfigs: import(\"../util/smartGrouping\").GroupConfig<KnownStatsModuleReason, TODO>[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>} ModuleReasonsGroupers */\n\n/** @type {ModuleReasonsGroupers} */\nconst MODULE_REASONS_GROUPERS = {\n  groupReasonsByOrigin: groupConfigs => {\n    groupConfigs.push({\n      getKeys: reason => (/** @type {string[]} */[reason.module]),\n      createGroup: (key, children, reasons) => ({\n        type: \"from origin\",\n        module: key,\n        children,\n        ...reasonGroup(children, reasons)\n      })\n    });\n  }\n};\n\n/** @type {Record<string, AssetsGroupers | ModulesGroupers | ModuleReasonsGroupers>} */\nconst RESULT_GROUPERS = {\n  \"compilation.assets\": ASSETS_GROUPERS,\n  \"asset.related\": ASSETS_GROUPERS,\n  \"compilation.modules\": MODULES_GROUPERS(\"module\"),\n  \"chunk.modules\": MODULES_GROUPERS(\"chunk\"),\n  \"chunk.rootModules\": MODULES_GROUPERS(\"root-of-chunk\"),\n  \"module.modules\": MODULES_GROUPERS(\"nested\"),\n  \"module.reasons\": MODULE_REASONS_GROUPERS\n};\n\n// remove a prefixed \"!\" that can be specified to reverse sort order\n/**\n * @param {string} field a field name\n * @returns {field} normalized field\n */\nconst normalizeFieldKey = field => {\n  if (field[0] === \"!\") {\n    return field.slice(1);\n  }\n  return field;\n};\n\n// if a field is prefixed by a \"!\" reverse sort order\n/**\n * @param {string} field a field name\n * @returns {boolean} result\n */\nconst sortOrderRegular = field => {\n  if (field[0] === \"!\") {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @template T\n * @param {string} field field name\n * @returns {function(T, T): 0 | 1 | -1} comparators\n */\nconst sortByField = field => {\n  if (!field) {\n    /**\n     * @param {any} a first\n     * @param {any} b second\n     * @returns {-1|0|1} zero\n     */\n    const noSort = (a, b) => 0;\n    return noSort;\n  }\n  const fieldKey = normalizeFieldKey(field);\n  let sortFn = compareSelect(m => m[fieldKey], compareIds);\n\n  // if a field is prefixed with a \"!\" the sort is reversed!\n  const sortIsRegular = sortOrderRegular(field);\n  if (!sortIsRegular) {\n    const oldSortFn = sortFn;\n    sortFn = (a, b) => oldSortFn(b, a);\n  }\n  return sortFn;\n};\n\n/** @type {Record<string, (comparators: Comparator<TODO>[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>} */\nconst ASSET_SORTERS = {\n  assetsSort: (comparators, context, {\n    assetsSort\n  }) => {\n    comparators.push(sortByField(assetsSort));\n  },\n  _: comparators => {\n    comparators.push(compareSelect(a => a.name, compareIds));\n  }\n};\n\n/** @type {Record<string, Record<string, (comparators: Comparator<TODO>[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>>} */\nconst RESULT_SORTERS = {\n  \"compilation.chunks\": {\n    chunksSort: (comparators, context, {\n      chunksSort\n    }) => {\n      comparators.push(sortByField(chunksSort));\n    }\n  },\n  \"compilation.modules\": {\n    modulesSort: (comparators, context, {\n      modulesSort\n    }) => {\n      comparators.push(sortByField(modulesSort));\n    }\n  },\n  \"chunk.modules\": {\n    chunkModulesSort: (comparators, context, {\n      chunkModulesSort\n    }) => {\n      comparators.push(sortByField(chunkModulesSort));\n    }\n  },\n  \"module.modules\": {\n    nestedModulesSort: (comparators, context, {\n      nestedModulesSort\n    }) => {\n      comparators.push(sortByField(nestedModulesSort));\n    }\n  },\n  \"compilation.assets\": ASSET_SORTERS,\n  \"asset.related\": ASSET_SORTERS\n};\n\n/**\n * @param {Record<string, Record<string, Function>>} config the config see above\n * @param {NormalizedStatsOptions} options stats options\n * @param {function(string, Function): void} fn handler function called for every active line in config\n * @returns {void}\n */\nconst iterateConfig = (config, options, fn) => {\n  for (const hookFor of Object.keys(config)) {\n    const subConfig = config[hookFor];\n    for (const option of Object.keys(subConfig)) {\n      if (option !== \"_\") {\n        if (option.startsWith(\"!\")) {\n          if (options[option.slice(1)]) continue;\n        } else {\n          const value = options[option];\n          if (value === false || value === undefined || Array.isArray(value) && value.length === 0) continue;\n        }\n      }\n      fn(hookFor, subConfig[option]);\n    }\n  }\n};\n\n/** @type {Record<string, string>} */\nconst ITEM_NAMES = {\n  \"compilation.children[]\": \"compilation\",\n  \"compilation.modules[]\": \"module\",\n  \"compilation.entrypoints[]\": \"chunkGroup\",\n  \"compilation.namedChunkGroups[]\": \"chunkGroup\",\n  \"compilation.errors[]\": \"error\",\n  \"compilation.warnings[]\": \"warning\",\n  \"chunk.modules[]\": \"module\",\n  \"chunk.rootModules[]\": \"module\",\n  \"chunk.origins[]\": \"chunkOrigin\",\n  \"compilation.chunks[]\": \"chunk\",\n  \"compilation.assets[]\": \"asset\",\n  \"asset.related[]\": \"asset\",\n  \"module.issuerPath[]\": \"moduleIssuer\",\n  \"module.reasons[]\": \"moduleReason\",\n  \"module.modules[]\": \"module\",\n  \"module.children[]\": \"module\",\n  \"moduleTrace[]\": \"moduleTraceItem\",\n  \"moduleTraceItem.dependencies[]\": \"moduleTraceDependency\"\n};\n\n/**\n * @template T\n * @typedef {{ name: T }} NamedObject\n */\n\n/**\n * @template {{ name: string }} T\n * @param {T[]} items items to be merged\n * @returns {NamedObject<T>} an object\n */\nconst mergeToObject = items => {\n  const obj = Object.create(null);\n  for (const item of items) {\n    obj[item.name] = item;\n  }\n  return obj;\n};\n\n/**\n * @template {{ name: string }} T\n * @type {Record<string, (items: T[]) => NamedObject<T>>}\n */\nconst MERGER = {\n  \"compilation.entrypoints\": mergeToObject,\n  \"compilation.namedChunkGroups\": mergeToObject\n};\nclass DefaultStatsFactoryPlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"DefaultStatsFactoryPlugin\", compilation => {\n      compilation.hooks.statsFactory.tap(\"DefaultStatsFactoryPlugin\",\n      /**\n       * @param {StatsFactory} stats stats factory\n       * @param {NormalizedStatsOptions} options stats options\n       */\n      (stats, options) => {\n        iterateConfig(SIMPLE_EXTRACTORS, options, (hookFor, fn) => {\n          stats.hooks.extract.for(hookFor).tap(\"DefaultStatsFactoryPlugin\", (obj, data, ctx) => fn(obj, data, ctx, options, stats));\n        });\n        iterateConfig(FILTER, options, (hookFor, fn) => {\n          stats.hooks.filter.for(hookFor).tap(\"DefaultStatsFactoryPlugin\", (item, ctx, idx, i) => fn(item, ctx, options, idx, i));\n        });\n        iterateConfig(FILTER_RESULTS, options, (hookFor, fn) => {\n          stats.hooks.filterResults.for(hookFor).tap(\"DefaultStatsFactoryPlugin\", (item, ctx, idx, i) => fn(item, ctx, options, idx, i));\n        });\n        iterateConfig(SORTERS, options, (hookFor, fn) => {\n          stats.hooks.sort.for(hookFor).tap(\"DefaultStatsFactoryPlugin\", (comparators, ctx) => fn(comparators, ctx, options));\n        });\n        iterateConfig(RESULT_SORTERS, options, (hookFor, fn) => {\n          stats.hooks.sortResults.for(hookFor).tap(\"DefaultStatsFactoryPlugin\", (comparators, ctx) => fn(comparators, ctx, options));\n        });\n        iterateConfig(RESULT_GROUPERS, options, (hookFor, fn) => {\n          stats.hooks.groupResults.for(hookFor).tap(\"DefaultStatsFactoryPlugin\", (groupConfigs, ctx) => fn(groupConfigs, ctx, options));\n        });\n        for (const key of Object.keys(ITEM_NAMES)) {\n          const itemName = ITEM_NAMES[key];\n          stats.hooks.getItemName.for(key).tap(\"DefaultStatsFactoryPlugin\", () => itemName);\n        }\n        for (const key of Object.keys(MERGER)) {\n          const merger = MERGER[key];\n          stats.hooks.merge.for(key).tap(\"DefaultStatsFactoryPlugin\", merger);\n        }\n        if (options.children) {\n          if (Array.isArray(options.children)) {\n            stats.hooks.getItemFactory.for(\"compilation.children[].compilation\").tap(\"DefaultStatsFactoryPlugin\",\n            /**\n             * @param {Compilation} comp compilation\n             * @param {StatsFactoryContext} options options\n             * @returns {StatsFactory | undefined} stats factory\n             */\n            (comp, {\n              _index: idx\n            }) => {\n              const children = /** @type {TODO} */\n              options.children;\n              if (idx < children.length) {\n                return compilation.createStatsFactory(compilation.createStatsOptions(children[idx]));\n              }\n            });\n          } else if (options.children !== true) {\n            const childFactory = compilation.createStatsFactory(compilation.createStatsOptions(options.children));\n            stats.hooks.getItemFactory.for(\"compilation.children[].compilation\").tap(\"DefaultStatsFactoryPlugin\", () => childFactory);\n          }\n        }\n      });\n    });\n  }\n}\nmodule.exports = DefaultStatsFactoryPlugin;","map":{"version":3,"names":["util","require","WEBPACK_MODULE_TYPE_RUNTIME","ModuleDependency","formatLocation","LogType","AggressiveSplittingPlugin","SizeLimitsPlugin","countIterable","compareLocations","compareChunksById","compareNumbers","compareIds","concatComparators","compareSelect","compareModulesByIdentifier","makePathsRelative","parseResource","uniqueArray","items","selector","set","Set","item","i","add","Array","from","uniqueOrderedArray","comparator","sort","mapObject","obj","fn","newObj","Object","create","key","keys","countWithChildren","compilation","getItems","count","length","child","children","c","type","EXTRACT_ERROR","_","object","error","context","requestShortener","message","chunk","chunkName","name","chunkEntry","hasRuntime","chunkInitial","canBeInitial","file","module","moduleIdentifier","identifier","moduleName","readableIdentifier","loc","ids","chunkGraph","chunkId","id","moduleId","getModuleId","moduleTrace","options","factory","moduleGraph","visitedModules","current","has","origin","getIssuer","push","errorDetails","cachedGetErrors","cachedGetWarnings","endsWith","details","errorStack","stack","SIMPLE_EXTRACTORS","bindContextCache","compiler","root","map","WeakMap","get","errors","getErrors","warnings","getWarnings","needAdditionalPass","logging","loggingDebug","loggingTrace","acceptedTypes","collapsedGroups","warn","info","log","group","groupEnd","groupCollapsed","clear","profile","profileEnd","time","status","cachedMakePathsRelative","depthInCollapsedGroup","logEntries","debugMode","some","groupStack","rootList","currentList","processedLogEntries","entry","pop","label","first","second","args","format","slice","newEntry","trace","undefined","replace","entries","filteredEntries","debug","hash","version","env","_env","timings","endTime","startTime","builtAt","publicPath","getPath","outputOptions","outputPath","path","assets","compilationFileToChunks","Map","compilationAuxiliaryFileToChunks","chunks","files","array","auxiliaryFiles","assetMap","asset","getAssets","related","values","relatedEntry","deps","isArray","dep","depItem","delete","assetsByChunkName","prototype","hasOwnProperty","call","groupedAssets","limited","spaceLimited","assetsSpace","filteredAssets","filteredChildren","modules","groupedModules","modulesSpace","filteredModules","entrypoints","chunkGroups","chunkGroupAuxiliary","chunkGroupChildren","value","chunkGroup","every","size","namedChunkGroups","rawErrors","factorizedErrors","filtered","e","filter","Boolean","Number","isFinite","errorsSpace","filteredErrorDetailsCount","filteredBySpace","errorsSpaceLimit","errorsCount","rawWarnings","warningsSpace","filteredWarningDetailsCount","warningsCount","warningsFilter","childType","warning","warningString","join","source","emitted","emittedAssets","comparedForEmit","comparedForEmitAssets","cached","cachedAssets","assign","asset$visible","auxiliaryChunks","chunkNames","chunkIdHints","idNameHints","auxiliaryChunkNames","auxiliaryChunkIdHints","filteredRelated","relatedAssets","performance","isOverSizeLimit","chunkGroupMaxAssets","getChildrenByOrders","toAsset","getAsset","sizeReducer","total","auxiliaryAssets","assetsSize","reduce","auxiliaryAssetsSize","statsChunkGroup","filteredAuxiliaryAssets","groups","childStatsChunkGroup","childAssets","built","builtModules","codeGenerated","codeGeneratedModules","buildTimeExecuted","buildTimeExecutedModules","sizes","sourceType","getSourceTypes","statsModule","moduleType","layer","cachedModules","module$visible","rootModules","issuer","reverse","getProfile","nameForCondition","index","getPreOrderIndex","preOrderIndex","index2","getPostOrderIndex","postOrderIndex","cacheable","buildInfo","optional","isOptional","orphan","getNumberOfModuleChunks","dependent","issuerName","issuerPath","failed","issuerId","getOrderedModuleChunksIterable","moduleAssets","reasons","groupsReasons","getIncomingConnections","reasonsSpace","filteredReasons","usedExports","runtime","getUsedExports","providedExports","getProvidedExports","optimizationBailout","getOptimizationBailout","depth","getDepth","nestedModules","innerModules","nestedModulesSpace","originalSource","statsProfile","restoring","integration","building","storing","resolving","additionalResolving","additionalFactories","additionalIntegration","dependencies","moduleIssuer","statsModuleIssuer","moduleReason","reason","dependency","moduleDep","statsModuleReason","originModule","resolvedModuleIdentifier","resolvedOriginModule","resolvedModule","active","isActive","explanation","userRequest","locInfo","resolvedModuleId","childIdByOrder","getChildIdsByOrders","statsChunk","rendered","initial","recorded","wasChunkRecorded","chunkReason","getChunkModulesSize","getChunkModulesSizes","names","idHints","renderedHash","childrenByOrder","chunkRelations","parents","siblings","groupsIterable","parentGroup","parentsIterable","childGroup","childrenIterable","sibling","chunkModules","getChunkModules","getChunkRootModules","chunkModulesSpace","chunkOrigins","originsKeySet","origins","g","request","chunkOrigin","statsChunkOrigin","moduleTraceItem","originIdentifier","originName","originId","moduleTraceDependency","FILTER","!orphanModules","FILTER_RESULTS","deprecate","MODULES_SORTER","comparators","m","SORTERS","x","getItemSize","getTotalSize","getTotalItems","collapse","newChildren","itemsAndGroups","max","filteredChildrenLineReserved","groupSizes","groupsSize","itemOrGroup","concat","limit","oversize","maxGroupSize","Math","headerSize","ceil","newSize","fullLength","result","splitted","split","len","overLimit","filteredDetails","assetGroup","moduleGroup","reasonGroup","GROUP_EXTENSION_REGEXP","GROUP_PATH_REGEXP","ASSETS_GROUPERS","groupConfigs","groupByFlag","exclude","getKeys","getOptions","groupChildren","force","createGroup","groupAssetsByEmitStatus","groupAssetsByPath","groupAssetsByExtension","extensionMatch","exec","extension","pathMatch","groupAssetsByInfo","groupByAssetInfoFlag","groupAssetsByChunk","groupByNames","excludeAssets","ident","excluded","MODULES_GROUPERS","groupModulesByCacheStatus","groupModulesByLayer","groupModulesByAttributes","groupModulesByType","groupModulesByPath","groupModulesByExtension","orphanModules","dependentModules","runtimeModules","resource","dataUrl","isDataUrl","startsWith","excludeModules","MODULE_REASONS_GROUPERS","groupReasonsByOrigin","RESULT_GROUPERS","normalizeFieldKey","field","sortOrderRegular","sortByField","noSort","a","b","fieldKey","sortFn","sortIsRegular","oldSortFn","ASSET_SORTERS","assetsSort","RESULT_SORTERS","chunksSort","modulesSort","chunkModulesSort","nestedModulesSort","iterateConfig","config","hookFor","subConfig","option","ITEM_NAMES","mergeToObject","MERGER","DefaultStatsFactoryPlugin","apply","hooks","tap","statsFactory","stats","extract","for","data","ctx","idx","filterResults","sortResults","groupResults","itemName","getItemName","merger","merge","getItemFactory","comp","_index","createStatsFactory","createStatsOptions","childFactory","exports"],"sources":["/home/wickliff/Desktop/dev-waki/portfolio2/node_modules/webpack/lib/stats/DefaultStatsFactoryPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst util = require(\"util\");\nconst { WEBPACK_MODULE_TYPE_RUNTIME } = require(\"../ModuleTypeConstants\");\nconst ModuleDependency = require(\"../dependencies/ModuleDependency\");\nconst formatLocation = require(\"../formatLocation\");\nconst { LogType } = require(\"../logging/Logger\");\nconst AggressiveSplittingPlugin = require(\"../optimize/AggressiveSplittingPlugin\");\nconst SizeLimitsPlugin = require(\"../performance/SizeLimitsPlugin\");\nconst { countIterable } = require(\"../util/IterableHelpers\");\nconst {\n\tcompareLocations,\n\tcompareChunksById,\n\tcompareNumbers,\n\tcompareIds,\n\tconcatComparators,\n\tcompareSelect,\n\tcompareModulesByIdentifier\n} = require(\"../util/comparators\");\nconst { makePathsRelative, parseResource } = require(\"../util/identifier\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Chunk\").ChunkId} ChunkId */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../ChunkGroup\").OriginRecord} OriginRecord */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compilation\").Asset} Asset */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compilation\").NormalizedStatsOptions} NormalizedStatsOptions */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../ChunkGraph\").ModuleId} ModuleId */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Module\").BuildInfo} BuildInfo */\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n/** @typedef {import(\"../ModuleProfile\")} ModuleProfile */\n/** @typedef {import(\"../RequestShortener\")} RequestShortener */\n/** @typedef {import(\"../WebpackError\")} WebpackError */\n/** @typedef {import(\"../TemplatedPathPlugin\").TemplatePath} TemplatePath */\n/**\n * @template T\n * @typedef {import(\"../util/comparators\").Comparator<T>} Comparator<T>\n */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n/**\n * @template T, R\n * @typedef {import(\"../util/smartGrouping\").GroupConfig<T, R>} GroupConfig\n */\n/** @typedef {import(\"./StatsFactory\")} StatsFactory */\n/** @typedef {import(\"./StatsFactory\").StatsFactoryContext} StatsFactoryContext */\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsCompilation} StatsCompilation */\n/**\n * @typedef {object} KnownStatsCompilation\n * @property {any=} env\n * @property {string=} name\n * @property {string=} hash\n * @property {string=} version\n * @property {number=} time\n * @property {number=} builtAt\n * @property {boolean=} needAdditionalPass\n * @property {string=} publicPath\n * @property {string=} outputPath\n * @property {Record<string, string[]>=} assetsByChunkName\n * @property {StatsAsset[]=} assets\n * @property {number=} filteredAssets\n * @property {StatsChunk[]=} chunks\n * @property {StatsModule[]=} modules\n * @property {number=} filteredModules\n * @property {Record<string, StatsChunkGroup>=} entrypoints\n * @property {Record<string, StatsChunkGroup>=} namedChunkGroups\n * @property {StatsError[]=} errors\n * @property {number=} errorsCount\n * @property {StatsError[]=} warnings\n * @property {number=} warningsCount\n * @property {StatsCompilation[]=} children\n * @property {Record<string, StatsLogging>=} logging\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsLogging} StatsLogging */\n/**\n * @typedef {object} KnownStatsLogging\n * @property {StatsLoggingEntry[]} entries\n * @property {number} filteredEntries\n * @property {boolean} debug\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsLoggingEntry} StatsLoggingEntry */\n/**\n * @typedef {object} KnownStatsLoggingEntry\n * @property {string} type\n * @property {string=} message\n * @property {string[]=} trace\n * @property {StatsLoggingEntry[]=} children\n * @property {any[]=} args\n * @property {number=} time\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsAsset} StatsAsset */\n/**\n * @typedef {object} KnownStatsAsset\n * @property {string} type\n * @property {string} name\n * @property {AssetInfo} info\n * @property {number} size\n * @property {boolean} emitted\n * @property {boolean} comparedForEmit\n * @property {boolean} cached\n * @property {StatsAsset[]=} related\n * @property {(string|number)[]=} chunkNames\n * @property {(string|number)[]=} chunkIdHints\n * @property {(string|number)[]=} chunks\n * @property {(string|number)[]=} auxiliaryChunkNames\n * @property {(string|number)[]=} auxiliaryChunks\n * @property {(string|number)[]=} auxiliaryChunkIdHints\n * @property {number=} filteredRelated\n * @property {boolean=} isOverSizeLimit\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsChunkGroup} StatsChunkGroup */\n/**\n * @typedef {object} KnownStatsChunkGroup\n * @property {(string | null)=} name\n * @property {(string | number)[]=} chunks\n * @property {({ name: string, size?: number })[]=} assets\n * @property {number=} filteredAssets\n * @property {number=} assetsSize\n * @property {({ name: string, size?: number })[]=} auxiliaryAssets\n * @property {number=} filteredAuxiliaryAssets\n * @property {number=} auxiliaryAssetsSize\n * @property {{ [x: string]: StatsChunkGroup[] }=} children\n * @property {{ [x: string]: string[] }=} childAssets\n * @property {boolean=} isOverSizeLimit\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsModule} StatsModule */\n/**\n * @typedef {object} KnownStatsModule\n * @property {string=} type\n * @property {string=} moduleType\n * @property {(string | null)=} layer\n * @property {string=} identifier\n * @property {string=} name\n * @property {(string | null)=} nameForCondition\n * @property {number=} index\n * @property {number=} preOrderIndex\n * @property {number=} index2\n * @property {number=} postOrderIndex\n * @property {number=} size\n * @property {{ [x: string]: number }=} sizes\n * @property {boolean=} cacheable\n * @property {boolean=} built\n * @property {boolean=} codeGenerated\n * @property {boolean=} buildTimeExecuted\n * @property {boolean=} cached\n * @property {boolean=} optional\n * @property {boolean=} orphan\n * @property {string | number=} id\n * @property {string | number | null=} issuerId\n * @property {(string | number)[]=} chunks\n * @property {(string | number)[]=} assets\n * @property {boolean=} dependent\n * @property {(string | null)=} issuer\n * @property {(string | null)=} issuerName\n * @property {StatsModuleIssuer[]=} issuerPath\n * @property {boolean=} failed\n * @property {number=} errors\n * @property {number=} warnings\n * @property {StatsProfile=} profile\n * @property {StatsModuleReason[]=} reasons\n * @property {(boolean | null | string[])=} usedExports\n * @property {(string[] | null)=} providedExports\n * @property {string[]=} optimizationBailout\n * @property {(number | null)=} depth\n * @property {StatsModule[]=} modules\n * @property {number=} filteredModules\n * @property {ReturnType<Source[\"source\"]>=} source\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsProfile} StatsProfile */\n/**\n * @typedef {object} KnownStatsProfile\n * @property {number} total\n * @property {number} resolving\n * @property {number} restoring\n * @property {number} building\n * @property {number} integration\n * @property {number} storing\n * @property {number} additionalResolving\n * @property {number} additionalIntegration\n * @property {number} factory\n * @property {number} dependencies\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsModuleIssuer} StatsModuleIssuer */\n/**\n * @typedef {object} KnownStatsModuleIssuer\n * @property {string} identifier\n * @property {string} name\n * @property {(string|number)=} id\n * @property {StatsProfile} profile\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsModuleReason} StatsModuleReason */\n/**\n * @typedef {object} KnownStatsModuleReason\n * @property {string | null} moduleIdentifier\n * @property {string | null} module\n * @property {string | null} moduleName\n * @property {string | null} resolvedModuleIdentifier\n * @property {string | null} resolvedModule\n * @property {string | null} type\n * @property {boolean} active\n * @property {string | null} explanation\n * @property {string | null} userRequest\n * @property {(string | null)=} loc\n * @property {(string | number | null)=} moduleId\n * @property {(string | number | null)=} resolvedModuleId\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsChunk} StatsChunk */\n/**\n * @typedef {object} KnownStatsChunk\n * @property {boolean} rendered\n * @property {boolean} initial\n * @property {boolean} entry\n * @property {boolean} recorded\n * @property {string=} reason\n * @property {number} size\n * @property {Record<string, number>} sizes\n * @property {string[]} names\n * @property {string[]} idHints\n * @property {string[]=} runtime\n * @property {string[]} files\n * @property {string[]} auxiliaryFiles\n * @property {string} hash\n * @property {Record<string, (string|number)[]>} childrenByOrder\n * @property {(string|number)=} id\n * @property {(string|number)[]=} siblings\n * @property {(string|number)[]=} parents\n * @property {(string|number)[]=} children\n * @property {StatsModule[]=} modules\n * @property {number=} filteredModules\n * @property {StatsChunkOrigin[]=} origins\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsChunkOrigin} StatsChunkOrigin */\n/**\n * @typedef {object} KnownStatsChunkOrigin\n * @property {string} module\n * @property {string} moduleIdentifier\n * @property {string} moduleName\n * @property {string} loc\n * @property {string} request\n * @property {(string | number)=} moduleId\n */\n\n/** @typedef { Record<string, EXPECTED_ANY> & KnownStatsModuleTraceItem} StatsModuleTraceItem */\n/**\n * @typedef {object} KnownStatsModuleTraceItem\n * @property {string=} originIdentifier\n * @property {string=} originName\n * @property {string=} moduleIdentifier\n * @property {string=} moduleName\n * @property {StatsModuleTraceDependency[]=} dependencies\n * @property {(string|number)=} originId\n * @property {(string|number)=} moduleId\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsModuleTraceDependency} StatsModuleTraceDependency */\n/**\n * @typedef {object} KnownStatsModuleTraceDependency\n * @property {string=} loc\n */\n\n/** @typedef {Record<string, EXPECTED_ANY> & KnownStatsError} StatsError */\n/**\n * @typedef {object} KnownStatsError\n * @property {string} message\n * @property {string=} chunkName\n * @property {boolean=} chunkEntry\n * @property {boolean=} chunkInitial\n * @property {string=} file\n * @property {string=} moduleIdentifier\n * @property {string=} moduleName\n * @property {string=} loc\n * @property {ChunkId=} chunkId\n * @property {string|number=} moduleId\n * @property {StatsModuleTraceItem[]=} moduleTrace\n * @property {any=} details\n * @property {string=} stack\n */\n\n/** @typedef {Asset & { type: string, related: PreprocessedAsset[] | undefined }} PreprocessedAsset */\n\n/**\n * @template T\n * @template O\n * @typedef {Record<string, (object: O, data: T, context: StatsFactoryContext, options: NormalizedStatsOptions, factory: StatsFactory) => void>} ExtractorsByOption\n */\n\n/**\n * @typedef {object} SimpleExtractors\n * @property {ExtractorsByOption<Compilation, StatsCompilation>} compilation\n * @property {ExtractorsByOption<PreprocessedAsset, StatsAsset>} asset\n * @property {ExtractorsByOption<PreprocessedAsset, StatsAsset>} asset$visible\n * @property {ExtractorsByOption<{ name: string, chunkGroup: ChunkGroup }, StatsChunkGroup>} chunkGroup\n * @property {ExtractorsByOption<Module, StatsModule>} module\n * @property {ExtractorsByOption<Module, StatsModule>} module$visible\n * @property {ExtractorsByOption<Module, StatsModuleIssuer>} moduleIssuer\n * @property {ExtractorsByOption<ModuleProfile, StatsProfile>} profile\n * @property {ExtractorsByOption<ModuleGraphConnection, StatsModuleReason>} moduleReason\n * @property {ExtractorsByOption<Chunk, StatsChunk>} chunk\n * @property {ExtractorsByOption<OriginRecord, StatsChunkOrigin>} chunkOrigin\n * @property {ExtractorsByOption<WebpackError, StatsError>} error\n * @property {ExtractorsByOption<WebpackError, StatsError>} warning\n * @property {ExtractorsByOption<{ origin: Module, module: Module }, StatsModuleTraceItem>} moduleTraceItem\n * @property {ExtractorsByOption<Dependency, StatsModuleTraceDependency>} moduleTraceDependency\n */\n\n/**\n * @template T\n * @template I\n * @param {Iterable<T>} items items to select from\n * @param {function(T): Iterable<I>} selector selector function to select values from item\n * @returns {I[]} array of values\n */\nconst uniqueArray = (items, selector) => {\n\t/** @type {Set<I>} */\n\tconst set = new Set();\n\tfor (const item of items) {\n\t\tfor (const i of selector(item)) {\n\t\t\tset.add(i);\n\t\t}\n\t}\n\treturn Array.from(set);\n};\n\n/**\n * @template T\n * @template I\n * @param {Iterable<T>} items items to select from\n * @param {function(T): Iterable<I>} selector selector function to select values from item\n * @param {Comparator<I>} comparator comparator function\n * @returns {I[]} array of values\n */\nconst uniqueOrderedArray = (items, selector, comparator) =>\n\tuniqueArray(items, selector).sort(comparator);\n\n/** @template T @template R @typedef {{ [P in keyof T]: R }} MappedValues<T, R> */\n\n/**\n * @template {object} T\n * @template {object} R\n * @param {T} obj object to be mapped\n * @param {function(T[keyof T], keyof T): R} fn mapping function\n * @returns {MappedValues<T, R>} mapped object\n */\nconst mapObject = (obj, fn) => {\n\tconst newObj = Object.create(null);\n\tfor (const key of Object.keys(obj)) {\n\t\tnewObj[key] = fn(\n\t\t\tobj[/** @type {keyof T} */ (key)],\n\t\t\t/** @type {keyof T} */ (key)\n\t\t);\n\t}\n\treturn newObj;\n};\n\n/**\n * @param {Compilation} compilation the compilation\n * @param {function(Compilation, string): any[]} getItems get items\n * @returns {number} total number\n */\nconst countWithChildren = (compilation, getItems) => {\n\tlet count = getItems(compilation, \"\").length;\n\tfor (const child of compilation.children) {\n\t\tcount += countWithChildren(child, (c, type) =>\n\t\t\tgetItems(c, `.children[].compilation${type}`)\n\t\t);\n\t}\n\treturn count;\n};\n\n/** @type {ExtractorsByOption<WebpackError | string, StatsError>} */\nconst EXTRACT_ERROR = {\n\t_: (object, error, context, { requestShortener }) => {\n\t\t// TODO webpack 6 disallow strings in the errors/warnings list\n\t\tif (typeof error === \"string\") {\n\t\t\tobject.message = error;\n\t\t} else {\n\t\t\tif (error.chunk) {\n\t\t\t\tobject.chunkName = error.chunk.name;\n\t\t\t\tobject.chunkEntry = error.chunk.hasRuntime();\n\t\t\t\tobject.chunkInitial = error.chunk.canBeInitial();\n\t\t\t}\n\t\t\tif (error.file) {\n\t\t\t\tobject.file = error.file;\n\t\t\t}\n\t\t\tif (error.module) {\n\t\t\t\tobject.moduleIdentifier = error.module.identifier();\n\t\t\t\tobject.moduleName = error.module.readableIdentifier(requestShortener);\n\t\t\t}\n\t\t\tif (error.loc) {\n\t\t\t\tobject.loc = formatLocation(error.loc);\n\t\t\t}\n\t\t\tobject.message = error.message;\n\t\t}\n\t},\n\tids: (object, error, { compilation: { chunkGraph } }) => {\n\t\tif (typeof error !== \"string\") {\n\t\t\tif (error.chunk) {\n\t\t\t\tobject.chunkId = /** @type {ChunkId} */ (error.chunk.id);\n\t\t\t}\n\t\t\tif (error.module) {\n\t\t\t\tobject.moduleId =\n\t\t\t\t\t/** @type {ModuleId} */\n\t\t\t\t\t(chunkGraph.getModuleId(error.module));\n\t\t\t}\n\t\t}\n\t},\n\tmoduleTrace: (object, error, context, options, factory) => {\n\t\tif (typeof error !== \"string\" && error.module) {\n\t\t\tconst {\n\t\t\t\ttype,\n\t\t\t\tcompilation: { moduleGraph }\n\t\t\t} = context;\n\t\t\t/** @type {Set<Module>} */\n\t\t\tconst visitedModules = new Set();\n\t\t\tconst moduleTrace = [];\n\t\t\tlet current = error.module;\n\t\t\twhile (current) {\n\t\t\t\tif (visitedModules.has(current)) break; // circular (technically impossible, but how knows)\n\t\t\t\tvisitedModules.add(current);\n\t\t\t\tconst origin = moduleGraph.getIssuer(current);\n\t\t\t\tif (!origin) break;\n\t\t\t\tmoduleTrace.push({ origin, module: current });\n\t\t\t\tcurrent = origin;\n\t\t\t}\n\t\t\tobject.moduleTrace = factory.create(\n\t\t\t\t`${type}.moduleTrace`,\n\t\t\t\tmoduleTrace,\n\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\t},\n\terrorDetails: (\n\t\tobject,\n\t\terror,\n\t\t{ type, compilation, cachedGetErrors, cachedGetWarnings },\n\t\t{ errorDetails }\n\t) => {\n\t\tif (\n\t\t\ttypeof error !== \"string\" &&\n\t\t\t(errorDetails === true ||\n\t\t\t\t(type.endsWith(\".error\") && cachedGetErrors(compilation).length < 3))\n\t\t) {\n\t\t\tobject.details = error.details;\n\t\t}\n\t},\n\terrorStack: (object, error) => {\n\t\tif (typeof error !== \"string\") {\n\t\t\tobject.stack = error.stack;\n\t\t}\n\t}\n};\n\n/** @type {SimpleExtractors} */\nconst SIMPLE_EXTRACTORS = {\n\tcompilation: {\n\t\t_: (object, compilation, context, options) => {\n\t\t\tif (!context.makePathsRelative) {\n\t\t\t\tcontext.makePathsRelative = makePathsRelative.bindContextCache(\n\t\t\t\t\tcompilation.compiler.context,\n\t\t\t\t\tcompilation.compiler.root\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (!context.cachedGetErrors) {\n\t\t\t\tconst map = new WeakMap();\n\t\t\t\tcontext.cachedGetErrors = compilation =>\n\t\t\t\t\tmap.get(compilation) ||\n\t\t\t\t\t// eslint-disable-next-line no-sequences\n\t\t\t\t\t(errors => (map.set(compilation, errors), errors))(\n\t\t\t\t\t\tcompilation.getErrors()\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tif (!context.cachedGetWarnings) {\n\t\t\t\tconst map = new WeakMap();\n\t\t\t\tcontext.cachedGetWarnings = compilation =>\n\t\t\t\t\tmap.get(compilation) ||\n\t\t\t\t\t// eslint-disable-next-line no-sequences\n\t\t\t\t\t(warnings => (map.set(compilation, warnings), warnings))(\n\t\t\t\t\t\tcompilation.getWarnings()\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tif (compilation.name) {\n\t\t\t\tobject.name = compilation.name;\n\t\t\t}\n\t\t\tif (compilation.needAdditionalPass) {\n\t\t\t\tobject.needAdditionalPass = true;\n\t\t\t}\n\n\t\t\tconst { logging, loggingDebug, loggingTrace } = options;\n\t\t\tif (logging || (loggingDebug && loggingDebug.length > 0)) {\n\t\t\t\tconst util = require(\"util\");\n\t\t\t\tobject.logging = {};\n\t\t\t\tlet acceptedTypes;\n\t\t\t\tlet collapsedGroups = false;\n\t\t\t\tswitch (logging) {\n\t\t\t\t\tcase \"error\":\n\t\t\t\t\t\tacceptedTypes = new Set([LogType.error]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"warn\":\n\t\t\t\t\t\tacceptedTypes = new Set([LogType.error, LogType.warn]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"info\":\n\t\t\t\t\t\tacceptedTypes = new Set([\n\t\t\t\t\t\t\tLogType.error,\n\t\t\t\t\t\t\tLogType.warn,\n\t\t\t\t\t\t\tLogType.info\n\t\t\t\t\t\t]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"log\":\n\t\t\t\t\t\tacceptedTypes = new Set([\n\t\t\t\t\t\t\tLogType.error,\n\t\t\t\t\t\t\tLogType.warn,\n\t\t\t\t\t\t\tLogType.info,\n\t\t\t\t\t\t\tLogType.log,\n\t\t\t\t\t\t\tLogType.group,\n\t\t\t\t\t\t\tLogType.groupEnd,\n\t\t\t\t\t\t\tLogType.groupCollapsed,\n\t\t\t\t\t\t\tLogType.clear\n\t\t\t\t\t\t]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"verbose\":\n\t\t\t\t\t\tacceptedTypes = new Set([\n\t\t\t\t\t\t\tLogType.error,\n\t\t\t\t\t\t\tLogType.warn,\n\t\t\t\t\t\t\tLogType.info,\n\t\t\t\t\t\t\tLogType.log,\n\t\t\t\t\t\t\tLogType.group,\n\t\t\t\t\t\t\tLogType.groupEnd,\n\t\t\t\t\t\t\tLogType.groupCollapsed,\n\t\t\t\t\t\t\tLogType.profile,\n\t\t\t\t\t\t\tLogType.profileEnd,\n\t\t\t\t\t\t\tLogType.time,\n\t\t\t\t\t\t\tLogType.status,\n\t\t\t\t\t\t\tLogType.clear\n\t\t\t\t\t\t]);\n\t\t\t\t\t\tcollapsedGroups = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tacceptedTypes = new Set();\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst cachedMakePathsRelative = makePathsRelative.bindContextCache(\n\t\t\t\t\toptions.context,\n\t\t\t\t\tcompilation.compiler.root\n\t\t\t\t);\n\t\t\t\tlet depthInCollapsedGroup = 0;\n\t\t\t\tfor (const [origin, logEntries] of compilation.logging) {\n\t\t\t\t\tconst debugMode = loggingDebug.some(fn => fn(origin));\n\t\t\t\t\tif (logging === false && !debugMode) continue;\n\t\t\t\t\t/** @type {KnownStatsLoggingEntry[]} */\n\t\t\t\t\tconst groupStack = [];\n\t\t\t\t\t/** @type {KnownStatsLoggingEntry[]} */\n\t\t\t\t\tconst rootList = [];\n\t\t\t\t\tlet currentList = rootList;\n\t\t\t\t\tlet processedLogEntries = 0;\n\t\t\t\t\tfor (const entry of logEntries) {\n\t\t\t\t\t\tlet type = entry.type;\n\t\t\t\t\t\tif (!debugMode && !acceptedTypes.has(type)) continue;\n\n\t\t\t\t\t\t// Expand groups in verbose and debug modes\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttype === LogType.groupCollapsed &&\n\t\t\t\t\t\t\t(debugMode || collapsedGroups)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\ttype = LogType.group;\n\n\t\t\t\t\t\tif (depthInCollapsedGroup === 0) {\n\t\t\t\t\t\t\tprocessedLogEntries++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (type === LogType.groupEnd) {\n\t\t\t\t\t\t\tgroupStack.pop();\n\t\t\t\t\t\t\tcurrentList =\n\t\t\t\t\t\t\t\tgroupStack.length > 0\n\t\t\t\t\t\t\t\t\t? /** @type {KnownStatsLoggingEntry[]} */ (\n\t\t\t\t\t\t\t\t\t\t\tgroupStack[groupStack.length - 1].children\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t: rootList;\n\t\t\t\t\t\t\tif (depthInCollapsedGroup > 0) depthInCollapsedGroup--;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet message;\n\t\t\t\t\t\tif (entry.type === LogType.time) {\n\t\t\t\t\t\t\tconst [label, first, second] =\n\t\t\t\t\t\t\t\t/** @type {[string, number, number]} */\n\t\t\t\t\t\t\t\t(entry.args);\n\t\t\t\t\t\t\tmessage = `${label}: ${first * 1000 + second / 1000000} ms`;\n\t\t\t\t\t\t} else if (entry.args && entry.args.length > 0) {\n\t\t\t\t\t\t\tmessage = util.format(entry.args[0], ...entry.args.slice(1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/** @type {KnownStatsLoggingEntry} */\n\t\t\t\t\t\tconst newEntry = {\n\t\t\t\t\t\t\t...entry,\n\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\ttrace: loggingTrace ? entry.trace : undefined,\n\t\t\t\t\t\t\tchildren:\n\t\t\t\t\t\t\t\ttype === LogType.group || type === LogType.groupCollapsed\n\t\t\t\t\t\t\t\t\t? []\n\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t};\n\t\t\t\t\t\tcurrentList.push(newEntry);\n\t\t\t\t\t\tif (newEntry.children) {\n\t\t\t\t\t\t\tgroupStack.push(newEntry);\n\t\t\t\t\t\t\tcurrentList = newEntry.children;\n\t\t\t\t\t\t\tif (depthInCollapsedGroup > 0) {\n\t\t\t\t\t\t\t\tdepthInCollapsedGroup++;\n\t\t\t\t\t\t\t} else if (type === LogType.groupCollapsed) {\n\t\t\t\t\t\t\t\tdepthInCollapsedGroup = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet name = cachedMakePathsRelative(origin).replace(/\\|/g, \" \");\n\t\t\t\t\tif (name in object.logging) {\n\t\t\t\t\t\tlet i = 1;\n\t\t\t\t\t\twhile (`${name}#${i}` in object.logging) {\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tname = `${name}#${i}`;\n\t\t\t\t\t}\n\t\t\t\t\tobject.logging[name] = {\n\t\t\t\t\t\tentries: rootList,\n\t\t\t\t\t\tfilteredEntries: logEntries.length - processedLogEntries,\n\t\t\t\t\t\tdebug: debugMode\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thash: (object, compilation) => {\n\t\t\tobject.hash = /** @type {string} */ (compilation.hash);\n\t\t},\n\t\tversion: object => {\n\t\t\tobject.version = require(\"../../package.json\").version;\n\t\t},\n\t\tenv: (object, compilation, context, { _env }) => {\n\t\t\tobject.env = _env;\n\t\t},\n\t\ttimings: (object, compilation) => {\n\t\t\tobject.time =\n\t\t\t\t/** @type {number} */ (compilation.endTime) -\n\t\t\t\t/** @type {number} */ (compilation.startTime);\n\t\t},\n\t\tbuiltAt: (object, compilation) => {\n\t\t\tobject.builtAt = /** @type {number} */ (compilation.endTime);\n\t\t},\n\t\tpublicPath: (object, compilation) => {\n\t\t\tobject.publicPath = compilation.getPath(\n\t\t\t\t/** @type {TemplatePath} */\n\t\t\t\t(compilation.outputOptions.publicPath)\n\t\t\t);\n\t\t},\n\t\toutputPath: (object, compilation) => {\n\t\t\tobject.outputPath = /** @type {string} */ (\n\t\t\t\tcompilation.outputOptions.path\n\t\t\t);\n\t\t},\n\t\tassets: (object, compilation, context, options, factory) => {\n\t\t\tconst { type } = context;\n\t\t\t/** @type {Map<string, Chunk[]>} */\n\t\t\tconst compilationFileToChunks = new Map();\n\t\t\t/** @type {Map<string, Chunk[]>} */\n\t\t\tconst compilationAuxiliaryFileToChunks = new Map();\n\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\tfor (const file of chunk.files) {\n\t\t\t\t\tlet array = compilationFileToChunks.get(file);\n\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tcompilationFileToChunks.set(file, array);\n\t\t\t\t\t}\n\t\t\t\t\tarray.push(chunk);\n\t\t\t\t}\n\t\t\t\tfor (const file of chunk.auxiliaryFiles) {\n\t\t\t\t\tlet array = compilationAuxiliaryFileToChunks.get(file);\n\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tcompilationAuxiliaryFileToChunks.set(file, array);\n\t\t\t\t\t}\n\t\t\t\t\tarray.push(chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/** @type {Map<string, PreprocessedAsset>} */\n\t\t\tconst assetMap = new Map();\n\t\t\t/** @type {Set<PreprocessedAsset>} */\n\t\t\tconst assets = new Set();\n\t\t\tfor (const asset of compilation.getAssets()) {\n\t\t\t\t/** @type {PreprocessedAsset} */\n\t\t\t\tconst item = {\n\t\t\t\t\t...asset,\n\t\t\t\t\ttype: \"asset\",\n\t\t\t\t\trelated: undefined\n\t\t\t\t};\n\t\t\t\tassets.add(item);\n\t\t\t\tassetMap.set(asset.name, item);\n\t\t\t}\n\t\t\tfor (const item of assetMap.values()) {\n\t\t\t\tconst related = item.info.related;\n\t\t\t\tif (!related) continue;\n\t\t\t\tfor (const type of Object.keys(related)) {\n\t\t\t\t\tconst relatedEntry = related[type];\n\t\t\t\t\tconst deps = Array.isArray(relatedEntry)\n\t\t\t\t\t\t? relatedEntry\n\t\t\t\t\t\t: [relatedEntry];\n\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\tconst depItem = assetMap.get(dep);\n\t\t\t\t\t\tif (!depItem) continue;\n\t\t\t\t\t\tassets.delete(depItem);\n\t\t\t\t\t\tdepItem.type = type;\n\t\t\t\t\t\titem.related = item.related || [];\n\t\t\t\t\t\titem.related.push(depItem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tobject.assetsByChunkName = {};\n\t\t\tfor (const [file, chunks] of compilationFileToChunks) {\n\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\tconst name = chunk.name;\n\t\t\t\t\tif (!name) continue;\n\t\t\t\t\tif (\n\t\t\t\t\t\t!Object.prototype.hasOwnProperty.call(\n\t\t\t\t\t\t\tobject.assetsByChunkName,\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tobject.assetsByChunkName[name] = [];\n\t\t\t\t\t}\n\t\t\t\t\tobject.assetsByChunkName[name].push(file);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst groupedAssets = factory.create(\n\t\t\t\t`${type}.assets`,\n\t\t\t\tArray.from(assets),\n\t\t\t\t{\n\t\t\t\t\t...context,\n\t\t\t\t\tcompilationFileToChunks,\n\t\t\t\t\tcompilationAuxiliaryFileToChunks\n\t\t\t\t}\n\t\t\t);\n\t\t\tconst limited = spaceLimited(\n\t\t\t\tgroupedAssets,\n\t\t\t\t/** @type {number} */ (options.assetsSpace)\n\t\t\t);\n\t\t\tobject.assets = limited.children;\n\t\t\tobject.filteredAssets = limited.filteredChildren;\n\t\t},\n\t\tchunks: (object, compilation, context, options, factory) => {\n\t\t\tconst { type } = context;\n\t\t\tobject.chunks = factory.create(\n\t\t\t\t`${type}.chunks`,\n\t\t\t\tArray.from(compilation.chunks),\n\t\t\t\tcontext\n\t\t\t);\n\t\t},\n\t\tmodules: (object, compilation, context, options, factory) => {\n\t\t\tconst { type } = context;\n\t\t\tconst array = Array.from(compilation.modules);\n\t\t\tconst groupedModules = factory.create(`${type}.modules`, array, context);\n\t\t\tconst limited = spaceLimited(groupedModules, options.modulesSpace);\n\t\t\tobject.modules = limited.children;\n\t\t\tobject.filteredModules = limited.filteredChildren;\n\t\t},\n\t\tentrypoints: (\n\t\t\tobject,\n\t\t\tcompilation,\n\t\t\tcontext,\n\t\t\t{ entrypoints, chunkGroups, chunkGroupAuxiliary, chunkGroupChildren },\n\t\t\tfactory\n\t\t) => {\n\t\t\tconst { type } = context;\n\t\t\tconst array = Array.from(compilation.entrypoints, ([key, value]) => ({\n\t\t\t\tname: key,\n\t\t\t\tchunkGroup: value\n\t\t\t}));\n\t\t\tif (entrypoints === \"auto\" && !chunkGroups) {\n\t\t\t\tif (array.length > 5) return;\n\t\t\t\tif (\n\t\t\t\t\t!chunkGroupChildren &&\n\t\t\t\t\tarray.every(({ chunkGroup }) => {\n\t\t\t\t\t\tif (chunkGroup.chunks.length !== 1) return false;\n\t\t\t\t\t\tconst chunk = chunkGroup.chunks[0];\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\tchunk.files.size === 1 &&\n\t\t\t\t\t\t\t(!chunkGroupAuxiliary || chunk.auxiliaryFiles.size === 0)\n\t\t\t\t\t\t);\n\t\t\t\t\t})\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tobject.entrypoints = factory.create(\n\t\t\t\t`${type}.entrypoints`,\n\t\t\t\tarray,\n\t\t\t\tcontext\n\t\t\t);\n\t\t},\n\t\tchunkGroups: (object, compilation, context, options, factory) => {\n\t\t\tconst { type } = context;\n\t\t\tconst array = Array.from(\n\t\t\t\tcompilation.namedChunkGroups,\n\t\t\t\t([key, value]) => ({\n\t\t\t\t\tname: key,\n\t\t\t\t\tchunkGroup: value\n\t\t\t\t})\n\t\t\t);\n\t\t\tobject.namedChunkGroups = factory.create(\n\t\t\t\t`${type}.namedChunkGroups`,\n\t\t\t\tarray,\n\t\t\t\tcontext\n\t\t\t);\n\t\t},\n\t\terrors: (object, compilation, context, options, factory) => {\n\t\t\tconst { type, cachedGetErrors } = context;\n\t\t\tconst rawErrors = cachedGetErrors(compilation);\n\t\t\tconst factorizedErrors = factory.create(\n\t\t\t\t`${type}.errors`,\n\t\t\t\tcachedGetErrors(compilation),\n\t\t\t\tcontext\n\t\t\t);\n\t\t\tlet filtered = 0;\n\t\t\tif (options.errorDetails === \"auto\" && rawErrors.length >= 3) {\n\t\t\t\tfiltered = rawErrors\n\t\t\t\t\t.map(e => typeof e !== \"string\" && e.details)\n\t\t\t\t\t.filter(Boolean).length;\n\t\t\t}\n\t\t\tif (\n\t\t\t\toptions.errorDetails === true ||\n\t\t\t\t!Number.isFinite(options.errorsSpace)\n\t\t\t) {\n\t\t\t\tobject.errors = factorizedErrors;\n\t\t\t\tif (filtered) object.filteredErrorDetailsCount = filtered;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst [errors, filteredBySpace] = errorsSpaceLimit(\n\t\t\t\tfactorizedErrors,\n\t\t\t\t/** @type {number} */\n\t\t\t\t(options.errorsSpace)\n\t\t\t);\n\t\t\tobject.filteredErrorDetailsCount = filtered + filteredBySpace;\n\t\t\tobject.errors = errors;\n\t\t},\n\t\terrorsCount: (object, compilation, { cachedGetErrors }) => {\n\t\t\tobject.errorsCount = countWithChildren(compilation, c =>\n\t\t\t\tcachedGetErrors(c)\n\t\t\t);\n\t\t},\n\t\twarnings: (object, compilation, context, options, factory) => {\n\t\t\tconst { type, cachedGetWarnings } = context;\n\t\t\tconst rawWarnings = factory.create(\n\t\t\t\t`${type}.warnings`,\n\t\t\t\tcachedGetWarnings(compilation),\n\t\t\t\tcontext\n\t\t\t);\n\t\t\tlet filtered = 0;\n\t\t\tif (options.errorDetails === \"auto\") {\n\t\t\t\tfiltered = cachedGetWarnings(compilation)\n\t\t\t\t\t.map(e => typeof e !== \"string\" && e.details)\n\t\t\t\t\t.filter(Boolean).length;\n\t\t\t}\n\t\t\tif (\n\t\t\t\toptions.errorDetails === true ||\n\t\t\t\t!Number.isFinite(options.warningsSpace)\n\t\t\t) {\n\t\t\t\tobject.warnings = rawWarnings;\n\t\t\t\tif (filtered) object.filteredWarningDetailsCount = filtered;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst [warnings, filteredBySpace] = errorsSpaceLimit(\n\t\t\t\trawWarnings,\n\t\t\t\t/** @type {number} */\n\t\t\t\t(options.warningsSpace)\n\t\t\t);\n\t\t\tobject.filteredWarningDetailsCount = filtered + filteredBySpace;\n\t\t\tobject.warnings = warnings;\n\t\t},\n\t\twarningsCount: (\n\t\t\tobject,\n\t\t\tcompilation,\n\t\t\tcontext,\n\t\t\t{ warningsFilter },\n\t\t\tfactory\n\t\t) => {\n\t\t\tconst { type, cachedGetWarnings } = context;\n\t\t\tobject.warningsCount = countWithChildren(compilation, (c, childType) => {\n\t\t\t\tif (\n\t\t\t\t\t!warningsFilter &&\n\t\t\t\t\t/** @type {((warning: StatsError, textValue: string) => boolean)[]} */\n\t\t\t\t\t(warningsFilter).length === 0\n\t\t\t\t)\n\t\t\t\t\treturn cachedGetWarnings(c);\n\t\t\t\treturn factory\n\t\t\t\t\t.create(`${type}${childType}.warnings`, cachedGetWarnings(c), context)\n\t\t\t\t\t.filter(\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {TODO} warning warning\n\t\t\t\t\t\t * @returns {boolean} result\n\t\t\t\t\t\t */\n\t\t\t\t\t\twarning => {\n\t\t\t\t\t\t\tconst warningString = Object.keys(warning)\n\t\t\t\t\t\t\t\t.map(\n\t\t\t\t\t\t\t\t\tkey =>\n\t\t\t\t\t\t\t\t\t\t`${warning[/** @type {keyof KnownStatsError} */ (key)]}`\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t.join(\"\\n\");\n\t\t\t\t\t\t\treturn !warningsFilter.some(filter =>\n\t\t\t\t\t\t\t\tfilter(warning, warningString)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t});\n\t\t},\n\t\tchildren: (object, compilation, context, options, factory) => {\n\t\t\tconst { type } = context;\n\t\t\tobject.children = factory.create(\n\t\t\t\t`${type}.children`,\n\t\t\t\tcompilation.children,\n\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\t},\n\tasset: {\n\t\t_: (object, asset, context, options, factory) => {\n\t\t\tconst { compilation } = context;\n\t\t\tobject.type = asset.type;\n\t\t\tobject.name = asset.name;\n\t\t\tobject.size = asset.source.size();\n\t\t\tobject.emitted = compilation.emittedAssets.has(asset.name);\n\t\t\tobject.comparedForEmit = compilation.comparedForEmitAssets.has(\n\t\t\t\tasset.name\n\t\t\t);\n\t\t\tconst cached = !object.emitted && !object.comparedForEmit;\n\t\t\tobject.cached = cached;\n\t\t\tobject.info = asset.info;\n\t\t\tif (!cached || options.cachedAssets) {\n\t\t\t\tObject.assign(\n\t\t\t\t\tobject,\n\t\t\t\t\tfactory.create(`${context.type}$visible`, asset, context)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\tasset$visible: {\n\t\t_: (\n\t\t\tobject,\n\t\t\tasset,\n\t\t\t{ compilation, compilationFileToChunks, compilationAuxiliaryFileToChunks }\n\t\t) => {\n\t\t\tconst chunks = compilationFileToChunks.get(asset.name) || [];\n\t\t\tconst auxiliaryChunks =\n\t\t\t\tcompilationAuxiliaryFileToChunks.get(asset.name) || [];\n\t\t\tobject.chunkNames = uniqueOrderedArray(\n\t\t\t\tchunks,\n\t\t\t\tc => (c.name ? [c.name] : []),\n\t\t\t\tcompareIds\n\t\t\t);\n\t\t\tobject.chunkIdHints = uniqueOrderedArray(\n\t\t\t\tchunks,\n\t\t\t\tc => Array.from(c.idNameHints),\n\t\t\t\tcompareIds\n\t\t\t);\n\t\t\tobject.auxiliaryChunkNames = uniqueOrderedArray(\n\t\t\t\tauxiliaryChunks,\n\t\t\t\tc => (c.name ? [c.name] : []),\n\t\t\t\tcompareIds\n\t\t\t);\n\t\t\tobject.auxiliaryChunkIdHints = uniqueOrderedArray(\n\t\t\t\tauxiliaryChunks,\n\t\t\t\tc => Array.from(c.idNameHints),\n\t\t\t\tcompareIds\n\t\t\t);\n\t\t\tobject.filteredRelated = asset.related ? asset.related.length : undefined;\n\t\t},\n\t\trelatedAssets: (object, asset, context, options, factory) => {\n\t\t\tconst { type } = context;\n\t\t\tobject.related = factory.create(\n\t\t\t\t`${type.slice(0, -8)}.related`,\n\t\t\t\tasset.related || [],\n\t\t\t\tcontext\n\t\t\t);\n\t\t\tobject.filteredRelated = asset.related\n\t\t\t\t? asset.related.length -\n\t\t\t\t\t/** @type {StatsAsset[]} */ (object.related).length\n\t\t\t\t: undefined;\n\t\t},\n\t\tids: (\n\t\t\tobject,\n\t\t\tasset,\n\t\t\t{ compilationFileToChunks, compilationAuxiliaryFileToChunks }\n\t\t) => {\n\t\t\tconst chunks = compilationFileToChunks.get(asset.name) || [];\n\t\t\tconst auxiliaryChunks =\n\t\t\t\tcompilationAuxiliaryFileToChunks.get(asset.name) || [];\n\t\t\tobject.chunks = uniqueOrderedArray(\n\t\t\t\tchunks,\n\t\t\t\tc => /** @type {ChunkId[]} */ (c.ids),\n\t\t\t\tcompareIds\n\t\t\t);\n\t\t\tobject.auxiliaryChunks = uniqueOrderedArray(\n\t\t\t\tauxiliaryChunks,\n\t\t\t\tc => /** @type {ChunkId[]} */ (c.ids),\n\t\t\t\tcompareIds\n\t\t\t);\n\t\t},\n\t\tperformance: (object, asset) => {\n\t\t\tobject.isOverSizeLimit = SizeLimitsPlugin.isOverSizeLimit(asset.source);\n\t\t}\n\t},\n\tchunkGroup: {\n\t\t_: (\n\t\t\tobject,\n\t\t\t{ name, chunkGroup },\n\t\t\t{ compilation, compilation: { moduleGraph, chunkGraph } },\n\t\t\t{ ids, chunkGroupAuxiliary, chunkGroupChildren, chunkGroupMaxAssets }\n\t\t) => {\n\t\t\tconst children =\n\t\t\t\tchunkGroupChildren &&\n\t\t\t\tchunkGroup.getChildrenByOrders(moduleGraph, chunkGraph);\n\t\t\t/**\n\t\t\t * @param {string} name Name\n\t\t\t * @returns {{ name: string, size: number }} Asset object\n\t\t\t */\n\t\t\tconst toAsset = name => {\n\t\t\t\tconst asset = compilation.getAsset(name);\n\t\t\t\treturn {\n\t\t\t\t\tname,\n\t\t\t\t\tsize: /** @type {number} */ (asset ? asset.info.size : -1)\n\t\t\t\t};\n\t\t\t};\n\t\t\t/** @type {(total: number, asset: { size: number }) => number} */\n\t\t\tconst sizeReducer = (total, { size }) => total + size;\n\t\t\tconst assets = uniqueArray(chunkGroup.chunks, c => c.files).map(toAsset);\n\t\t\tconst auxiliaryAssets = uniqueOrderedArray(\n\t\t\t\tchunkGroup.chunks,\n\t\t\t\tc => c.auxiliaryFiles,\n\t\t\t\tcompareIds\n\t\t\t).map(toAsset);\n\t\t\tconst assetsSize = assets.reduce(sizeReducer, 0);\n\t\t\tconst auxiliaryAssetsSize = auxiliaryAssets.reduce(sizeReducer, 0);\n\t\t\t/** @type {KnownStatsChunkGroup} */\n\t\t\tconst statsChunkGroup = {\n\t\t\t\tname,\n\t\t\t\tchunks: ids\n\t\t\t\t\t? /** @type {ChunkId[]} */ (chunkGroup.chunks.map(c => c.id))\n\t\t\t\t\t: undefined,\n\t\t\t\tassets: assets.length <= chunkGroupMaxAssets ? assets : undefined,\n\t\t\t\tfilteredAssets:\n\t\t\t\t\tassets.length <= chunkGroupMaxAssets ? 0 : assets.length,\n\t\t\t\tassetsSize,\n\t\t\t\tauxiliaryAssets:\n\t\t\t\t\tchunkGroupAuxiliary && auxiliaryAssets.length <= chunkGroupMaxAssets\n\t\t\t\t\t\t? auxiliaryAssets\n\t\t\t\t\t\t: undefined,\n\t\t\t\tfilteredAuxiliaryAssets:\n\t\t\t\t\tchunkGroupAuxiliary && auxiliaryAssets.length <= chunkGroupMaxAssets\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: auxiliaryAssets.length,\n\t\t\t\tauxiliaryAssetsSize,\n\t\t\t\tchildren: children\n\t\t\t\t\t? mapObject(children, groups =>\n\t\t\t\t\t\t\tgroups.map(group => {\n\t\t\t\t\t\t\t\tconst assets = uniqueArray(group.chunks, c => c.files).map(\n\t\t\t\t\t\t\t\t\ttoAsset\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst auxiliaryAssets = uniqueOrderedArray(\n\t\t\t\t\t\t\t\t\tgroup.chunks,\n\t\t\t\t\t\t\t\t\tc => c.auxiliaryFiles,\n\t\t\t\t\t\t\t\t\tcompareIds\n\t\t\t\t\t\t\t\t).map(toAsset);\n\n\t\t\t\t\t\t\t\t/** @type {KnownStatsChunkGroup} */\n\t\t\t\t\t\t\t\tconst childStatsChunkGroup = {\n\t\t\t\t\t\t\t\t\tname: group.name,\n\t\t\t\t\t\t\t\t\tchunks: ids\n\t\t\t\t\t\t\t\t\t\t? /** @type {ChunkId[]} */\n\t\t\t\t\t\t\t\t\t\t\t(group.chunks.map(c => c.id))\n\t\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\t\t\tassets:\n\t\t\t\t\t\t\t\t\t\tassets.length <= chunkGroupMaxAssets ? assets : undefined,\n\t\t\t\t\t\t\t\t\tfilteredAssets:\n\t\t\t\t\t\t\t\t\t\tassets.length <= chunkGroupMaxAssets ? 0 : assets.length,\n\t\t\t\t\t\t\t\t\tauxiliaryAssets:\n\t\t\t\t\t\t\t\t\t\tchunkGroupAuxiliary &&\n\t\t\t\t\t\t\t\t\t\tauxiliaryAssets.length <= chunkGroupMaxAssets\n\t\t\t\t\t\t\t\t\t\t\t? auxiliaryAssets\n\t\t\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\t\t\tfilteredAuxiliaryAssets:\n\t\t\t\t\t\t\t\t\t\tchunkGroupAuxiliary &&\n\t\t\t\t\t\t\t\t\t\tauxiliaryAssets.length <= chunkGroupMaxAssets\n\t\t\t\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t\t\t\t: auxiliaryAssets.length\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\treturn childStatsChunkGroup;\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t)\n\t\t\t\t\t: undefined,\n\t\t\t\tchildAssets: children\n\t\t\t\t\t? mapObject(children, groups => {\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\tconst set = new Set();\n\t\t\t\t\t\t\tfor (const group of groups) {\n\t\t\t\t\t\t\t\tfor (const chunk of group.chunks) {\n\t\t\t\t\t\t\t\t\tfor (const asset of chunk.files) {\n\t\t\t\t\t\t\t\t\t\tset.add(asset);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn Array.from(set);\n\t\t\t\t\t\t})\n\t\t\t\t\t: undefined\n\t\t\t};\n\t\t\tObject.assign(object, statsChunkGroup);\n\t\t},\n\t\tperformance: (object, { chunkGroup }) => {\n\t\t\tobject.isOverSizeLimit = SizeLimitsPlugin.isOverSizeLimit(chunkGroup);\n\t\t}\n\t},\n\tmodule: {\n\t\t_: (object, module, context, options, factory) => {\n\t\t\tconst { type } = context;\n\t\t\tconst compilation = /** @type {Compilation} */ (context.compilation);\n\t\t\tconst built = compilation.builtModules.has(module);\n\t\t\tconst codeGenerated = compilation.codeGeneratedModules.has(module);\n\t\t\tconst buildTimeExecuted =\n\t\t\t\tcompilation.buildTimeExecutedModules.has(module);\n\t\t\t/** @type {{[x: string]: number}} */\n\t\t\tconst sizes = {};\n\t\t\tfor (const sourceType of module.getSourceTypes()) {\n\t\t\t\tsizes[sourceType] = module.size(sourceType);\n\t\t\t}\n\t\t\t/** @type {KnownStatsModule} */\n\t\t\tconst statsModule = {\n\t\t\t\ttype: \"module\",\n\t\t\t\tmoduleType: module.type,\n\t\t\t\tlayer: module.layer,\n\t\t\t\tsize: module.size(),\n\t\t\t\tsizes,\n\t\t\t\tbuilt,\n\t\t\t\tcodeGenerated,\n\t\t\t\tbuildTimeExecuted,\n\t\t\t\tcached: !built && !codeGenerated\n\t\t\t};\n\t\t\tObject.assign(object, statsModule);\n\n\t\t\tif (built || codeGenerated || options.cachedModules) {\n\t\t\t\tObject.assign(\n\t\t\t\t\tobject,\n\t\t\t\t\tfactory.create(`${type}$visible`, module, context)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\tmodule$visible: {\n\t\t_: (object, module, context, { requestShortener }, factory) => {\n\t\t\tconst { type, rootModules } = context;\n\t\t\tconst compilation = /** @type {Compilation} */ (context.compilation);\n\t\t\tconst { moduleGraph } = compilation;\n\t\t\t/** @type {Module[]} */\n\t\t\tconst path = [];\n\t\t\tconst issuer = moduleGraph.getIssuer(module);\n\t\t\tlet current = issuer;\n\t\t\twhile (current) {\n\t\t\t\tpath.push(current);\n\t\t\t\tcurrent = moduleGraph.getIssuer(current);\n\t\t\t}\n\t\t\tpath.reverse();\n\t\t\tconst profile = moduleGraph.getProfile(module);\n\t\t\tconst errors = module.getErrors();\n\t\t\tconst errorsCount = errors !== undefined ? countIterable(errors) : 0;\n\t\t\tconst warnings = module.getWarnings();\n\t\t\tconst warningsCount =\n\t\t\t\twarnings !== undefined ? countIterable(warnings) : 0;\n\t\t\t/** @type {{[x: string]: number}} */\n\t\t\tconst sizes = {};\n\t\t\tfor (const sourceType of module.getSourceTypes()) {\n\t\t\t\tsizes[sourceType] = module.size(sourceType);\n\t\t\t}\n\t\t\t/** @type {KnownStatsModule} */\n\t\t\tconst statsModule = {\n\t\t\t\tidentifier: module.identifier(),\n\t\t\t\tname: module.readableIdentifier(requestShortener),\n\t\t\t\tnameForCondition: module.nameForCondition(),\n\t\t\t\tindex: /** @type {number} */ (moduleGraph.getPreOrderIndex(module)),\n\t\t\t\tpreOrderIndex: /** @type {number} */ (\n\t\t\t\t\tmoduleGraph.getPreOrderIndex(module)\n\t\t\t\t),\n\t\t\t\tindex2: /** @type {number} */ (moduleGraph.getPostOrderIndex(module)),\n\t\t\t\tpostOrderIndex: /** @type {number} */ (\n\t\t\t\t\tmoduleGraph.getPostOrderIndex(module)\n\t\t\t\t),\n\t\t\t\tcacheable: /** @type {BuildInfo} */ (module.buildInfo).cacheable,\n\t\t\t\toptional: module.isOptional(moduleGraph),\n\t\t\t\torphan:\n\t\t\t\t\t!type.endsWith(\"module.modules[].module$visible\") &&\n\t\t\t\t\tcompilation.chunkGraph.getNumberOfModuleChunks(module) === 0,\n\t\t\t\tdependent: rootModules ? !rootModules.has(module) : undefined,\n\t\t\t\tissuer: issuer && issuer.identifier(),\n\t\t\t\tissuerName: issuer && issuer.readableIdentifier(requestShortener),\n\t\t\t\tissuerPath:\n\t\t\t\t\tissuer &&\n\t\t\t\t\tfactory.create(`${type.slice(0, -8)}.issuerPath`, path, context),\n\t\t\t\tfailed: errorsCount > 0,\n\t\t\t\terrors: errorsCount,\n\t\t\t\twarnings: warningsCount\n\t\t\t};\n\t\t\tObject.assign(object, statsModule);\n\t\t\tif (profile) {\n\t\t\t\tobject.profile = factory.create(\n\t\t\t\t\t`${type.slice(0, -8)}.profile`,\n\t\t\t\t\tprofile,\n\t\t\t\t\tcontext\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\tids: (object, module, { compilation: { chunkGraph, moduleGraph } }) => {\n\t\t\tobject.id = /** @type {ModuleId} */ (chunkGraph.getModuleId(module));\n\t\t\tconst issuer = moduleGraph.getIssuer(module);\n\t\t\tobject.issuerId = issuer && chunkGraph.getModuleId(issuer);\n\t\t\tobject.chunks =\n\t\t\t\t/** @type {ChunkId[]} */\n\t\t\t\t(\n\t\t\t\t\tArray.from(\n\t\t\t\t\t\tchunkGraph.getOrderedModuleChunksIterable(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tcompareChunksById\n\t\t\t\t\t\t),\n\t\t\t\t\t\tchunk => chunk.id\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t},\n\t\tmoduleAssets: (object, module) => {\n\t\t\tobject.assets = /** @type {BuildInfo} */ (module.buildInfo).assets\n\t\t\t\t? Object.keys(/** @type {BuildInfo} */ (module.buildInfo).assets)\n\t\t\t\t: [];\n\t\t},\n\t\treasons: (object, module, context, options, factory) => {\n\t\t\tconst {\n\t\t\t\ttype,\n\t\t\t\tcompilation: { moduleGraph }\n\t\t\t} = context;\n\t\t\tconst groupsReasons = factory.create(\n\t\t\t\t`${type.slice(0, -8)}.reasons`,\n\t\t\t\tArray.from(moduleGraph.getIncomingConnections(module)),\n\t\t\t\tcontext\n\t\t\t);\n\t\t\tconst limited = spaceLimited(\n\t\t\t\tgroupsReasons,\n\t\t\t\t/** @type {number} */\n\t\t\t\t(options.reasonsSpace)\n\t\t\t);\n\t\t\tobject.reasons = limited.children;\n\t\t\tobject.filteredReasons = limited.filteredChildren;\n\t\t},\n\t\tusedExports: (\n\t\t\tobject,\n\t\t\tmodule,\n\t\t\t{ runtime, compilation: { moduleGraph } }\n\t\t) => {\n\t\t\tconst usedExports = moduleGraph.getUsedExports(module, runtime);\n\t\t\tif (usedExports === null) {\n\t\t\t\tobject.usedExports = null;\n\t\t\t} else if (typeof usedExports === \"boolean\") {\n\t\t\t\tobject.usedExports = usedExports;\n\t\t\t} else {\n\t\t\t\tobject.usedExports = Array.from(usedExports);\n\t\t\t}\n\t\t},\n\t\tprovidedExports: (object, module, { compilation: { moduleGraph } }) => {\n\t\t\tconst providedExports = moduleGraph.getProvidedExports(module);\n\t\t\tobject.providedExports = Array.isArray(providedExports)\n\t\t\t\t? providedExports\n\t\t\t\t: null;\n\t\t},\n\t\toptimizationBailout: (\n\t\t\tobject,\n\t\t\tmodule,\n\t\t\t{ compilation: { moduleGraph } },\n\t\t\t{ requestShortener }\n\t\t) => {\n\t\t\tobject.optimizationBailout = moduleGraph\n\t\t\t\t.getOptimizationBailout(module)\n\t\t\t\t.map(item => {\n\t\t\t\t\tif (typeof item === \"function\") return item(requestShortener);\n\t\t\t\t\treturn item;\n\t\t\t\t});\n\t\t},\n\t\tdepth: (object, module, { compilation: { moduleGraph } }) => {\n\t\t\tobject.depth = moduleGraph.getDepth(module);\n\t\t},\n\t\tnestedModules: (object, module, context, options, factory) => {\n\t\t\tconst { type } = context;\n\t\t\tconst innerModules = /** @type {Module & { modules?: Module[] }} */ (\n\t\t\t\tmodule\n\t\t\t).modules;\n\t\t\tif (Array.isArray(innerModules)) {\n\t\t\t\tconst groupedModules = factory.create(\n\t\t\t\t\t`${type.slice(0, -8)}.modules`,\n\t\t\t\t\tinnerModules,\n\t\t\t\t\tcontext\n\t\t\t\t);\n\t\t\t\tconst limited = spaceLimited(\n\t\t\t\t\tgroupedModules,\n\t\t\t\t\toptions.nestedModulesSpace\n\t\t\t\t);\n\t\t\t\tobject.modules = limited.children;\n\t\t\t\tobject.filteredModules = limited.filteredChildren;\n\t\t\t}\n\t\t},\n\t\tsource: (object, module) => {\n\t\t\tconst originalSource = module.originalSource();\n\t\t\tif (originalSource) {\n\t\t\t\tobject.source = originalSource.source();\n\t\t\t}\n\t\t}\n\t},\n\tprofile: {\n\t\t_: (object, profile) => {\n\t\t\t/** @type {KnownStatsProfile} */\n\t\t\tconst statsProfile = {\n\t\t\t\ttotal:\n\t\t\t\t\tprofile.factory +\n\t\t\t\t\tprofile.restoring +\n\t\t\t\t\tprofile.integration +\n\t\t\t\t\tprofile.building +\n\t\t\t\t\tprofile.storing,\n\t\t\t\tresolving: profile.factory,\n\t\t\t\trestoring: profile.restoring,\n\t\t\t\tbuilding: profile.building,\n\t\t\t\tintegration: profile.integration,\n\t\t\t\tstoring: profile.storing,\n\t\t\t\tadditionalResolving: profile.additionalFactories,\n\t\t\t\tadditionalIntegration: profile.additionalIntegration,\n\t\t\t\t// TODO remove this in webpack 6\n\t\t\t\tfactory: profile.factory,\n\t\t\t\t// TODO remove this in webpack 6\n\t\t\t\tdependencies: profile.additionalFactories\n\t\t\t};\n\t\t\tObject.assign(object, statsProfile);\n\t\t}\n\t},\n\tmoduleIssuer: {\n\t\t_: (object, module, context, { requestShortener }, factory) => {\n\t\t\tconst { type } = context;\n\t\t\tconst compilation = /** @type {Compilation} */ (context.compilation);\n\t\t\tconst { moduleGraph } = compilation;\n\t\t\tconst profile = moduleGraph.getProfile(module);\n\t\t\t/** @type {Partial<KnownStatsModuleIssuer>} */\n\t\t\tconst statsModuleIssuer = {\n\t\t\t\tidentifier: module.identifier(),\n\t\t\t\tname: module.readableIdentifier(requestShortener)\n\t\t\t};\n\t\t\tObject.assign(object, statsModuleIssuer);\n\t\t\tif (profile) {\n\t\t\t\tobject.profile = factory.create(`${type}.profile`, profile, context);\n\t\t\t}\n\t\t},\n\t\tids: (object, module, { compilation: { chunkGraph } }) => {\n\t\t\tobject.id = /** @type {ModuleId} */ (chunkGraph.getModuleId(module));\n\t\t}\n\t},\n\tmoduleReason: {\n\t\t_: (object, reason, { runtime }, { requestShortener }) => {\n\t\t\tconst dep = reason.dependency;\n\t\t\tconst moduleDep =\n\t\t\t\tdep && dep instanceof ModuleDependency ? dep : undefined;\n\t\t\t/** @type {KnownStatsModuleReason} */\n\t\t\tconst statsModuleReason = {\n\t\t\t\tmoduleIdentifier: reason.originModule\n\t\t\t\t\t? reason.originModule.identifier()\n\t\t\t\t\t: null,\n\t\t\t\tmodule: reason.originModule\n\t\t\t\t\t? reason.originModule.readableIdentifier(requestShortener)\n\t\t\t\t\t: null,\n\t\t\t\tmoduleName: reason.originModule\n\t\t\t\t\t? reason.originModule.readableIdentifier(requestShortener)\n\t\t\t\t\t: null,\n\t\t\t\tresolvedModuleIdentifier: reason.resolvedOriginModule\n\t\t\t\t\t? reason.resolvedOriginModule.identifier()\n\t\t\t\t\t: null,\n\t\t\t\tresolvedModule: reason.resolvedOriginModule\n\t\t\t\t\t? reason.resolvedOriginModule.readableIdentifier(requestShortener)\n\t\t\t\t\t: null,\n\t\t\t\ttype: reason.dependency ? reason.dependency.type : null,\n\t\t\t\tactive: reason.isActive(runtime),\n\t\t\t\texplanation: reason.explanation,\n\t\t\t\tuserRequest: (moduleDep && moduleDep.userRequest) || null\n\t\t\t};\n\t\t\tObject.assign(object, statsModuleReason);\n\t\t\tif (reason.dependency) {\n\t\t\t\tconst locInfo = formatLocation(reason.dependency.loc);\n\t\t\t\tif (locInfo) {\n\t\t\t\t\tobject.loc = locInfo;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tids: (object, reason, { compilation: { chunkGraph } }) => {\n\t\t\tobject.moduleId = reason.originModule\n\t\t\t\t? chunkGraph.getModuleId(reason.originModule)\n\t\t\t\t: null;\n\t\t\tobject.resolvedModuleId = reason.resolvedOriginModule\n\t\t\t\t? chunkGraph.getModuleId(reason.resolvedOriginModule)\n\t\t\t\t: null;\n\t\t}\n\t},\n\tchunk: {\n\t\t_: (object, chunk, { makePathsRelative, compilation: { chunkGraph } }) => {\n\t\t\tconst childIdByOrder = chunk.getChildIdsByOrders(chunkGraph);\n\n\t\t\t/** @type {KnownStatsChunk} */\n\t\t\tconst statsChunk = {\n\t\t\t\trendered: chunk.rendered,\n\t\t\t\tinitial: chunk.canBeInitial(),\n\t\t\t\tentry: chunk.hasRuntime(),\n\t\t\t\trecorded: AggressiveSplittingPlugin.wasChunkRecorded(chunk),\n\t\t\t\treason: chunk.chunkReason,\n\t\t\t\tsize: chunkGraph.getChunkModulesSize(chunk),\n\t\t\t\tsizes: chunkGraph.getChunkModulesSizes(chunk),\n\t\t\t\tnames: chunk.name ? [chunk.name] : [],\n\t\t\t\tidHints: Array.from(chunk.idNameHints),\n\t\t\t\truntime:\n\t\t\t\t\tchunk.runtime === undefined\n\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t: typeof chunk.runtime === \"string\"\n\t\t\t\t\t\t\t? [makePathsRelative(chunk.runtime)]\n\t\t\t\t\t\t\t: Array.from(chunk.runtime.sort(), makePathsRelative),\n\t\t\t\tfiles: Array.from(chunk.files),\n\t\t\t\tauxiliaryFiles: Array.from(chunk.auxiliaryFiles).sort(compareIds),\n\t\t\t\thash: /** @type {string} */ (chunk.renderedHash),\n\t\t\t\tchildrenByOrder: childIdByOrder\n\t\t\t};\n\t\t\tObject.assign(object, statsChunk);\n\t\t},\n\t\tids: (object, chunk) => {\n\t\t\tobject.id = /** @type {ChunkId} */ (chunk.id);\n\t\t},\n\t\tchunkRelations: (object, chunk, { compilation: { chunkGraph } }) => {\n\t\t\t/** @type {Set<string|number>} */\n\t\t\tconst parents = new Set();\n\t\t\t/** @type {Set<string|number>} */\n\t\t\tconst children = new Set();\n\t\t\t/** @type {Set<string|number>} */\n\t\t\tconst siblings = new Set();\n\n\t\t\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\t\t\tfor (const parentGroup of chunkGroup.parentsIterable) {\n\t\t\t\t\tfor (const chunk of parentGroup.chunks) {\n\t\t\t\t\t\tparents.add(/** @type {ChunkId} */ (chunk.id));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const childGroup of chunkGroup.childrenIterable) {\n\t\t\t\t\tfor (const chunk of childGroup.chunks) {\n\t\t\t\t\t\tchildren.add(/** @type {ChunkId} */ (chunk.id));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const sibling of chunkGroup.chunks) {\n\t\t\t\t\tif (sibling !== chunk)\n\t\t\t\t\t\tsiblings.add(/** @type {ChunkId} */ (sibling.id));\n\t\t\t\t}\n\t\t\t}\n\t\t\tobject.siblings = Array.from(siblings).sort(compareIds);\n\t\t\tobject.parents = Array.from(parents).sort(compareIds);\n\t\t\tobject.children = Array.from(children).sort(compareIds);\n\t\t},\n\t\tchunkModules: (object, chunk, context, options, factory) => {\n\t\t\tconst {\n\t\t\t\ttype,\n\t\t\t\tcompilation: { chunkGraph }\n\t\t\t} = context;\n\t\t\tconst array = chunkGraph.getChunkModules(chunk);\n\t\t\tconst groupedModules = factory.create(`${type}.modules`, array, {\n\t\t\t\t...context,\n\t\t\t\truntime: chunk.runtime,\n\t\t\t\trootModules: new Set(chunkGraph.getChunkRootModules(chunk))\n\t\t\t});\n\t\t\tconst limited = spaceLimited(groupedModules, options.chunkModulesSpace);\n\t\t\tobject.modules = limited.children;\n\t\t\tobject.filteredModules = limited.filteredChildren;\n\t\t},\n\t\tchunkOrigins: (object, chunk, context, options, factory) => {\n\t\t\tconst {\n\t\t\t\ttype,\n\t\t\t\tcompilation: { chunkGraph }\n\t\t\t} = context;\n\t\t\t/** @type {Set<string>} */\n\t\t\tconst originsKeySet = new Set();\n\t\t\tconst origins = [];\n\t\t\tfor (const g of chunk.groupsIterable) {\n\t\t\t\torigins.push(...g.origins);\n\t\t\t}\n\t\t\tconst array = origins.filter(origin => {\n\t\t\t\tconst key = [\n\t\t\t\t\torigin.module ? chunkGraph.getModuleId(origin.module) : undefined,\n\t\t\t\t\tformatLocation(origin.loc),\n\t\t\t\t\torigin.request\n\t\t\t\t].join();\n\t\t\t\tif (originsKeySet.has(key)) return false;\n\t\t\t\toriginsKeySet.add(key);\n\t\t\t\treturn true;\n\t\t\t});\n\t\t\tobject.origins = factory.create(`${type}.origins`, array, context);\n\t\t}\n\t},\n\tchunkOrigin: {\n\t\t_: (object, origin, context, { requestShortener }) => {\n\t\t\t/** @type {KnownStatsChunkOrigin} */\n\t\t\tconst statsChunkOrigin = {\n\t\t\t\tmodule: origin.module ? origin.module.identifier() : \"\",\n\t\t\t\tmoduleIdentifier: origin.module ? origin.module.identifier() : \"\",\n\t\t\t\tmoduleName: origin.module\n\t\t\t\t\t? origin.module.readableIdentifier(requestShortener)\n\t\t\t\t\t: \"\",\n\t\t\t\tloc: formatLocation(origin.loc),\n\t\t\t\trequest: origin.request\n\t\t\t};\n\t\t\tObject.assign(object, statsChunkOrigin);\n\t\t},\n\t\tids: (object, origin, { compilation: { chunkGraph } }) => {\n\t\t\tobject.moduleId = origin.module\n\t\t\t\t? /** @type {ModuleId} */ (chunkGraph.getModuleId(origin.module))\n\t\t\t\t: undefined;\n\t\t}\n\t},\n\terror: EXTRACT_ERROR,\n\twarning: EXTRACT_ERROR,\n\tmoduleTraceItem: {\n\t\t_: (object, { origin, module }, context, { requestShortener }, factory) => {\n\t\t\tconst {\n\t\t\t\ttype,\n\t\t\t\tcompilation: { moduleGraph }\n\t\t\t} = context;\n\t\t\tobject.originIdentifier = origin.identifier();\n\t\t\tobject.originName = origin.readableIdentifier(requestShortener);\n\t\t\tobject.moduleIdentifier = module.identifier();\n\t\t\tobject.moduleName = module.readableIdentifier(requestShortener);\n\t\t\tconst dependencies = Array.from(\n\t\t\t\tmoduleGraph.getIncomingConnections(module)\n\t\t\t)\n\t\t\t\t.filter(c => c.resolvedOriginModule === origin && c.dependency)\n\t\t\t\t.map(c => c.dependency);\n\t\t\tobject.dependencies = factory.create(\n\t\t\t\t`${type}.dependencies`,\n\t\t\t\tArray.from(new Set(dependencies)),\n\t\t\t\tcontext\n\t\t\t);\n\t\t},\n\t\tids: (object, { origin, module }, { compilation: { chunkGraph } }) => {\n\t\t\tobject.originId =\n\t\t\t\t/** @type {ModuleId} */\n\t\t\t\t(chunkGraph.getModuleId(origin));\n\t\t\tobject.moduleId =\n\t\t\t\t/** @type {ModuleId} */\n\t\t\t\t(chunkGraph.getModuleId(module));\n\t\t}\n\t},\n\tmoduleTraceDependency: {\n\t\t_: (object, dependency) => {\n\t\t\tobject.loc = formatLocation(dependency.loc);\n\t\t}\n\t}\n};\n\n/** @type {Record<string, Record<string, (thing: any, context: StatsFactoryContext, options: NormalizedStatsOptions) => boolean | undefined>>} */\nconst FILTER = {\n\t\"module.reasons\": {\n\t\t\"!orphanModules\": (reason, { compilation: { chunkGraph } }) => {\n\t\t\tif (\n\t\t\t\treason.originModule &&\n\t\t\t\tchunkGraph.getNumberOfModuleChunks(reason.originModule) === 0\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/** @type {Record<string, Record<string, (thing: KnownStatsError, context: StatsFactoryContext, options: NormalizedStatsOptions) => boolean | undefined>>} */\nconst FILTER_RESULTS = {\n\t\"compilation.warnings\": {\n\t\twarningsFilter: util.deprecate(\n\t\t\t(warning, context, { warningsFilter }) => {\n\t\t\t\tconst warningString = Object.keys(warning)\n\t\t\t\t\t.map(key => `${warning[/** @type {keyof KnownStatsError} */ (key)]}`)\n\t\t\t\t\t.join(\"\\n\");\n\t\t\t\treturn !warningsFilter.some(filter => filter(warning, warningString));\n\t\t\t},\n\t\t\t\"config.stats.warningsFilter is deprecated in favor of config.ignoreWarnings\",\n\t\t\t\"DEP_WEBPACK_STATS_WARNINGS_FILTER\"\n\t\t)\n\t}\n};\n\n/** @type {Record<string, (comparators: Function[], context: StatsFactoryContext) => void>} */\nconst MODULES_SORTER = {\n\t_: (comparators, { compilation: { moduleGraph } }) => {\n\t\tcomparators.push(\n\t\t\tcompareSelect(\n\t\t\t\t/**\n\t\t\t\t * @param {Module} m module\n\t\t\t\t * @returns {number | null} depth\n\t\t\t\t */\n\t\t\t\tm => moduleGraph.getDepth(m),\n\t\t\t\tcompareNumbers\n\t\t\t),\n\t\t\tcompareSelect(\n\t\t\t\t/**\n\t\t\t\t * @param {Module} m module\n\t\t\t\t * @returns {number | null} index\n\t\t\t\t */\n\t\t\t\tm => moduleGraph.getPreOrderIndex(m),\n\t\t\t\tcompareNumbers\n\t\t\t),\n\t\t\tcompareSelect(\n\t\t\t\t/**\n\t\t\t\t * @param {Module} m module\n\t\t\t\t * @returns {string} identifier\n\t\t\t\t */\n\t\t\t\tm => m.identifier(),\n\t\t\t\tcompareIds\n\t\t\t)\n\t\t);\n\t}\n};\n\n/** @type {Record<string, Record<string, (comparators: Function[], context: StatsFactoryContext) => void>>} */\nconst SORTERS = {\n\t\"compilation.chunks\": {\n\t\t_: comparators => {\n\t\t\tcomparators.push(compareSelect(c => c.id, compareIds));\n\t\t}\n\t},\n\t\"compilation.modules\": MODULES_SORTER,\n\t\"chunk.rootModules\": MODULES_SORTER,\n\t\"chunk.modules\": MODULES_SORTER,\n\t\"module.modules\": MODULES_SORTER,\n\t\"module.reasons\": {\n\t\t_: (comparators, { compilation: { chunkGraph } }) => {\n\t\t\tcomparators.push(\n\t\t\t\tcompareSelect(x => x.originModule, compareModulesByIdentifier)\n\t\t\t);\n\t\t\tcomparators.push(\n\t\t\t\tcompareSelect(x => x.resolvedOriginModule, compareModulesByIdentifier)\n\t\t\t);\n\t\t\tcomparators.push(\n\t\t\t\tcompareSelect(\n\t\t\t\t\tx => x.dependency,\n\t\t\t\t\tconcatComparators(\n\t\t\t\t\t\tcompareSelect(\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {Dependency} x dependency\n\t\t\t\t\t\t\t * @returns {DependencyLocation} location\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tx => x.loc,\n\t\t\t\t\t\t\tcompareLocations\n\t\t\t\t\t\t),\n\t\t\t\t\t\tcompareSelect(x => x.type, compareIds)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t},\n\t\"chunk.origins\": {\n\t\t_: (comparators, { compilation: { chunkGraph } }) => {\n\t\t\tcomparators.push(\n\t\t\t\tcompareSelect(\n\t\t\t\t\torigin =>\n\t\t\t\t\t\torigin.module ? chunkGraph.getModuleId(origin.module) : undefined,\n\t\t\t\t\tcompareIds\n\t\t\t\t),\n\t\t\t\tcompareSelect(origin => formatLocation(origin.loc), compareIds),\n\t\t\t\tcompareSelect(origin => origin.request, compareIds)\n\t\t\t);\n\t\t}\n\t}\n};\n\n/**\n * @template T\n * @typedef {T & { children: Children<T>[] | undefined, filteredChildren?: number }} Children\n */\n\n/**\n * @template T\n * @param {Children<T>} item item\n * @returns {number} item size\n */\nconst getItemSize = item =>\n\t// Each item takes 1 line\n\t// + the size of the children\n\t// + 1 extra line when it has children and filteredChildren\n\t!item.children\n\t\t? 1\n\t\t: item.filteredChildren\n\t\t\t? 2 + getTotalSize(item.children)\n\t\t\t: 1 + getTotalSize(item.children);\n\n/**\n * @template T\n * @param {Children<T>[]} children children\n * @returns {number} total size\n */\nconst getTotalSize = children => {\n\tlet size = 0;\n\tfor (const child of children) {\n\t\tsize += getItemSize(child);\n\t}\n\treturn size;\n};\n\n/**\n * @template T\n * @param {Children<T>[]} children children\n * @returns {number} total items\n */\nconst getTotalItems = children => {\n\tlet count = 0;\n\tfor (const child of children) {\n\t\tif (!child.children && !child.filteredChildren) {\n\t\t\tcount++;\n\t\t} else {\n\t\t\tif (child.children) count += getTotalItems(child.children);\n\t\t\tif (child.filteredChildren) count += child.filteredChildren;\n\t\t}\n\t}\n\treturn count;\n};\n\n/**\n * @template T\n * @param {Children<T>[]} children children\n * @returns {Children<T>[]} collapsed children\n */\nconst collapse = children => {\n\t// After collapse each child must take exactly one line\n\tconst newChildren = [];\n\tfor (const child of children) {\n\t\tif (child.children) {\n\t\t\tlet filteredChildren = child.filteredChildren || 0;\n\t\t\tfilteredChildren += getTotalItems(child.children);\n\t\t\tnewChildren.push({\n\t\t\t\t...child,\n\t\t\t\tchildren: undefined,\n\t\t\t\tfilteredChildren\n\t\t\t});\n\t\t} else {\n\t\t\tnewChildren.push(child);\n\t\t}\n\t}\n\treturn newChildren;\n};\n\n/**\n * @template T\n * @param {Children<T>[]} itemsAndGroups item and groups\n * @param {number} max max\n * @param {boolean=} filteredChildrenLineReserved filtered children line reserved\n * @returns {Children<T>} result\n */\nconst spaceLimited = (\n\titemsAndGroups,\n\tmax,\n\tfilteredChildrenLineReserved = false\n) => {\n\tif (max < 1) {\n\t\treturn /** @type {Children<T>} */ ({\n\t\t\tchildren: undefined,\n\t\t\tfilteredChildren: getTotalItems(itemsAndGroups)\n\t\t});\n\t}\n\t/** @type {Children<T>[] | undefined} */\n\tlet children;\n\t/** @type {number | undefined} */\n\tlet filteredChildren;\n\t// This are the groups, which take 1+ lines each\n\t/** @type {Children<T>[] | undefined} */\n\tconst groups = [];\n\t// The sizes of the groups are stored in groupSizes\n\t/** @type {number[]} */\n\tconst groupSizes = [];\n\t// This are the items, which take 1 line each\n\tconst items = [];\n\t// The total of group sizes\n\tlet groupsSize = 0;\n\n\tfor (const itemOrGroup of itemsAndGroups) {\n\t\t// is item\n\t\tif (!itemOrGroup.children && !itemOrGroup.filteredChildren) {\n\t\t\titems.push(itemOrGroup);\n\t\t} else {\n\t\t\tgroups.push(itemOrGroup);\n\t\t\tconst size = getItemSize(itemOrGroup);\n\t\t\tgroupSizes.push(size);\n\t\t\tgroupsSize += size;\n\t\t}\n\t}\n\n\tif (groupsSize + items.length <= max) {\n\t\t// The total size in the current state fits into the max\n\t\t// keep all\n\t\tchildren = groups.length > 0 ? groups.concat(items) : items;\n\t} else if (groups.length === 0) {\n\t\t// slice items to max\n\t\t// inner space marks that lines for filteredChildren already reserved\n\t\tconst limit = max - (filteredChildrenLineReserved ? 0 : 1);\n\t\tfilteredChildren = items.length - limit;\n\t\titems.length = limit;\n\t\tchildren = items;\n\t} else {\n\t\t// limit is the size when all groups are collapsed\n\t\tconst limit =\n\t\t\tgroups.length +\n\t\t\t(filteredChildrenLineReserved || items.length === 0 ? 0 : 1);\n\t\tif (limit < max) {\n\t\t\t// calculate how much we are over the size limit\n\t\t\t// this allows to approach the limit faster\n\t\t\tlet oversize;\n\t\t\t// If each group would take 1 line the total would be below the maximum\n\t\t\t// collapse some groups, keep items\n\t\t\twhile (\n\t\t\t\t(oversize =\n\t\t\t\t\tgroupsSize +\n\t\t\t\t\titems.length +\n\t\t\t\t\t(filteredChildren && !filteredChildrenLineReserved ? 1 : 0) -\n\t\t\t\t\tmax) > 0\n\t\t\t) {\n\t\t\t\t// Find the maximum group and process only this one\n\t\t\t\tconst maxGroupSize = Math.max(...groupSizes);\n\t\t\t\tif (maxGroupSize < items.length) {\n\t\t\t\t\tfilteredChildren = items.length;\n\t\t\t\t\titems.length = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < groups.length; i++) {\n\t\t\t\t\tif (groupSizes[i] === maxGroupSize) {\n\t\t\t\t\t\tconst group = groups[i];\n\t\t\t\t\t\t// run this algorithm recursively and limit the size of the children to\n\t\t\t\t\t\t// current size - oversize / number of groups\n\t\t\t\t\t\t// So it should always end up being smaller\n\t\t\t\t\t\tconst headerSize = group.filteredChildren ? 2 : 1;\n\t\t\t\t\t\tconst limited = spaceLimited(\n\t\t\t\t\t\t\t/** @type {Children<T>} */ (group.children),\n\t\t\t\t\t\t\tmaxGroupSize -\n\t\t\t\t\t\t\t\t// we should use ceil to always feet in max\n\t\t\t\t\t\t\t\tMath.ceil(oversize / groups.length) -\n\t\t\t\t\t\t\t\t// we substitute size of group head\n\t\t\t\t\t\t\t\theaderSize,\n\t\t\t\t\t\t\theaderSize === 2\n\t\t\t\t\t\t);\n\t\t\t\t\t\tgroups[i] = {\n\t\t\t\t\t\t\t...group,\n\t\t\t\t\t\t\tchildren: limited.children,\n\t\t\t\t\t\t\tfilteredChildren: limited.filteredChildren\n\t\t\t\t\t\t\t\t? (group.filteredChildren || 0) + limited.filteredChildren\n\t\t\t\t\t\t\t\t: group.filteredChildren\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst newSize = getItemSize(groups[i]);\n\t\t\t\t\t\tgroupsSize -= maxGroupSize - newSize;\n\t\t\t\t\t\tgroupSizes[i] = newSize;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tchildren = groups.concat(items);\n\t\t} else if (limit === max) {\n\t\t\t// If we have only enough space to show one line per group and one line for the filtered items\n\t\t\t// collapse all groups and items\n\t\t\tchildren = collapse(groups);\n\t\t\tfilteredChildren = items.length;\n\t\t} else {\n\t\t\t// If we have no space\n\t\t\t// collapse complete group\n\t\t\tfilteredChildren = getTotalItems(itemsAndGroups);\n\t\t}\n\t}\n\n\treturn /** @type {Children<T>} */ ({ children, filteredChildren });\n};\n\n/**\n * @param {StatsError[]} errors errors\n * @param {number} max max\n * @returns {[StatsError[], number]} error space limit\n */\nconst errorsSpaceLimit = (errors, max) => {\n\tlet filtered = 0;\n\t// Can not fit into limit\n\t// print only messages\n\tif (errors.length + 1 >= max)\n\t\treturn [\n\t\t\terrors.map(error => {\n\t\t\t\tif (typeof error === \"string\" || !error.details) return error;\n\t\t\t\tfiltered++;\n\t\t\t\treturn { ...error, details: \"\" };\n\t\t\t}),\n\t\t\tfiltered\n\t\t];\n\tlet fullLength = errors.length;\n\tlet result = errors;\n\n\tlet i = 0;\n\tfor (; i < errors.length; i++) {\n\t\tconst error = errors[i];\n\t\tif (typeof error !== \"string\" && error.details) {\n\t\t\tconst splitted = error.details.split(\"\\n\");\n\t\t\tconst len = splitted.length;\n\t\t\tfullLength += len;\n\t\t\tif (fullLength > max) {\n\t\t\t\tresult = i > 0 ? errors.slice(0, i) : [];\n\t\t\t\tconst overLimit = fullLength - max + 1;\n\t\t\t\tconst error = errors[i++];\n\t\t\t\tresult.push({\n\t\t\t\t\t...error,\n\t\t\t\t\tdetails: error.details.split(\"\\n\").slice(0, -overLimit).join(\"\\n\"),\n\t\t\t\t\tfilteredDetails: overLimit\n\t\t\t\t});\n\t\t\t\tfiltered = errors.length - i;\n\t\t\t\tfor (; i < errors.length; i++) {\n\t\t\t\t\tconst error = errors[i];\n\t\t\t\t\tif (typeof error === \"string\" || !error.details) result.push(error);\n\t\t\t\t\tresult.push({ ...error, details: \"\" });\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else if (fullLength === max) {\n\t\t\t\tresult = errors.slice(0, ++i);\n\t\t\t\tfiltered = errors.length - i;\n\t\t\t\tfor (; i < errors.length; i++) {\n\t\t\t\t\tconst error = errors[i];\n\t\t\t\t\tif (typeof error === \"string\" || !error.details) result.push(error);\n\t\t\t\t\tresult.push({ ...error, details: \"\" });\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [result, filtered];\n};\n\n/**\n * @template {{ size: number }} T\n * @template {{ size: number }} R\n * @param {(R | T)[]} children children\n * @param {T[]} assets assets\n * @returns {{ size: number }} asset size\n */\nconst assetGroup = (children, assets) => {\n\tlet size = 0;\n\tfor (const asset of children) {\n\t\tsize += asset.size;\n\t}\n\treturn { size };\n};\n\n/**\n * @template {{ size: number, sizes: Record<string, number> }} T\n * @param {Children<T>[]} children children\n * @param {KnownStatsModule[]} modules modules\n * @returns {{ size: number, sizes: Record<string, number>}} size and sizes\n */\nconst moduleGroup = (children, modules) => {\n\tlet size = 0;\n\t/** @type {Record<string, number>} */\n\tconst sizes = {};\n\tfor (const module of children) {\n\t\tsize += module.size;\n\t\tfor (const key of Object.keys(module.sizes)) {\n\t\t\tsizes[key] = (sizes[key] || 0) + module.sizes[key];\n\t\t}\n\t}\n\treturn {\n\t\tsize,\n\t\tsizes\n\t};\n};\n\n/**\n * @template {{ active: boolean }} T\n * @param {Children<T>[]} children children\n * @param {KnownStatsModuleReason[]} reasons reasons\n * @returns {{ active: boolean }} reason group\n */\nconst reasonGroup = (children, reasons) => {\n\tlet active = false;\n\tfor (const reason of children) {\n\t\tactive = active || reason.active;\n\t}\n\treturn {\n\t\tactive\n\t};\n};\n\nconst GROUP_EXTENSION_REGEXP = /(\\.[^.]+?)(?:\\?|(?: \\+ \\d+ modules?)?$)/;\nconst GROUP_PATH_REGEXP = /(.+)[/\\\\][^/\\\\]+?(?:\\?|(?: \\+ \\d+ modules?)?$)/;\n\n/** @typedef {Record<string, (groupConfigs: GroupConfig<KnownStatsAsset, TODO>[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>} AssetsGroupers */\n\n/** @type {AssetsGroupers} */\nconst ASSETS_GROUPERS = {\n\t_: (groupConfigs, context, options) => {\n\t\t/**\n\t\t * @param {keyof KnownStatsAsset} name name\n\t\t * @param {boolean=} exclude need exclude?\n\t\t */\n\t\tconst groupByFlag = (name, exclude) => {\n\t\t\tgroupConfigs.push({\n\t\t\t\tgetKeys: asset => (asset[name] ? [\"1\"] : undefined),\n\t\t\t\tgetOptions: () => ({\n\t\t\t\t\tgroupChildren: !exclude,\n\t\t\t\t\tforce: exclude\n\t\t\t\t}),\n\t\t\t\tcreateGroup: (key, children, assets) =>\n\t\t\t\t\texclude\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\ttype: \"assets by status\",\n\t\t\t\t\t\t\t\t[name]: Boolean(key),\n\t\t\t\t\t\t\t\tfilteredChildren: assets.length,\n\t\t\t\t\t\t\t\t...assetGroup(children, assets)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\ttype: \"assets by status\",\n\t\t\t\t\t\t\t\t[name]: Boolean(key),\n\t\t\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t\t\t...assetGroup(children, assets)\n\t\t\t\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\tconst {\n\t\t\tgroupAssetsByEmitStatus,\n\t\t\tgroupAssetsByPath,\n\t\t\tgroupAssetsByExtension\n\t\t} = options;\n\t\tif (groupAssetsByEmitStatus) {\n\t\t\tgroupByFlag(\"emitted\");\n\t\t\tgroupByFlag(\"comparedForEmit\");\n\t\t\tgroupByFlag(\"isOverSizeLimit\");\n\t\t}\n\t\tif (groupAssetsByEmitStatus || !options.cachedAssets) {\n\t\t\tgroupByFlag(\"cached\", !options.cachedAssets);\n\t\t}\n\t\tif (groupAssetsByPath || groupAssetsByExtension) {\n\t\t\tgroupConfigs.push({\n\t\t\t\tgetKeys: asset => {\n\t\t\t\t\tconst extensionMatch =\n\t\t\t\t\t\tgroupAssetsByExtension && GROUP_EXTENSION_REGEXP.exec(asset.name);\n\t\t\t\t\tconst extension = extensionMatch ? extensionMatch[1] : \"\";\n\t\t\t\t\tconst pathMatch =\n\t\t\t\t\t\tgroupAssetsByPath && GROUP_PATH_REGEXP.exec(asset.name);\n\t\t\t\t\tconst path = pathMatch ? pathMatch[1].split(/[/\\\\]/) : [];\n\t\t\t\t\tconst keys = [];\n\t\t\t\t\tif (groupAssetsByPath) {\n\t\t\t\t\t\tkeys.push(\".\");\n\t\t\t\t\t\tif (extension)\n\t\t\t\t\t\t\tkeys.push(\n\t\t\t\t\t\t\t\tpath.length\n\t\t\t\t\t\t\t\t\t? `${path.join(\"/\")}/*${extension}`\n\t\t\t\t\t\t\t\t\t: `*${extension}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\twhile (path.length > 0) {\n\t\t\t\t\t\t\tkeys.push(`${path.join(\"/\")}/`);\n\t\t\t\t\t\t\tpath.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (extension) {\n\t\t\t\t\t\tkeys.push(`*${extension}`);\n\t\t\t\t\t}\n\t\t\t\t\treturn keys;\n\t\t\t\t},\n\t\t\t\tcreateGroup: (key, children, assets) => ({\n\t\t\t\t\ttype: groupAssetsByPath ? \"assets by path\" : \"assets by extension\",\n\t\t\t\t\tname: key,\n\t\t\t\t\tchildren,\n\t\t\t\t\t...assetGroup(children, assets)\n\t\t\t\t})\n\t\t\t});\n\t\t}\n\t},\n\tgroupAssetsByInfo: (groupConfigs, context, options) => {\n\t\t/**\n\t\t * @param {string} name name\n\t\t */\n\t\tconst groupByAssetInfoFlag = name => {\n\t\t\tgroupConfigs.push({\n\t\t\t\tgetKeys: asset => (asset.info && asset.info[name] ? [\"1\"] : undefined),\n\t\t\t\tcreateGroup: (key, children, assets) => ({\n\t\t\t\t\ttype: \"assets by info\",\n\t\t\t\t\tinfo: {\n\t\t\t\t\t\t[name]: Boolean(key)\n\t\t\t\t\t},\n\t\t\t\t\tchildren,\n\t\t\t\t\t...assetGroup(children, assets)\n\t\t\t\t})\n\t\t\t});\n\t\t};\n\t\tgroupByAssetInfoFlag(\"immutable\");\n\t\tgroupByAssetInfoFlag(\"development\");\n\t\tgroupByAssetInfoFlag(\"hotModuleReplacement\");\n\t},\n\tgroupAssetsByChunk: (groupConfigs, context, options) => {\n\t\t/**\n\t\t * @param {keyof KnownStatsAsset} name name\n\t\t */\n\t\tconst groupByNames = name => {\n\t\t\tgroupConfigs.push({\n\t\t\t\tgetKeys: asset => /** @type {string[]} */ (asset[name]),\n\t\t\t\tcreateGroup: (key, children, assets) => ({\n\t\t\t\t\ttype: \"assets by chunk\",\n\t\t\t\t\t[name]: [key],\n\t\t\t\t\tchildren,\n\t\t\t\t\t...assetGroup(children, assets)\n\t\t\t\t})\n\t\t\t});\n\t\t};\n\t\tgroupByNames(\"chunkNames\");\n\t\tgroupByNames(\"auxiliaryChunkNames\");\n\t\tgroupByNames(\"chunkIdHints\");\n\t\tgroupByNames(\"auxiliaryChunkIdHints\");\n\t},\n\texcludeAssets: (groupConfigs, context, { excludeAssets }) => {\n\t\tgroupConfigs.push({\n\t\t\tgetKeys: asset => {\n\t\t\t\tconst ident = asset.name;\n\t\t\t\tconst excluded = excludeAssets.some(fn => fn(ident, asset));\n\t\t\t\tif (excluded) return [\"excluded\"];\n\t\t\t},\n\t\t\tgetOptions: () => ({\n\t\t\t\tgroupChildren: false,\n\t\t\t\tforce: true\n\t\t\t}),\n\t\t\tcreateGroup: (key, children, assets) => ({\n\t\t\t\ttype: \"hidden assets\",\n\t\t\t\tfilteredChildren: assets.length,\n\t\t\t\t...assetGroup(children, assets)\n\t\t\t})\n\t\t});\n\t}\n};\n\n/** @typedef {Record<string, (groupConfigs: GroupConfig<KnownStatsModule, TODO>[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>} ModulesGroupers */\n\n/** @type {function(\"module\" | \"chunk\" | \"root-of-chunk\" | \"nested\"): ModulesGroupers} */\nconst MODULES_GROUPERS = type => ({\n\t_: (groupConfigs, context, options) => {\n\t\t/**\n\t\t * @param {keyof KnownStatsModule} name name\n\t\t * @param {string} type type\n\t\t * @param {boolean=} exclude need exclude?\n\t\t */\n\t\tconst groupByFlag = (name, type, exclude) => {\n\t\t\tgroupConfigs.push({\n\t\t\t\tgetKeys: module => (module[name] ? [\"1\"] : undefined),\n\t\t\t\tgetOptions: () => ({\n\t\t\t\t\tgroupChildren: !exclude,\n\t\t\t\t\tforce: exclude\n\t\t\t\t}),\n\t\t\t\tcreateGroup: (key, children, modules) => ({\n\t\t\t\t\ttype,\n\t\t\t\t\t[name]: Boolean(key),\n\t\t\t\t\t...(exclude ? { filteredChildren: modules.length } : { children }),\n\t\t\t\t\t...moduleGroup(children, modules)\n\t\t\t\t})\n\t\t\t});\n\t\t};\n\t\tconst {\n\t\t\tgroupModulesByCacheStatus,\n\t\t\tgroupModulesByLayer,\n\t\t\tgroupModulesByAttributes,\n\t\t\tgroupModulesByType,\n\t\t\tgroupModulesByPath,\n\t\t\tgroupModulesByExtension\n\t\t} = options;\n\t\tif (groupModulesByAttributes) {\n\t\t\tgroupByFlag(\"errors\", \"modules with errors\");\n\t\t\tgroupByFlag(\"warnings\", \"modules with warnings\");\n\t\t\tgroupByFlag(\"assets\", \"modules with assets\");\n\t\t\tgroupByFlag(\"optional\", \"optional modules\");\n\t\t}\n\t\tif (groupModulesByCacheStatus) {\n\t\t\tgroupByFlag(\"cacheable\", \"cacheable modules\");\n\t\t\tgroupByFlag(\"built\", \"built modules\");\n\t\t\tgroupByFlag(\"codeGenerated\", \"code generated modules\");\n\t\t}\n\t\tif (groupModulesByCacheStatus || !options.cachedModules) {\n\t\t\tgroupByFlag(\"cached\", \"cached modules\", !options.cachedModules);\n\t\t}\n\t\tif (groupModulesByAttributes || !options.orphanModules) {\n\t\t\tgroupByFlag(\"orphan\", \"orphan modules\", !options.orphanModules);\n\t\t}\n\t\tif (groupModulesByAttributes || !options.dependentModules) {\n\t\t\tgroupByFlag(\"dependent\", \"dependent modules\", !options.dependentModules);\n\t\t}\n\t\tif (groupModulesByType || !options.runtimeModules) {\n\t\t\tgroupConfigs.push({\n\t\t\t\tgetKeys: module => {\n\t\t\t\t\tif (!module.moduleType) return;\n\t\t\t\t\tif (groupModulesByType) {\n\t\t\t\t\t\treturn [module.moduleType.split(\"/\", 1)[0]];\n\t\t\t\t\t} else if (module.moduleType === WEBPACK_MODULE_TYPE_RUNTIME) {\n\t\t\t\t\t\treturn [WEBPACK_MODULE_TYPE_RUNTIME];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tgetOptions: key => {\n\t\t\t\t\tconst exclude =\n\t\t\t\t\t\tkey === WEBPACK_MODULE_TYPE_RUNTIME && !options.runtimeModules;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tgroupChildren: !exclude,\n\t\t\t\t\t\tforce: exclude\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tcreateGroup: (key, children, modules) => {\n\t\t\t\t\tconst exclude =\n\t\t\t\t\t\tkey === WEBPACK_MODULE_TYPE_RUNTIME && !options.runtimeModules;\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: `${key} modules`,\n\t\t\t\t\t\tmoduleType: key,\n\t\t\t\t\t\t...(exclude ? { filteredChildren: modules.length } : { children }),\n\t\t\t\t\t\t...moduleGroup(children, modules)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (groupModulesByLayer) {\n\t\t\tgroupConfigs.push({\n\t\t\t\tgetKeys: module => /** @type {string[]} */ ([module.layer]),\n\t\t\t\tcreateGroup: (key, children, modules) => ({\n\t\t\t\t\ttype: \"modules by layer\",\n\t\t\t\t\tlayer: key,\n\t\t\t\t\tchildren,\n\t\t\t\t\t...moduleGroup(children, modules)\n\t\t\t\t})\n\t\t\t});\n\t\t}\n\t\tif (groupModulesByPath || groupModulesByExtension) {\n\t\t\tgroupConfigs.push({\n\t\t\t\tgetKeys: module => {\n\t\t\t\t\tif (!module.name) return;\n\t\t\t\t\tconst resource = parseResource(\n\t\t\t\t\t\t/** @type {string} */ (module.name.split(\"!\").pop())\n\t\t\t\t\t).path;\n\t\t\t\t\tconst dataUrl = /^data:[^,;]+/.exec(resource);\n\t\t\t\t\tif (dataUrl) return [dataUrl[0]];\n\t\t\t\t\tconst extensionMatch =\n\t\t\t\t\t\tgroupModulesByExtension && GROUP_EXTENSION_REGEXP.exec(resource);\n\t\t\t\t\tconst extension = extensionMatch ? extensionMatch[1] : \"\";\n\t\t\t\t\tconst pathMatch =\n\t\t\t\t\t\tgroupModulesByPath && GROUP_PATH_REGEXP.exec(resource);\n\t\t\t\t\tconst path = pathMatch ? pathMatch[1].split(/[/\\\\]/) : [];\n\t\t\t\t\tconst keys = [];\n\t\t\t\t\tif (groupModulesByPath) {\n\t\t\t\t\t\tif (extension)\n\t\t\t\t\t\t\tkeys.push(\n\t\t\t\t\t\t\t\tpath.length\n\t\t\t\t\t\t\t\t\t? `${path.join(\"/\")}/*${extension}`\n\t\t\t\t\t\t\t\t\t: `*${extension}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\twhile (path.length > 0) {\n\t\t\t\t\t\t\tkeys.push(`${path.join(\"/\")}/`);\n\t\t\t\t\t\t\tpath.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (extension) {\n\t\t\t\t\t\tkeys.push(`*${extension}`);\n\t\t\t\t\t}\n\t\t\t\t\treturn keys;\n\t\t\t\t},\n\t\t\t\tcreateGroup: (key, children, modules) => {\n\t\t\t\t\tconst isDataUrl = key.startsWith(\"data:\");\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: isDataUrl\n\t\t\t\t\t\t\t? \"modules by mime type\"\n\t\t\t\t\t\t\t: groupModulesByPath\n\t\t\t\t\t\t\t\t? \"modules by path\"\n\t\t\t\t\t\t\t\t: \"modules by extension\",\n\t\t\t\t\t\tname: isDataUrl ? key.slice(/* 'data:'.length */ 5) : key,\n\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t...moduleGroup(children, modules)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\texcludeModules: (groupConfigs, context, { excludeModules }) => {\n\t\tgroupConfigs.push({\n\t\t\tgetKeys: module => {\n\t\t\t\tconst name = module.name;\n\t\t\t\tif (name) {\n\t\t\t\t\tconst excluded = excludeModules.some(fn => fn(name, module, type));\n\t\t\t\t\tif (excluded) return [\"1\"];\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetOptions: () => ({\n\t\t\t\tgroupChildren: false,\n\t\t\t\tforce: true\n\t\t\t}),\n\t\t\tcreateGroup: (key, children, modules) => ({\n\t\t\t\ttype: \"hidden modules\",\n\t\t\t\tfilteredChildren: children.length,\n\t\t\t\t...moduleGroup(children, modules)\n\t\t\t})\n\t\t});\n\t}\n});\n\n/** @typedef {Record<string, (groupConfigs: import(\"../util/smartGrouping\").GroupConfig<KnownStatsModuleReason, TODO>[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>} ModuleReasonsGroupers */\n\n/** @type {ModuleReasonsGroupers} */\nconst MODULE_REASONS_GROUPERS = {\n\tgroupReasonsByOrigin: groupConfigs => {\n\t\tgroupConfigs.push({\n\t\t\tgetKeys: reason => /** @type {string[]} */ ([reason.module]),\n\t\t\tcreateGroup: (key, children, reasons) => ({\n\t\t\t\ttype: \"from origin\",\n\t\t\t\tmodule: key,\n\t\t\t\tchildren,\n\t\t\t\t...reasonGroup(children, reasons)\n\t\t\t})\n\t\t});\n\t}\n};\n\n/** @type {Record<string, AssetsGroupers | ModulesGroupers | ModuleReasonsGroupers>} */\nconst RESULT_GROUPERS = {\n\t\"compilation.assets\": ASSETS_GROUPERS,\n\t\"asset.related\": ASSETS_GROUPERS,\n\t\"compilation.modules\": MODULES_GROUPERS(\"module\"),\n\t\"chunk.modules\": MODULES_GROUPERS(\"chunk\"),\n\t\"chunk.rootModules\": MODULES_GROUPERS(\"root-of-chunk\"),\n\t\"module.modules\": MODULES_GROUPERS(\"nested\"),\n\t\"module.reasons\": MODULE_REASONS_GROUPERS\n};\n\n// remove a prefixed \"!\" that can be specified to reverse sort order\n/**\n * @param {string} field a field name\n * @returns {field} normalized field\n */\nconst normalizeFieldKey = field => {\n\tif (field[0] === \"!\") {\n\t\treturn field.slice(1);\n\t}\n\treturn field;\n};\n\n// if a field is prefixed by a \"!\" reverse sort order\n/**\n * @param {string} field a field name\n * @returns {boolean} result\n */\nconst sortOrderRegular = field => {\n\tif (field[0] === \"!\") {\n\t\treturn false;\n\t}\n\treturn true;\n};\n\n/**\n * @template T\n * @param {string} field field name\n * @returns {function(T, T): 0 | 1 | -1} comparators\n */\nconst sortByField = field => {\n\tif (!field) {\n\t\t/**\n\t\t * @param {any} a first\n\t\t * @param {any} b second\n\t\t * @returns {-1|0|1} zero\n\t\t */\n\t\tconst noSort = (a, b) => 0;\n\t\treturn noSort;\n\t}\n\n\tconst fieldKey = normalizeFieldKey(field);\n\n\tlet sortFn = compareSelect(m => m[fieldKey], compareIds);\n\n\t// if a field is prefixed with a \"!\" the sort is reversed!\n\tconst sortIsRegular = sortOrderRegular(field);\n\n\tif (!sortIsRegular) {\n\t\tconst oldSortFn = sortFn;\n\t\tsortFn = (a, b) => oldSortFn(b, a);\n\t}\n\n\treturn sortFn;\n};\n\n/** @type {Record<string, (comparators: Comparator<TODO>[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>} */\nconst ASSET_SORTERS = {\n\tassetsSort: (comparators, context, { assetsSort }) => {\n\t\tcomparators.push(sortByField(assetsSort));\n\t},\n\t_: comparators => {\n\t\tcomparators.push(compareSelect(a => a.name, compareIds));\n\t}\n};\n\n/** @type {Record<string, Record<string, (comparators: Comparator<TODO>[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>>} */\nconst RESULT_SORTERS = {\n\t\"compilation.chunks\": {\n\t\tchunksSort: (comparators, context, { chunksSort }) => {\n\t\t\tcomparators.push(sortByField(chunksSort));\n\t\t}\n\t},\n\t\"compilation.modules\": {\n\t\tmodulesSort: (comparators, context, { modulesSort }) => {\n\t\t\tcomparators.push(sortByField(modulesSort));\n\t\t}\n\t},\n\t\"chunk.modules\": {\n\t\tchunkModulesSort: (comparators, context, { chunkModulesSort }) => {\n\t\t\tcomparators.push(sortByField(chunkModulesSort));\n\t\t}\n\t},\n\t\"module.modules\": {\n\t\tnestedModulesSort: (comparators, context, { nestedModulesSort }) => {\n\t\t\tcomparators.push(sortByField(nestedModulesSort));\n\t\t}\n\t},\n\t\"compilation.assets\": ASSET_SORTERS,\n\t\"asset.related\": ASSET_SORTERS\n};\n\n/**\n * @param {Record<string, Record<string, Function>>} config the config see above\n * @param {NormalizedStatsOptions} options stats options\n * @param {function(string, Function): void} fn handler function called for every active line in config\n * @returns {void}\n */\nconst iterateConfig = (config, options, fn) => {\n\tfor (const hookFor of Object.keys(config)) {\n\t\tconst subConfig = config[hookFor];\n\t\tfor (const option of Object.keys(subConfig)) {\n\t\t\tif (option !== \"_\") {\n\t\t\t\tif (option.startsWith(\"!\")) {\n\t\t\t\t\tif (options[option.slice(1)]) continue;\n\t\t\t\t} else {\n\t\t\t\t\tconst value = options[option];\n\t\t\t\t\tif (\n\t\t\t\t\t\tvalue === false ||\n\t\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t\t(Array.isArray(value) && value.length === 0)\n\t\t\t\t\t)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfn(hookFor, subConfig[option]);\n\t\t}\n\t}\n};\n\n/** @type {Record<string, string>} */\nconst ITEM_NAMES = {\n\t\"compilation.children[]\": \"compilation\",\n\t\"compilation.modules[]\": \"module\",\n\t\"compilation.entrypoints[]\": \"chunkGroup\",\n\t\"compilation.namedChunkGroups[]\": \"chunkGroup\",\n\t\"compilation.errors[]\": \"error\",\n\t\"compilation.warnings[]\": \"warning\",\n\t\"chunk.modules[]\": \"module\",\n\t\"chunk.rootModules[]\": \"module\",\n\t\"chunk.origins[]\": \"chunkOrigin\",\n\t\"compilation.chunks[]\": \"chunk\",\n\t\"compilation.assets[]\": \"asset\",\n\t\"asset.related[]\": \"asset\",\n\t\"module.issuerPath[]\": \"moduleIssuer\",\n\t\"module.reasons[]\": \"moduleReason\",\n\t\"module.modules[]\": \"module\",\n\t\"module.children[]\": \"module\",\n\t\"moduleTrace[]\": \"moduleTraceItem\",\n\t\"moduleTraceItem.dependencies[]\": \"moduleTraceDependency\"\n};\n\n/**\n * @template T\n * @typedef {{ name: T }} NamedObject\n */\n\n/**\n * @template {{ name: string }} T\n * @param {T[]} items items to be merged\n * @returns {NamedObject<T>} an object\n */\nconst mergeToObject = items => {\n\tconst obj = Object.create(null);\n\tfor (const item of items) {\n\t\tobj[item.name] = item;\n\t}\n\treturn obj;\n};\n\n/**\n * @template {{ name: string }} T\n * @type {Record<string, (items: T[]) => NamedObject<T>>}\n */\nconst MERGER = {\n\t\"compilation.entrypoints\": mergeToObject,\n\t\"compilation.namedChunkGroups\": mergeToObject\n};\n\nclass DefaultStatsFactoryPlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"DefaultStatsFactoryPlugin\", compilation => {\n\t\t\tcompilation.hooks.statsFactory.tap(\n\t\t\t\t\"DefaultStatsFactoryPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {StatsFactory} stats stats factory\n\t\t\t\t * @param {NormalizedStatsOptions} options stats options\n\t\t\t\t */\n\t\t\t\t(stats, options) => {\n\t\t\t\t\titerateConfig(SIMPLE_EXTRACTORS, options, (hookFor, fn) => {\n\t\t\t\t\t\tstats.hooks.extract\n\t\t\t\t\t\t\t.for(hookFor)\n\t\t\t\t\t\t\t.tap(\"DefaultStatsFactoryPlugin\", (obj, data, ctx) =>\n\t\t\t\t\t\t\t\tfn(obj, data, ctx, options, stats)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\titerateConfig(FILTER, options, (hookFor, fn) => {\n\t\t\t\t\t\tstats.hooks.filter\n\t\t\t\t\t\t\t.for(hookFor)\n\t\t\t\t\t\t\t.tap(\"DefaultStatsFactoryPlugin\", (item, ctx, idx, i) =>\n\t\t\t\t\t\t\t\tfn(item, ctx, options, idx, i)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\titerateConfig(FILTER_RESULTS, options, (hookFor, fn) => {\n\t\t\t\t\t\tstats.hooks.filterResults\n\t\t\t\t\t\t\t.for(hookFor)\n\t\t\t\t\t\t\t.tap(\"DefaultStatsFactoryPlugin\", (item, ctx, idx, i) =>\n\t\t\t\t\t\t\t\tfn(item, ctx, options, idx, i)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\titerateConfig(SORTERS, options, (hookFor, fn) => {\n\t\t\t\t\t\tstats.hooks.sort\n\t\t\t\t\t\t\t.for(hookFor)\n\t\t\t\t\t\t\t.tap(\"DefaultStatsFactoryPlugin\", (comparators, ctx) =>\n\t\t\t\t\t\t\t\tfn(comparators, ctx, options)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\titerateConfig(RESULT_SORTERS, options, (hookFor, fn) => {\n\t\t\t\t\t\tstats.hooks.sortResults\n\t\t\t\t\t\t\t.for(hookFor)\n\t\t\t\t\t\t\t.tap(\"DefaultStatsFactoryPlugin\", (comparators, ctx) =>\n\t\t\t\t\t\t\t\tfn(comparators, ctx, options)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\titerateConfig(RESULT_GROUPERS, options, (hookFor, fn) => {\n\t\t\t\t\t\tstats.hooks.groupResults\n\t\t\t\t\t\t\t.for(hookFor)\n\t\t\t\t\t\t\t.tap(\"DefaultStatsFactoryPlugin\", (groupConfigs, ctx) =>\n\t\t\t\t\t\t\t\tfn(groupConfigs, ctx, options)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\tfor (const key of Object.keys(ITEM_NAMES)) {\n\t\t\t\t\t\tconst itemName = ITEM_NAMES[key];\n\t\t\t\t\t\tstats.hooks.getItemName\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\"DefaultStatsFactoryPlugin\", () => itemName);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const key of Object.keys(MERGER)) {\n\t\t\t\t\t\tconst merger = MERGER[key];\n\t\t\t\t\t\tstats.hooks.merge.for(key).tap(\"DefaultStatsFactoryPlugin\", merger);\n\t\t\t\t\t}\n\t\t\t\t\tif (options.children) {\n\t\t\t\t\t\tif (Array.isArray(options.children)) {\n\t\t\t\t\t\t\tstats.hooks.getItemFactory\n\t\t\t\t\t\t\t\t.for(\"compilation.children[].compilation\")\n\t\t\t\t\t\t\t\t.tap(\n\t\t\t\t\t\t\t\t\t\"DefaultStatsFactoryPlugin\",\n\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t * @param {Compilation} comp compilation\n\t\t\t\t\t\t\t\t\t * @param {StatsFactoryContext} options options\n\t\t\t\t\t\t\t\t\t * @returns {StatsFactory | undefined} stats factory\n\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\t(comp, { _index: idx }) => {\n\t\t\t\t\t\t\t\t\t\tconst children =\n\t\t\t\t\t\t\t\t\t\t\t/** @type {TODO} */\n\t\t\t\t\t\t\t\t\t\t\t(options.children);\n\t\t\t\t\t\t\t\t\t\tif (idx < children.length) {\n\t\t\t\t\t\t\t\t\t\t\treturn compilation.createStatsFactory(\n\t\t\t\t\t\t\t\t\t\t\t\tcompilation.createStatsOptions(children[idx])\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (options.children !== true) {\n\t\t\t\t\t\t\tconst childFactory = compilation.createStatsFactory(\n\t\t\t\t\t\t\t\tcompilation.createStatsOptions(options.children)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tstats.hooks.getItemFactory\n\t\t\t\t\t\t\t\t.for(\"compilation.children[].compilation\")\n\t\t\t\t\t\t\t\t.tap(\"DefaultStatsFactoryPlugin\", () => childFactory);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = DefaultStatsFactoryPlugin;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAM;EAAEC;AAA4B,CAAC,GAAGD,OAAO,CAAC,wBAAwB,CAAC;AACzE,MAAME,gBAAgB,GAAGF,OAAO,CAAC,kCAAkC,CAAC;AACpE,MAAMG,cAAc,GAAGH,OAAO,CAAC,mBAAmB,CAAC;AACnD,MAAM;EAAEI;AAAQ,CAAC,GAAGJ,OAAO,CAAC,mBAAmB,CAAC;AAChD,MAAMK,yBAAyB,GAAGL,OAAO,CAAC,uCAAuC,CAAC;AAClF,MAAMM,gBAAgB,GAAGN,OAAO,CAAC,iCAAiC,CAAC;AACnE,MAAM;EAAEO;AAAc,CAAC,GAAGP,OAAO,CAAC,yBAAyB,CAAC;AAC5D,MAAM;EACLQ,gBAAgB;EAChBC,iBAAiB;EACjBC,cAAc;EACdC,UAAU;EACVC,iBAAiB;EACjBC,aAAa;EACbC;AACD,CAAC,GAAGd,OAAO,CAAC,qBAAqB,CAAC;AAClC,MAAM;EAAEe,iBAAiB;EAAEC;AAAc,CAAC,GAAGhB,OAAO,CAAC,oBAAoB,CAAC;;AAE1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMiB,WAAW,GAAGA,CAACC,KAAK,EAAEC,QAAQ,KAAK;EACxC;EACA,MAAMC,GAAG,GAAG,IAAIC,GAAG,CAAC,CAAC;EACrB,KAAK,MAAMC,IAAI,IAAIJ,KAAK,EAAE;IACzB,KAAK,MAAMK,CAAC,IAAIJ,QAAQ,CAACG,IAAI,CAAC,EAAE;MAC/BF,GAAG,CAACI,GAAG,CAACD,CAAC,CAAC;IACX;EACD;EACA,OAAOE,KAAK,CAACC,IAAI,CAACN,GAAG,CAAC;AACvB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMO,kBAAkB,GAAGA,CAACT,KAAK,EAAEC,QAAQ,EAAES,UAAU,KACtDX,WAAW,CAACC,KAAK,EAAEC,QAAQ,CAAC,CAACU,IAAI,CAACD,UAAU,CAAC;;AAE9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,SAAS,GAAGA,CAACC,GAAG,EAAEC,EAAE,KAAK;EAC9B,MAAMC,MAAM,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EAClC,KAAK,MAAMC,GAAG,IAAIF,MAAM,CAACG,IAAI,CAACN,GAAG,CAAC,EAAE;IACnCE,MAAM,CAACG,GAAG,CAAC,GAAGJ,EAAE,CACfD,GAAG,EAAC,sBAAwBK,GAAG,EAAE,EACjC,sBAAwBA,GACzB,CAAC;EACF;EACA,OAAOH,MAAM;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMK,iBAAiB,GAAGA,CAACC,WAAW,EAAEC,QAAQ,KAAK;EACpD,IAAIC,KAAK,GAAGD,QAAQ,CAACD,WAAW,EAAE,EAAE,CAAC,CAACG,MAAM;EAC5C,KAAK,MAAMC,KAAK,IAAIJ,WAAW,CAACK,QAAQ,EAAE;IACzCH,KAAK,IAAIH,iBAAiB,CAACK,KAAK,EAAE,CAACE,CAAC,EAAEC,IAAI,KACzCN,QAAQ,CAACK,CAAC,EAAE,0BAA0BC,IAAI,EAAE,CAC7C,CAAC;EACF;EACA,OAAOL,KAAK;AACb,CAAC;;AAED;AACA,MAAMM,aAAa,GAAG;EACrBC,CAAC,EAAEA,CAACC,MAAM,EAAEC,KAAK,EAAEC,OAAO,EAAE;IAAEC;EAAiB,CAAC,KAAK;IACpD;IACA,IAAI,OAAOF,KAAK,KAAK,QAAQ,EAAE;MAC9BD,MAAM,CAACI,OAAO,GAAGH,KAAK;IACvB,CAAC,MAAM;MACN,IAAIA,KAAK,CAACI,KAAK,EAAE;QAChBL,MAAM,CAACM,SAAS,GAAGL,KAAK,CAACI,KAAK,CAACE,IAAI;QACnCP,MAAM,CAACQ,UAAU,GAAGP,KAAK,CAACI,KAAK,CAACI,UAAU,CAAC,CAAC;QAC5CT,MAAM,CAACU,YAAY,GAAGT,KAAK,CAACI,KAAK,CAACM,YAAY,CAAC,CAAC;MACjD;MACA,IAAIV,KAAK,CAACW,IAAI,EAAE;QACfZ,MAAM,CAACY,IAAI,GAAGX,KAAK,CAACW,IAAI;MACzB;MACA,IAAIX,KAAK,CAACY,MAAM,EAAE;QACjBb,MAAM,CAACc,gBAAgB,GAAGb,KAAK,CAACY,MAAM,CAACE,UAAU,CAAC,CAAC;QACnDf,MAAM,CAACgB,UAAU,GAAGf,KAAK,CAACY,MAAM,CAACI,kBAAkB,CAACd,gBAAgB,CAAC;MACtE;MACA,IAAIF,KAAK,CAACiB,GAAG,EAAE;QACdlB,MAAM,CAACkB,GAAG,GAAGhE,cAAc,CAAC+C,KAAK,CAACiB,GAAG,CAAC;MACvC;MACAlB,MAAM,CAACI,OAAO,GAAGH,KAAK,CAACG,OAAO;IAC/B;EACD,CAAC;EACDe,GAAG,EAAEA,CAACnB,MAAM,EAAEC,KAAK,EAAE;IAAEX,WAAW,EAAE;MAAE8B;IAAW;EAAE,CAAC,KAAK;IACxD,IAAI,OAAOnB,KAAK,KAAK,QAAQ,EAAE;MAC9B,IAAIA,KAAK,CAACI,KAAK,EAAE;QAChBL,MAAM,CAACqB,OAAO,GAAG,sBAAwBpB,KAAK,CAACI,KAAK,CAACiB,EAAG;MACzD;MACA,IAAIrB,KAAK,CAACY,MAAM,EAAE;QACjBb,MAAM,CAACuB,QAAQ,GACd;QACCH,UAAU,CAACI,WAAW,CAACvB,KAAK,CAACY,MAAM,CAAE;MACxC;IACD;EACD,CAAC;EACDY,WAAW,EAAEA,CAACzB,MAAM,EAAEC,KAAK,EAAEC,OAAO,EAAEwB,OAAO,EAAEC,OAAO,KAAK;IAC1D,IAAI,OAAO1B,KAAK,KAAK,QAAQ,IAAIA,KAAK,CAACY,MAAM,EAAE;MAC9C,MAAM;QACLhB,IAAI;QACJP,WAAW,EAAE;UAAEsC;QAAY;MAC5B,CAAC,GAAG1B,OAAO;MACX;MACA,MAAM2B,cAAc,GAAG,IAAIzD,GAAG,CAAC,CAAC;MAChC,MAAMqD,WAAW,GAAG,EAAE;MACtB,IAAIK,OAAO,GAAG7B,KAAK,CAACY,MAAM;MAC1B,OAAOiB,OAAO,EAAE;QACf,IAAID,cAAc,CAACE,GAAG,CAACD,OAAO,CAAC,EAAE,MAAM,CAAC;QACxCD,cAAc,CAACtD,GAAG,CAACuD,OAAO,CAAC;QAC3B,MAAME,MAAM,GAAGJ,WAAW,CAACK,SAAS,CAACH,OAAO,CAAC;QAC7C,IAAI,CAACE,MAAM,EAAE;QACbP,WAAW,CAACS,IAAI,CAAC;UAAEF,MAAM;UAAEnB,MAAM,EAAEiB;QAAQ,CAAC,CAAC;QAC7CA,OAAO,GAAGE,MAAM;MACjB;MACAhC,MAAM,CAACyB,WAAW,GAAGE,OAAO,CAACzC,MAAM,CAClC,GAAGW,IAAI,cAAc,EACrB4B,WAAW,EACXvB,OACD,CAAC;IACF;EACD,CAAC;EACDiC,YAAY,EAAEA,CACbnC,MAAM,EACNC,KAAK,EACL;IAAEJ,IAAI;IAAEP,WAAW;IAAE8C,eAAe;IAAEC;EAAkB,CAAC,EACzD;IAAEF;EAAa,CAAC,KACZ;IACJ,IACC,OAAOlC,KAAK,KAAK,QAAQ,KACxBkC,YAAY,KAAK,IAAI,IACpBtC,IAAI,CAACyC,QAAQ,CAAC,QAAQ,CAAC,IAAIF,eAAe,CAAC9C,WAAW,CAAC,CAACG,MAAM,GAAG,CAAE,CAAC,EACrE;MACDO,MAAM,CAACuC,OAAO,GAAGtC,KAAK,CAACsC,OAAO;IAC/B;EACD,CAAC;EACDC,UAAU,EAAEA,CAACxC,MAAM,EAAEC,KAAK,KAAK;IAC9B,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC9BD,MAAM,CAACyC,KAAK,GAAGxC,KAAK,CAACwC,KAAK;IAC3B;EACD;AACD,CAAC;;AAED;AACA,MAAMC,iBAAiB,GAAG;EACzBpD,WAAW,EAAE;IACZS,CAAC,EAAEA,CAACC,MAAM,EAAEV,WAAW,EAAEY,OAAO,EAAEwB,OAAO,KAAK;MAC7C,IAAI,CAACxB,OAAO,CAACpC,iBAAiB,EAAE;QAC/BoC,OAAO,CAACpC,iBAAiB,GAAGA,iBAAiB,CAAC6E,gBAAgB,CAC7DrD,WAAW,CAACsD,QAAQ,CAAC1C,OAAO,EAC5BZ,WAAW,CAACsD,QAAQ,CAACC,IACtB,CAAC;MACF;MACA,IAAI,CAAC3C,OAAO,CAACkC,eAAe,EAAE;QAC7B,MAAMU,GAAG,GAAG,IAAIC,OAAO,CAAC,CAAC;QACzB7C,OAAO,CAACkC,eAAe,GAAG9C,WAAW,IACpCwD,GAAG,CAACE,GAAG,CAAC1D,WAAW,CAAC;QACpB;QACA,CAAC2D,MAAM,KAAKH,GAAG,CAAC3E,GAAG,CAACmB,WAAW,EAAE2D,MAAM,CAAC,EAAEA,MAAM,CAAC,EAChD3D,WAAW,CAAC4D,SAAS,CAAC,CACvB,CAAC;MACH;MACA,IAAI,CAAChD,OAAO,CAACmC,iBAAiB,EAAE;QAC/B,MAAMS,GAAG,GAAG,IAAIC,OAAO,CAAC,CAAC;QACzB7C,OAAO,CAACmC,iBAAiB,GAAG/C,WAAW,IACtCwD,GAAG,CAACE,GAAG,CAAC1D,WAAW,CAAC;QACpB;QACA,CAAC6D,QAAQ,KAAKL,GAAG,CAAC3E,GAAG,CAACmB,WAAW,EAAE6D,QAAQ,CAAC,EAAEA,QAAQ,CAAC,EACtD7D,WAAW,CAAC8D,WAAW,CAAC,CACzB,CAAC;MACH;MACA,IAAI9D,WAAW,CAACiB,IAAI,EAAE;QACrBP,MAAM,CAACO,IAAI,GAAGjB,WAAW,CAACiB,IAAI;MAC/B;MACA,IAAIjB,WAAW,CAAC+D,kBAAkB,EAAE;QACnCrD,MAAM,CAACqD,kBAAkB,GAAG,IAAI;MACjC;MAEA,MAAM;QAAEC,OAAO;QAAEC,YAAY;QAAEC;MAAa,CAAC,GAAG9B,OAAO;MACvD,IAAI4B,OAAO,IAAKC,YAAY,IAAIA,YAAY,CAAC9D,MAAM,GAAG,CAAE,EAAE;QACzD,MAAM3C,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;QAC5BiD,MAAM,CAACsD,OAAO,GAAG,CAAC,CAAC;QACnB,IAAIG,aAAa;QACjB,IAAIC,eAAe,GAAG,KAAK;QAC3B,QAAQJ,OAAO;UACd,KAAK,OAAO;YACXG,aAAa,GAAG,IAAIrF,GAAG,CAAC,CAACjB,OAAO,CAAC8C,KAAK,CAAC,CAAC;YACxC;UACD,KAAK,MAAM;YACVwD,aAAa,GAAG,IAAIrF,GAAG,CAAC,CAACjB,OAAO,CAAC8C,KAAK,EAAE9C,OAAO,CAACwG,IAAI,CAAC,CAAC;YACtD;UACD,KAAK,MAAM;YACVF,aAAa,GAAG,IAAIrF,GAAG,CAAC,CACvBjB,OAAO,CAAC8C,KAAK,EACb9C,OAAO,CAACwG,IAAI,EACZxG,OAAO,CAACyG,IAAI,CACZ,CAAC;YACF;UACD,KAAK,KAAK;YACTH,aAAa,GAAG,IAAIrF,GAAG,CAAC,CACvBjB,OAAO,CAAC8C,KAAK,EACb9C,OAAO,CAACwG,IAAI,EACZxG,OAAO,CAACyG,IAAI,EACZzG,OAAO,CAAC0G,GAAG,EACX1G,OAAO,CAAC2G,KAAK,EACb3G,OAAO,CAAC4G,QAAQ,EAChB5G,OAAO,CAAC6G,cAAc,EACtB7G,OAAO,CAAC8G,KAAK,CACb,CAAC;YACF;UACD,KAAK,SAAS;YACbR,aAAa,GAAG,IAAIrF,GAAG,CAAC,CACvBjB,OAAO,CAAC8C,KAAK,EACb9C,OAAO,CAACwG,IAAI,EACZxG,OAAO,CAACyG,IAAI,EACZzG,OAAO,CAAC0G,GAAG,EACX1G,OAAO,CAAC2G,KAAK,EACb3G,OAAO,CAAC4G,QAAQ,EAChB5G,OAAO,CAAC6G,cAAc,EACtB7G,OAAO,CAAC+G,OAAO,EACf/G,OAAO,CAACgH,UAAU,EAClBhH,OAAO,CAACiH,IAAI,EACZjH,OAAO,CAACkH,MAAM,EACdlH,OAAO,CAAC8G,KAAK,CACb,CAAC;YACFP,eAAe,GAAG,IAAI;YACtB;UACD;YACCD,aAAa,GAAG,IAAIrF,GAAG,CAAC,CAAC;YACzB;QACF;QACA,MAAMkG,uBAAuB,GAAGxG,iBAAiB,CAAC6E,gBAAgB,CACjEjB,OAAO,CAACxB,OAAO,EACfZ,WAAW,CAACsD,QAAQ,CAACC,IACtB,CAAC;QACD,IAAI0B,qBAAqB,GAAG,CAAC;QAC7B,KAAK,MAAM,CAACvC,MAAM,EAAEwC,UAAU,CAAC,IAAIlF,WAAW,CAACgE,OAAO,EAAE;UACvD,MAAMmB,SAAS,GAAGlB,YAAY,CAACmB,IAAI,CAAC3F,EAAE,IAAIA,EAAE,CAACiD,MAAM,CAAC,CAAC;UACrD,IAAIsB,OAAO,KAAK,KAAK,IAAI,CAACmB,SAAS,EAAE;UACrC;UACA,MAAME,UAAU,GAAG,EAAE;UACrB;UACA,MAAMC,QAAQ,GAAG,EAAE;UACnB,IAAIC,WAAW,GAAGD,QAAQ;UAC1B,IAAIE,mBAAmB,GAAG,CAAC;UAC3B,KAAK,MAAMC,KAAK,IAAIP,UAAU,EAAE;YAC/B,IAAI3E,IAAI,GAAGkF,KAAK,CAAClF,IAAI;YACrB,IAAI,CAAC4E,SAAS,IAAI,CAAChB,aAAa,CAAC1B,GAAG,CAAClC,IAAI,CAAC,EAAE;;YAE5C;YACA,IACCA,IAAI,KAAK1C,OAAO,CAAC6G,cAAc,KAC9BS,SAAS,IAAIf,eAAe,CAAC,EAE9B7D,IAAI,GAAG1C,OAAO,CAAC2G,KAAK;YAErB,IAAIS,qBAAqB,KAAK,CAAC,EAAE;cAChCO,mBAAmB,EAAE;YACtB;YAEA,IAAIjF,IAAI,KAAK1C,OAAO,CAAC4G,QAAQ,EAAE;cAC9BY,UAAU,CAACK,GAAG,CAAC,CAAC;cAChBH,WAAW,GACVF,UAAU,CAAClF,MAAM,GAAG,CAAC,IAClB;cACAkF,UAAU,CAACA,UAAU,CAAClF,MAAM,GAAG,CAAC,CAAC,CAACE,QAAQ,IAE1CiF,QAAQ;cACZ,IAAIL,qBAAqB,GAAG,CAAC,EAAEA,qBAAqB,EAAE;cACtD;YACD;YACA,IAAInE,OAAO;YACX,IAAI2E,KAAK,CAAClF,IAAI,KAAK1C,OAAO,CAACiH,IAAI,EAAE;cAChC,MAAM,CAACa,KAAK,EAAEC,KAAK,EAAEC,MAAM,CAAC,GAC3B;cACCJ,KAAK,CAACK,IAAK;cACbhF,OAAO,GAAG,GAAG6E,KAAK,KAAKC,KAAK,GAAG,IAAI,GAAGC,MAAM,GAAG,OAAO,KAAK;YAC5D,CAAC,MAAM,IAAIJ,KAAK,CAACK,IAAI,IAAIL,KAAK,CAACK,IAAI,CAAC3F,MAAM,GAAG,CAAC,EAAE;cAC/CW,OAAO,GAAGtD,IAAI,CAACuI,MAAM,CAACN,KAAK,CAACK,IAAI,CAAC,CAAC,CAAC,EAAE,GAAGL,KAAK,CAACK,IAAI,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC;YAC7D;YACA;YACA,MAAMC,QAAQ,GAAG;cAChB,GAAGR,KAAK;cACRlF,IAAI;cACJO,OAAO;cACPoF,KAAK,EAAEhC,YAAY,GAAGuB,KAAK,CAACS,KAAK,GAAGC,SAAS;cAC7C9F,QAAQ,EACPE,IAAI,KAAK1C,OAAO,CAAC2G,KAAK,IAAIjE,IAAI,KAAK1C,OAAO,CAAC6G,cAAc,GACtD,EAAE,GACFyB;YACL,CAAC;YACDZ,WAAW,CAAC3C,IAAI,CAACqD,QAAQ,CAAC;YAC1B,IAAIA,QAAQ,CAAC5F,QAAQ,EAAE;cACtBgF,UAAU,CAACzC,IAAI,CAACqD,QAAQ,CAAC;cACzBV,WAAW,GAAGU,QAAQ,CAAC5F,QAAQ;cAC/B,IAAI4E,qBAAqB,GAAG,CAAC,EAAE;gBAC9BA,qBAAqB,EAAE;cACxB,CAAC,MAAM,IAAI1E,IAAI,KAAK1C,OAAO,CAAC6G,cAAc,EAAE;gBAC3CO,qBAAqB,GAAG,CAAC;cAC1B;YACD;UACD;UACA,IAAIhE,IAAI,GAAG+D,uBAAuB,CAACtC,MAAM,CAAC,CAAC0D,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;UAC9D,IAAInF,IAAI,IAAIP,MAAM,CAACsD,OAAO,EAAE;YAC3B,IAAIhF,CAAC,GAAG,CAAC;YACT,OAAO,GAAGiC,IAAI,IAAIjC,CAAC,EAAE,IAAI0B,MAAM,CAACsD,OAAO,EAAE;cACxChF,CAAC,EAAE;YACJ;YACAiC,IAAI,GAAG,GAAGA,IAAI,IAAIjC,CAAC,EAAE;UACtB;UACA0B,MAAM,CAACsD,OAAO,CAAC/C,IAAI,CAAC,GAAG;YACtBoF,OAAO,EAAEf,QAAQ;YACjBgB,eAAe,EAAEpB,UAAU,CAAC/E,MAAM,GAAGqF,mBAAmB;YACxDe,KAAK,EAAEpB;UACR,CAAC;QACF;MACD;IACD,CAAC;IACDqB,IAAI,EAAEA,CAAC9F,MAAM,EAAEV,WAAW,KAAK;MAC9BU,MAAM,CAAC8F,IAAI,GAAG,qBAAuBxG,WAAW,CAACwG,IAAK;IACvD,CAAC;IACDC,OAAO,EAAE/F,MAAM,IAAI;MAClBA,MAAM,CAAC+F,OAAO,GAAGhJ,OAAO,CAAC,oBAAoB,CAAC,CAACgJ,OAAO;IACvD,CAAC;IACDC,GAAG,EAAEA,CAAChG,MAAM,EAAEV,WAAW,EAAEY,OAAO,EAAE;MAAE+F;IAAK,CAAC,KAAK;MAChDjG,MAAM,CAACgG,GAAG,GAAGC,IAAI;IAClB,CAAC;IACDC,OAAO,EAAEA,CAAClG,MAAM,EAAEV,WAAW,KAAK;MACjCU,MAAM,CAACoE,IAAI,GACV,qBAAuB9E,WAAW,CAAC6G,OAAO,IAC1C,qBAAuB7G,WAAW,CAAC8G,SAAS,CAAC;IAC/C,CAAC;IACDC,OAAO,EAAEA,CAACrG,MAAM,EAAEV,WAAW,KAAK;MACjCU,MAAM,CAACqG,OAAO,GAAG,qBAAuB/G,WAAW,CAAC6G,OAAQ;IAC7D,CAAC;IACDG,UAAU,EAAEA,CAACtG,MAAM,EAAEV,WAAW,KAAK;MACpCU,MAAM,CAACsG,UAAU,GAAGhH,WAAW,CAACiH,OAAO,CACtC;MACCjH,WAAW,CAACkH,aAAa,CAACF,UAC5B,CAAC;IACF,CAAC;IACDG,UAAU,EAAEA,CAACzG,MAAM,EAAEV,WAAW,KAAK;MACpCU,MAAM,CAACyG,UAAU,GAAG;MACnBnH,WAAW,CAACkH,aAAa,CAACE,IAC1B;IACF,CAAC;IACDC,MAAM,EAAEA,CAAC3G,MAAM,EAAEV,WAAW,EAAEY,OAAO,EAAEwB,OAAO,EAAEC,OAAO,KAAK;MAC3D,MAAM;QAAE9B;MAAK,CAAC,GAAGK,OAAO;MACxB;MACA,MAAM0G,uBAAuB,GAAG,IAAIC,GAAG,CAAC,CAAC;MACzC;MACA,MAAMC,gCAAgC,GAAG,IAAID,GAAG,CAAC,CAAC;MAClD,KAAK,MAAMxG,KAAK,IAAIf,WAAW,CAACyH,MAAM,EAAE;QACvC,KAAK,MAAMnG,IAAI,IAAIP,KAAK,CAAC2G,KAAK,EAAE;UAC/B,IAAIC,KAAK,GAAGL,uBAAuB,CAAC5D,GAAG,CAACpC,IAAI,CAAC;UAC7C,IAAIqG,KAAK,KAAKxB,SAAS,EAAE;YACxBwB,KAAK,GAAG,EAAE;YACVL,uBAAuB,CAACzI,GAAG,CAACyC,IAAI,EAAEqG,KAAK,CAAC;UACzC;UACAA,KAAK,CAAC/E,IAAI,CAAC7B,KAAK,CAAC;QAClB;QACA,KAAK,MAAMO,IAAI,IAAIP,KAAK,CAAC6G,cAAc,EAAE;UACxC,IAAID,KAAK,GAAGH,gCAAgC,CAAC9D,GAAG,CAACpC,IAAI,CAAC;UACtD,IAAIqG,KAAK,KAAKxB,SAAS,EAAE;YACxBwB,KAAK,GAAG,EAAE;YACVH,gCAAgC,CAAC3I,GAAG,CAACyC,IAAI,EAAEqG,KAAK,CAAC;UAClD;UACAA,KAAK,CAAC/E,IAAI,CAAC7B,KAAK,CAAC;QAClB;MACD;MACA;MACA,MAAM8G,QAAQ,GAAG,IAAIN,GAAG,CAAC,CAAC;MAC1B;MACA,MAAMF,MAAM,GAAG,IAAIvI,GAAG,CAAC,CAAC;MACxB,KAAK,MAAMgJ,KAAK,IAAI9H,WAAW,CAAC+H,SAAS,CAAC,CAAC,EAAE;QAC5C;QACA,MAAMhJ,IAAI,GAAG;UACZ,GAAG+I,KAAK;UACRvH,IAAI,EAAE,OAAO;UACbyH,OAAO,EAAE7B;QACV,CAAC;QACDkB,MAAM,CAACpI,GAAG,CAACF,IAAI,CAAC;QAChB8I,QAAQ,CAAChJ,GAAG,CAACiJ,KAAK,CAAC7G,IAAI,EAAElC,IAAI,CAAC;MAC/B;MACA,KAAK,MAAMA,IAAI,IAAI8I,QAAQ,CAACI,MAAM,CAAC,CAAC,EAAE;QACrC,MAAMD,OAAO,GAAGjJ,IAAI,CAACuF,IAAI,CAAC0D,OAAO;QACjC,IAAI,CAACA,OAAO,EAAE;QACd,KAAK,MAAMzH,IAAI,IAAIZ,MAAM,CAACG,IAAI,CAACkI,OAAO,CAAC,EAAE;UACxC,MAAME,YAAY,GAAGF,OAAO,CAACzH,IAAI,CAAC;UAClC,MAAM4H,IAAI,GAAGjJ,KAAK,CAACkJ,OAAO,CAACF,YAAY,CAAC,GACrCA,YAAY,GACZ,CAACA,YAAY,CAAC;UACjB,KAAK,MAAMG,GAAG,IAAIF,IAAI,EAAE;YACvB,MAAMG,OAAO,GAAGT,QAAQ,CAACnE,GAAG,CAAC2E,GAAG,CAAC;YACjC,IAAI,CAACC,OAAO,EAAE;YACdjB,MAAM,CAACkB,MAAM,CAACD,OAAO,CAAC;YACtBA,OAAO,CAAC/H,IAAI,GAAGA,IAAI;YACnBxB,IAAI,CAACiJ,OAAO,GAAGjJ,IAAI,CAACiJ,OAAO,IAAI,EAAE;YACjCjJ,IAAI,CAACiJ,OAAO,CAACpF,IAAI,CAAC0F,OAAO,CAAC;UAC3B;QACD;MACD;MAEA5H,MAAM,CAAC8H,iBAAiB,GAAG,CAAC,CAAC;MAC7B,KAAK,MAAM,CAAClH,IAAI,EAAEmG,MAAM,CAAC,IAAIH,uBAAuB,EAAE;QACrD,KAAK,MAAMvG,KAAK,IAAI0G,MAAM,EAAE;UAC3B,MAAMxG,IAAI,GAAGF,KAAK,CAACE,IAAI;UACvB,IAAI,CAACA,IAAI,EAAE;UACX,IACC,CAACtB,MAAM,CAAC8I,SAAS,CAACC,cAAc,CAACC,IAAI,CACpCjI,MAAM,CAAC8H,iBAAiB,EACxBvH,IACD,CAAC,EACA;YACDP,MAAM,CAAC8H,iBAAiB,CAACvH,IAAI,CAAC,GAAG,EAAE;UACpC;UACAP,MAAM,CAAC8H,iBAAiB,CAACvH,IAAI,CAAC,CAAC2B,IAAI,CAACtB,IAAI,CAAC;QAC1C;MACD;MAEA,MAAMsH,aAAa,GAAGvG,OAAO,CAACzC,MAAM,CACnC,GAAGW,IAAI,SAAS,EAChBrB,KAAK,CAACC,IAAI,CAACkI,MAAM,CAAC,EAClB;QACC,GAAGzG,OAAO;QACV0G,uBAAuB;QACvBE;MACD,CACD,CAAC;MACD,MAAMqB,OAAO,GAAGC,YAAY,CAC3BF,aAAa,EACb,qBAAuBxG,OAAO,CAAC2G,WAChC,CAAC;MACDrI,MAAM,CAAC2G,MAAM,GAAGwB,OAAO,CAACxI,QAAQ;MAChCK,MAAM,CAACsI,cAAc,GAAGH,OAAO,CAACI,gBAAgB;IACjD,CAAC;IACDxB,MAAM,EAAEA,CAAC/G,MAAM,EAAEV,WAAW,EAAEY,OAAO,EAAEwB,OAAO,EAAEC,OAAO,KAAK;MAC3D,MAAM;QAAE9B;MAAK,CAAC,GAAGK,OAAO;MACxBF,MAAM,CAAC+G,MAAM,GAAGpF,OAAO,CAACzC,MAAM,CAC7B,GAAGW,IAAI,SAAS,EAChBrB,KAAK,CAACC,IAAI,CAACa,WAAW,CAACyH,MAAM,CAAC,EAC9B7G,OACD,CAAC;IACF,CAAC;IACDsI,OAAO,EAAEA,CAACxI,MAAM,EAAEV,WAAW,EAAEY,OAAO,EAAEwB,OAAO,EAAEC,OAAO,KAAK;MAC5D,MAAM;QAAE9B;MAAK,CAAC,GAAGK,OAAO;MACxB,MAAM+G,KAAK,GAAGzI,KAAK,CAACC,IAAI,CAACa,WAAW,CAACkJ,OAAO,CAAC;MAC7C,MAAMC,cAAc,GAAG9G,OAAO,CAACzC,MAAM,CAAC,GAAGW,IAAI,UAAU,EAAEoH,KAAK,EAAE/G,OAAO,CAAC;MACxE,MAAMiI,OAAO,GAAGC,YAAY,CAACK,cAAc,EAAE/G,OAAO,CAACgH,YAAY,CAAC;MAClE1I,MAAM,CAACwI,OAAO,GAAGL,OAAO,CAACxI,QAAQ;MACjCK,MAAM,CAAC2I,eAAe,GAAGR,OAAO,CAACI,gBAAgB;IAClD,CAAC;IACDK,WAAW,EAAEA,CACZ5I,MAAM,EACNV,WAAW,EACXY,OAAO,EACP;MAAE0I,WAAW;MAAEC,WAAW;MAAEC,mBAAmB;MAAEC;IAAmB,CAAC,EACrEpH,OAAO,KACH;MACJ,MAAM;QAAE9B;MAAK,CAAC,GAAGK,OAAO;MACxB,MAAM+G,KAAK,GAAGzI,KAAK,CAACC,IAAI,CAACa,WAAW,CAACsJ,WAAW,EAAE,CAAC,CAACzJ,GAAG,EAAE6J,KAAK,CAAC,MAAM;QACpEzI,IAAI,EAAEpB,GAAG;QACT8J,UAAU,EAAED;MACb,CAAC,CAAC,CAAC;MACH,IAAIJ,WAAW,KAAK,MAAM,IAAI,CAACC,WAAW,EAAE;QAC3C,IAAI5B,KAAK,CAACxH,MAAM,GAAG,CAAC,EAAE;QACtB,IACC,CAACsJ,kBAAkB,IACnB9B,KAAK,CAACiC,KAAK,CAAC,CAAC;UAAED;QAAW,CAAC,KAAK;UAC/B,IAAIA,UAAU,CAAClC,MAAM,CAACtH,MAAM,KAAK,CAAC,EAAE,OAAO,KAAK;UAChD,MAAMY,KAAK,GAAG4I,UAAU,CAAClC,MAAM,CAAC,CAAC,CAAC;UAClC,OACC1G,KAAK,CAAC2G,KAAK,CAACmC,IAAI,KAAK,CAAC,KACrB,CAACL,mBAAmB,IAAIzI,KAAK,CAAC6G,cAAc,CAACiC,IAAI,KAAK,CAAC,CAAC;QAE3D,CAAC,CAAC,EACD;UACD;QACD;MACD;MACAnJ,MAAM,CAAC4I,WAAW,GAAGjH,OAAO,CAACzC,MAAM,CAClC,GAAGW,IAAI,cAAc,EACrBoH,KAAK,EACL/G,OACD,CAAC;IACF,CAAC;IACD2I,WAAW,EAAEA,CAAC7I,MAAM,EAAEV,WAAW,EAAEY,OAAO,EAAEwB,OAAO,EAAEC,OAAO,KAAK;MAChE,MAAM;QAAE9B;MAAK,CAAC,GAAGK,OAAO;MACxB,MAAM+G,KAAK,GAAGzI,KAAK,CAACC,IAAI,CACvBa,WAAW,CAAC8J,gBAAgB,EAC5B,CAAC,CAACjK,GAAG,EAAE6J,KAAK,CAAC,MAAM;QAClBzI,IAAI,EAAEpB,GAAG;QACT8J,UAAU,EAAED;MACb,CAAC,CACF,CAAC;MACDhJ,MAAM,CAACoJ,gBAAgB,GAAGzH,OAAO,CAACzC,MAAM,CACvC,GAAGW,IAAI,mBAAmB,EAC1BoH,KAAK,EACL/G,OACD,CAAC;IACF,CAAC;IACD+C,MAAM,EAAEA,CAACjD,MAAM,EAAEV,WAAW,EAAEY,OAAO,EAAEwB,OAAO,EAAEC,OAAO,KAAK;MAC3D,MAAM;QAAE9B,IAAI;QAAEuC;MAAgB,CAAC,GAAGlC,OAAO;MACzC,MAAMmJ,SAAS,GAAGjH,eAAe,CAAC9C,WAAW,CAAC;MAC9C,MAAMgK,gBAAgB,GAAG3H,OAAO,CAACzC,MAAM,CACtC,GAAGW,IAAI,SAAS,EAChBuC,eAAe,CAAC9C,WAAW,CAAC,EAC5BY,OACD,CAAC;MACD,IAAIqJ,QAAQ,GAAG,CAAC;MAChB,IAAI7H,OAAO,CAACS,YAAY,KAAK,MAAM,IAAIkH,SAAS,CAAC5J,MAAM,IAAI,CAAC,EAAE;QAC7D8J,QAAQ,GAAGF,SAAS,CAClBvG,GAAG,CAAC0G,CAAC,IAAI,OAAOA,CAAC,KAAK,QAAQ,IAAIA,CAAC,CAACjH,OAAO,CAAC,CAC5CkH,MAAM,CAACC,OAAO,CAAC,CAACjK,MAAM;MACzB;MACA,IACCiC,OAAO,CAACS,YAAY,KAAK,IAAI,IAC7B,CAACwH,MAAM,CAACC,QAAQ,CAAClI,OAAO,CAACmI,WAAW,CAAC,EACpC;QACD7J,MAAM,CAACiD,MAAM,GAAGqG,gBAAgB;QAChC,IAAIC,QAAQ,EAAEvJ,MAAM,CAAC8J,yBAAyB,GAAGP,QAAQ;QACzD;MACD;MACA,MAAM,CAACtG,MAAM,EAAE8G,eAAe,CAAC,GAAGC,gBAAgB,CACjDV,gBAAgB,EAChB;MACC5H,OAAO,CAACmI,WACV,CAAC;MACD7J,MAAM,CAAC8J,yBAAyB,GAAGP,QAAQ,GAAGQ,eAAe;MAC7D/J,MAAM,CAACiD,MAAM,GAAGA,MAAM;IACvB,CAAC;IACDgH,WAAW,EAAEA,CAACjK,MAAM,EAAEV,WAAW,EAAE;MAAE8C;IAAgB,CAAC,KAAK;MAC1DpC,MAAM,CAACiK,WAAW,GAAG5K,iBAAiB,CAACC,WAAW,EAAEM,CAAC,IACpDwC,eAAe,CAACxC,CAAC,CAClB,CAAC;IACF,CAAC;IACDuD,QAAQ,EAAEA,CAACnD,MAAM,EAAEV,WAAW,EAAEY,OAAO,EAAEwB,OAAO,EAAEC,OAAO,KAAK;MAC7D,MAAM;QAAE9B,IAAI;QAAEwC;MAAkB,CAAC,GAAGnC,OAAO;MAC3C,MAAMgK,WAAW,GAAGvI,OAAO,CAACzC,MAAM,CACjC,GAAGW,IAAI,WAAW,EAClBwC,iBAAiB,CAAC/C,WAAW,CAAC,EAC9BY,OACD,CAAC;MACD,IAAIqJ,QAAQ,GAAG,CAAC;MAChB,IAAI7H,OAAO,CAACS,YAAY,KAAK,MAAM,EAAE;QACpCoH,QAAQ,GAAGlH,iBAAiB,CAAC/C,WAAW,CAAC,CACvCwD,GAAG,CAAC0G,CAAC,IAAI,OAAOA,CAAC,KAAK,QAAQ,IAAIA,CAAC,CAACjH,OAAO,CAAC,CAC5CkH,MAAM,CAACC,OAAO,CAAC,CAACjK,MAAM;MACzB;MACA,IACCiC,OAAO,CAACS,YAAY,KAAK,IAAI,IAC7B,CAACwH,MAAM,CAACC,QAAQ,CAAClI,OAAO,CAACyI,aAAa,CAAC,EACtC;QACDnK,MAAM,CAACmD,QAAQ,GAAG+G,WAAW;QAC7B,IAAIX,QAAQ,EAAEvJ,MAAM,CAACoK,2BAA2B,GAAGb,QAAQ;QAC3D;MACD;MACA,MAAM,CAACpG,QAAQ,EAAE4G,eAAe,CAAC,GAAGC,gBAAgB,CACnDE,WAAW,EACX;MACCxI,OAAO,CAACyI,aACV,CAAC;MACDnK,MAAM,CAACoK,2BAA2B,GAAGb,QAAQ,GAAGQ,eAAe;MAC/D/J,MAAM,CAACmD,QAAQ,GAAGA,QAAQ;IAC3B,CAAC;IACDkH,aAAa,EAAEA,CACdrK,MAAM,EACNV,WAAW,EACXY,OAAO,EACP;MAAEoK;IAAe,CAAC,EAClB3I,OAAO,KACH;MACJ,MAAM;QAAE9B,IAAI;QAAEwC;MAAkB,CAAC,GAAGnC,OAAO;MAC3CF,MAAM,CAACqK,aAAa,GAAGhL,iBAAiB,CAACC,WAAW,EAAE,CAACM,CAAC,EAAE2K,SAAS,KAAK;QACvE,IACC,CAACD,cAAc,IACf;QACCA,cAAc,CAAE7K,MAAM,KAAK,CAAC,EAE7B,OAAO4C,iBAAiB,CAACzC,CAAC,CAAC;QAC5B,OAAO+B,OAAO,CACZzC,MAAM,CAAC,GAAGW,IAAI,GAAG0K,SAAS,WAAW,EAAElI,iBAAiB,CAACzC,CAAC,CAAC,EAAEM,OAAO,CAAC,CACrEuJ,MAAM;QACN;AACN;AACA;AACA;QACMe,OAAO,IAAI;UACV,MAAMC,aAAa,GAAGxL,MAAM,CAACG,IAAI,CAACoL,OAAO,CAAC,CACxC1H,GAAG,CACH3D,GAAG,IACF,GAAGqL,OAAO,EAAC,oCAAsCrL,GAAG,EAAE,EACxD,CAAC,CACAuL,IAAI,CAAC,IAAI,CAAC;UACZ,OAAO,CAACJ,cAAc,CAAC5F,IAAI,CAAC+E,MAAM,IACjCA,MAAM,CAACe,OAAO,EAAEC,aAAa,CAC9B,CAAC;QACF,CACD,CAAC;MACH,CAAC,CAAC;IACH,CAAC;IACD9K,QAAQ,EAAEA,CAACK,MAAM,EAAEV,WAAW,EAAEY,OAAO,EAAEwB,OAAO,EAAEC,OAAO,KAAK;MAC7D,MAAM;QAAE9B;MAAK,CAAC,GAAGK,OAAO;MACxBF,MAAM,CAACL,QAAQ,GAAGgC,OAAO,CAACzC,MAAM,CAC/B,GAAGW,IAAI,WAAW,EAClBP,WAAW,CAACK,QAAQ,EACpBO,OACD,CAAC;IACF;EACD,CAAC;EACDkH,KAAK,EAAE;IACNrH,CAAC,EAAEA,CAACC,MAAM,EAAEoH,KAAK,EAAElH,OAAO,EAAEwB,OAAO,EAAEC,OAAO,KAAK;MAChD,MAAM;QAAErC;MAAY,CAAC,GAAGY,OAAO;MAC/BF,MAAM,CAACH,IAAI,GAAGuH,KAAK,CAACvH,IAAI;MACxBG,MAAM,CAACO,IAAI,GAAG6G,KAAK,CAAC7G,IAAI;MACxBP,MAAM,CAACmJ,IAAI,GAAG/B,KAAK,CAACuD,MAAM,CAACxB,IAAI,CAAC,CAAC;MACjCnJ,MAAM,CAAC4K,OAAO,GAAGtL,WAAW,CAACuL,aAAa,CAAC9I,GAAG,CAACqF,KAAK,CAAC7G,IAAI,CAAC;MAC1DP,MAAM,CAAC8K,eAAe,GAAGxL,WAAW,CAACyL,qBAAqB,CAAChJ,GAAG,CAC7DqF,KAAK,CAAC7G,IACP,CAAC;MACD,MAAMyK,MAAM,GAAG,CAAChL,MAAM,CAAC4K,OAAO,IAAI,CAAC5K,MAAM,CAAC8K,eAAe;MACzD9K,MAAM,CAACgL,MAAM,GAAGA,MAAM;MACtBhL,MAAM,CAAC4D,IAAI,GAAGwD,KAAK,CAACxD,IAAI;MACxB,IAAI,CAACoH,MAAM,IAAItJ,OAAO,CAACuJ,YAAY,EAAE;QACpChM,MAAM,CAACiM,MAAM,CACZlL,MAAM,EACN2B,OAAO,CAACzC,MAAM,CAAC,GAAGgB,OAAO,CAACL,IAAI,UAAU,EAAEuH,KAAK,EAAElH,OAAO,CACzD,CAAC;MACF;IACD;EACD,CAAC;EACDiL,aAAa,EAAE;IACdpL,CAAC,EAAEA,CACFC,MAAM,EACNoH,KAAK,EACL;MAAE9H,WAAW;MAAEsH,uBAAuB;MAAEE;IAAiC,CAAC,KACtE;MACJ,MAAMC,MAAM,GAAGH,uBAAuB,CAAC5D,GAAG,CAACoE,KAAK,CAAC7G,IAAI,CAAC,IAAI,EAAE;MAC5D,MAAM6K,eAAe,GACpBtE,gCAAgC,CAAC9D,GAAG,CAACoE,KAAK,CAAC7G,IAAI,CAAC,IAAI,EAAE;MACvDP,MAAM,CAACqL,UAAU,GAAG3M,kBAAkB,CACrCqI,MAAM,EACNnH,CAAC,IAAKA,CAAC,CAACW,IAAI,GAAG,CAACX,CAAC,CAACW,IAAI,CAAC,GAAG,EAAG,EAC7B7C,UACD,CAAC;MACDsC,MAAM,CAACsL,YAAY,GAAG5M,kBAAkB,CACvCqI,MAAM,EACNnH,CAAC,IAAIpB,KAAK,CAACC,IAAI,CAACmB,CAAC,CAAC2L,WAAW,CAAC,EAC9B7N,UACD,CAAC;MACDsC,MAAM,CAACwL,mBAAmB,GAAG9M,kBAAkB,CAC9C0M,eAAe,EACfxL,CAAC,IAAKA,CAAC,CAACW,IAAI,GAAG,CAACX,CAAC,CAACW,IAAI,CAAC,GAAG,EAAG,EAC7B7C,UACD,CAAC;MACDsC,MAAM,CAACyL,qBAAqB,GAAG/M,kBAAkB,CAChD0M,eAAe,EACfxL,CAAC,IAAIpB,KAAK,CAACC,IAAI,CAACmB,CAAC,CAAC2L,WAAW,CAAC,EAC9B7N,UACD,CAAC;MACDsC,MAAM,CAAC0L,eAAe,GAAGtE,KAAK,CAACE,OAAO,GAAGF,KAAK,CAACE,OAAO,CAAC7H,MAAM,GAAGgG,SAAS;IAC1E,CAAC;IACDkG,aAAa,EAAEA,CAAC3L,MAAM,EAAEoH,KAAK,EAAElH,OAAO,EAAEwB,OAAO,EAAEC,OAAO,KAAK;MAC5D,MAAM;QAAE9B;MAAK,CAAC,GAAGK,OAAO;MACxBF,MAAM,CAACsH,OAAO,GAAG3F,OAAO,CAACzC,MAAM,CAC9B,GAAGW,IAAI,CAACyF,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,UAAU,EAC9B8B,KAAK,CAACE,OAAO,IAAI,EAAE,EACnBpH,OACD,CAAC;MACDF,MAAM,CAAC0L,eAAe,GAAGtE,KAAK,CAACE,OAAO,GACnCF,KAAK,CAACE,OAAO,CAAC7H,MAAM,GACrB,2BAA6BO,MAAM,CAACsH,OAAO,CAAE7H,MAAM,GAClDgG,SAAS;IACb,CAAC;IACDtE,GAAG,EAAEA,CACJnB,MAAM,EACNoH,KAAK,EACL;MAAER,uBAAuB;MAAEE;IAAiC,CAAC,KACzD;MACJ,MAAMC,MAAM,GAAGH,uBAAuB,CAAC5D,GAAG,CAACoE,KAAK,CAAC7G,IAAI,CAAC,IAAI,EAAE;MAC5D,MAAM6K,eAAe,GACpBtE,gCAAgC,CAAC9D,GAAG,CAACoE,KAAK,CAAC7G,IAAI,CAAC,IAAI,EAAE;MACvDP,MAAM,CAAC+G,MAAM,GAAGrI,kBAAkB,CACjCqI,MAAM,EACNnH,CAAC,KAAI,wBAA0BA,CAAC,CAACuB,GAAG,CAAC,EACrCzD,UACD,CAAC;MACDsC,MAAM,CAACoL,eAAe,GAAG1M,kBAAkB,CAC1C0M,eAAe,EACfxL,CAAC,KAAI,wBAA0BA,CAAC,CAACuB,GAAG,CAAC,EACrCzD,UACD,CAAC;IACF,CAAC;IACDkO,WAAW,EAAEA,CAAC5L,MAAM,EAAEoH,KAAK,KAAK;MAC/BpH,MAAM,CAAC6L,eAAe,GAAGxO,gBAAgB,CAACwO,eAAe,CAACzE,KAAK,CAACuD,MAAM,CAAC;IACxE;EACD,CAAC;EACD1B,UAAU,EAAE;IACXlJ,CAAC,EAAEA,CACFC,MAAM,EACN;MAAEO,IAAI;MAAE0I;IAAW,CAAC,EACpB;MAAE3J,WAAW;MAAEA,WAAW,EAAE;QAAEsC,WAAW;QAAER;MAAW;IAAE,CAAC,EACzD;MAAED,GAAG;MAAE2H,mBAAmB;MAAEC,kBAAkB;MAAE+C;IAAoB,CAAC,KACjE;MACJ,MAAMnM,QAAQ,GACboJ,kBAAkB,IAClBE,UAAU,CAAC8C,mBAAmB,CAACnK,WAAW,EAAER,UAAU,CAAC;MACxD;AACH;AACA;AACA;MACG,MAAM4K,OAAO,GAAGzL,IAAI,IAAI;QACvB,MAAM6G,KAAK,GAAG9H,WAAW,CAAC2M,QAAQ,CAAC1L,IAAI,CAAC;QACxC,OAAO;UACNA,IAAI;UACJ4I,IAAI,GAAE,qBAAuB/B,KAAK,GAAGA,KAAK,CAACxD,IAAI,CAACuF,IAAI,GAAG,CAAC,CAAC;QAC1D,CAAC;MACF,CAAC;MACD;MACA,MAAM+C,WAAW,GAAGA,CAACC,KAAK,EAAE;QAAEhD;MAAK,CAAC,KAAKgD,KAAK,GAAGhD,IAAI;MACrD,MAAMxC,MAAM,GAAG3I,WAAW,CAACiL,UAAU,CAAClC,MAAM,EAAEnH,CAAC,IAAIA,CAAC,CAACoH,KAAK,CAAC,CAAClE,GAAG,CAACkJ,OAAO,CAAC;MACxE,MAAMI,eAAe,GAAG1N,kBAAkB,CACzCuK,UAAU,CAAClC,MAAM,EACjBnH,CAAC,IAAIA,CAAC,CAACsH,cAAc,EACrBxJ,UACD,CAAC,CAACoF,GAAG,CAACkJ,OAAO,CAAC;MACd,MAAMK,UAAU,GAAG1F,MAAM,CAAC2F,MAAM,CAACJ,WAAW,EAAE,CAAC,CAAC;MAChD,MAAMK,mBAAmB,GAAGH,eAAe,CAACE,MAAM,CAACJ,WAAW,EAAE,CAAC,CAAC;MAClE;MACA,MAAMM,eAAe,GAAG;QACvBjM,IAAI;QACJwG,MAAM,EAAE5F,GAAG,IACR,wBAA0B8H,UAAU,CAAClC,MAAM,CAACjE,GAAG,CAAClD,CAAC,IAAIA,CAAC,CAAC0B,EAAE,CAAC,IAC1DmE,SAAS;QACZkB,MAAM,EAAEA,MAAM,CAAClH,MAAM,IAAIqM,mBAAmB,GAAGnF,MAAM,GAAGlB,SAAS;QACjE6C,cAAc,EACb3B,MAAM,CAAClH,MAAM,IAAIqM,mBAAmB,GAAG,CAAC,GAAGnF,MAAM,CAAClH,MAAM;QACzD4M,UAAU;QACVD,eAAe,EACdtD,mBAAmB,IAAIsD,eAAe,CAAC3M,MAAM,IAAIqM,mBAAmB,GACjEM,eAAe,GACf3G,SAAS;QACbgH,uBAAuB,EACtB3D,mBAAmB,IAAIsD,eAAe,CAAC3M,MAAM,IAAIqM,mBAAmB,GACjE,CAAC,GACDM,eAAe,CAAC3M,MAAM;QAC1B8M,mBAAmB;QACnB5M,QAAQ,EAAEA,QAAQ,GACfd,SAAS,CAACc,QAAQ,EAAE+M,MAAM,IAC1BA,MAAM,CAAC5J,GAAG,CAACgB,KAAK,IAAI;UACnB,MAAM6C,MAAM,GAAG3I,WAAW,CAAC8F,KAAK,CAACiD,MAAM,EAAEnH,CAAC,IAAIA,CAAC,CAACoH,KAAK,CAAC,CAAClE,GAAG,CACzDkJ,OACD,CAAC;UACD,MAAMI,eAAe,GAAG1N,kBAAkB,CACzCoF,KAAK,CAACiD,MAAM,EACZnH,CAAC,IAAIA,CAAC,CAACsH,cAAc,EACrBxJ,UACD,CAAC,CAACoF,GAAG,CAACkJ,OAAO,CAAC;;UAEd;UACA,MAAMW,oBAAoB,GAAG;YAC5BpM,IAAI,EAAEuD,KAAK,CAACvD,IAAI;YAChBwG,MAAM,EAAE5F,GAAG,IACR;YACA2C,KAAK,CAACiD,MAAM,CAACjE,GAAG,CAAClD,CAAC,IAAIA,CAAC,CAAC0B,EAAE,CAAC,IAC3BmE,SAAS;YACZkB,MAAM,EACLA,MAAM,CAAClH,MAAM,IAAIqM,mBAAmB,GAAGnF,MAAM,GAAGlB,SAAS;YAC1D6C,cAAc,EACb3B,MAAM,CAAClH,MAAM,IAAIqM,mBAAmB,GAAG,CAAC,GAAGnF,MAAM,CAAClH,MAAM;YACzD2M,eAAe,EACdtD,mBAAmB,IACnBsD,eAAe,CAAC3M,MAAM,IAAIqM,mBAAmB,GAC1CM,eAAe,GACf3G,SAAS;YACbgH,uBAAuB,EACtB3D,mBAAmB,IACnBsD,eAAe,CAAC3M,MAAM,IAAIqM,mBAAmB,GAC1C,CAAC,GACDM,eAAe,CAAC3M;UACrB,CAAC;UAED,OAAOkN,oBAAoB;QAC5B,CAAC,CACF,CAAC,GACAlH,SAAS;QACZmH,WAAW,EAAEjN,QAAQ,GAClBd,SAAS,CAACc,QAAQ,EAAE+M,MAAM,IAAI;UAC9B;UACA,MAAMvO,GAAG,GAAG,IAAIC,GAAG,CAAC,CAAC;UACrB,KAAK,MAAM0F,KAAK,IAAI4I,MAAM,EAAE;YAC3B,KAAK,MAAMrM,KAAK,IAAIyD,KAAK,CAACiD,MAAM,EAAE;cACjC,KAAK,MAAMK,KAAK,IAAI/G,KAAK,CAAC2G,KAAK,EAAE;gBAChC7I,GAAG,CAACI,GAAG,CAAC6I,KAAK,CAAC;cACf;YACD;UACD;UACA,OAAO5I,KAAK,CAACC,IAAI,CAACN,GAAG,CAAC;QACvB,CAAC,CAAC,GACDsH;MACJ,CAAC;MACDxG,MAAM,CAACiM,MAAM,CAAClL,MAAM,EAAEwM,eAAe,CAAC;IACvC,CAAC;IACDZ,WAAW,EAAEA,CAAC5L,MAAM,EAAE;MAAEiJ;IAAW,CAAC,KAAK;MACxCjJ,MAAM,CAAC6L,eAAe,GAAGxO,gBAAgB,CAACwO,eAAe,CAAC5C,UAAU,CAAC;IACtE;EACD,CAAC;EACDpI,MAAM,EAAE;IACPd,CAAC,EAAEA,CAACC,MAAM,EAAEa,MAAM,EAAEX,OAAO,EAAEwB,OAAO,EAAEC,OAAO,KAAK;MACjD,MAAM;QAAE9B;MAAK,CAAC,GAAGK,OAAO;MACxB,MAAMZ,WAAW,GAAG,0BAA4BY,OAAO,CAACZ,WAAY;MACpE,MAAMuN,KAAK,GAAGvN,WAAW,CAACwN,YAAY,CAAC/K,GAAG,CAAClB,MAAM,CAAC;MAClD,MAAMkM,aAAa,GAAGzN,WAAW,CAAC0N,oBAAoB,CAACjL,GAAG,CAAClB,MAAM,CAAC;MAClE,MAAMoM,iBAAiB,GACtB3N,WAAW,CAAC4N,wBAAwB,CAACnL,GAAG,CAAClB,MAAM,CAAC;MACjD;MACA,MAAMsM,KAAK,GAAG,CAAC,CAAC;MAChB,KAAK,MAAMC,UAAU,IAAIvM,MAAM,CAACwM,cAAc,CAAC,CAAC,EAAE;QACjDF,KAAK,CAACC,UAAU,CAAC,GAAGvM,MAAM,CAACsI,IAAI,CAACiE,UAAU,CAAC;MAC5C;MACA;MACA,MAAME,WAAW,GAAG;QACnBzN,IAAI,EAAE,QAAQ;QACd0N,UAAU,EAAE1M,MAAM,CAAChB,IAAI;QACvB2N,KAAK,EAAE3M,MAAM,CAAC2M,KAAK;QACnBrE,IAAI,EAAEtI,MAAM,CAACsI,IAAI,CAAC,CAAC;QACnBgE,KAAK;QACLN,KAAK;QACLE,aAAa;QACbE,iBAAiB;QACjBjC,MAAM,EAAE,CAAC6B,KAAK,IAAI,CAACE;MACpB,CAAC;MACD9N,MAAM,CAACiM,MAAM,CAAClL,MAAM,EAAEsN,WAAW,CAAC;MAElC,IAAIT,KAAK,IAAIE,aAAa,IAAIrL,OAAO,CAAC+L,aAAa,EAAE;QACpDxO,MAAM,CAACiM,MAAM,CACZlL,MAAM,EACN2B,OAAO,CAACzC,MAAM,CAAC,GAAGW,IAAI,UAAU,EAAEgB,MAAM,EAAEX,OAAO,CAClD,CAAC;MACF;IACD;EACD,CAAC;EACDwN,cAAc,EAAE;IACf3N,CAAC,EAAEA,CAACC,MAAM,EAAEa,MAAM,EAAEX,OAAO,EAAE;MAAEC;IAAiB,CAAC,EAAEwB,OAAO,KAAK;MAC9D,MAAM;QAAE9B,IAAI;QAAE8N;MAAY,CAAC,GAAGzN,OAAO;MACrC,MAAMZ,WAAW,GAAG,0BAA4BY,OAAO,CAACZ,WAAY;MACpE,MAAM;QAAEsC;MAAY,CAAC,GAAGtC,WAAW;MACnC;MACA,MAAMoH,IAAI,GAAG,EAAE;MACf,MAAMkH,MAAM,GAAGhM,WAAW,CAACK,SAAS,CAACpB,MAAM,CAAC;MAC5C,IAAIiB,OAAO,GAAG8L,MAAM;MACpB,OAAO9L,OAAO,EAAE;QACf4E,IAAI,CAACxE,IAAI,CAACJ,OAAO,CAAC;QAClBA,OAAO,GAAGF,WAAW,CAACK,SAAS,CAACH,OAAO,CAAC;MACzC;MACA4E,IAAI,CAACmH,OAAO,CAAC,CAAC;MACd,MAAM3J,OAAO,GAAGtC,WAAW,CAACkM,UAAU,CAACjN,MAAM,CAAC;MAC9C,MAAMoC,MAAM,GAAGpC,MAAM,CAACqC,SAAS,CAAC,CAAC;MACjC,MAAM+G,WAAW,GAAGhH,MAAM,KAAKwC,SAAS,GAAGnI,aAAa,CAAC2F,MAAM,CAAC,GAAG,CAAC;MACpE,MAAME,QAAQ,GAAGtC,MAAM,CAACuC,WAAW,CAAC,CAAC;MACrC,MAAMiH,aAAa,GAClBlH,QAAQ,KAAKsC,SAAS,GAAGnI,aAAa,CAAC6F,QAAQ,CAAC,GAAG,CAAC;MACrD;MACA,MAAMgK,KAAK,GAAG,CAAC,CAAC;MAChB,KAAK,MAAMC,UAAU,IAAIvM,MAAM,CAACwM,cAAc,CAAC,CAAC,EAAE;QACjDF,KAAK,CAACC,UAAU,CAAC,GAAGvM,MAAM,CAACsI,IAAI,CAACiE,UAAU,CAAC;MAC5C;MACA;MACA,MAAME,WAAW,GAAG;QACnBvM,UAAU,EAAEF,MAAM,CAACE,UAAU,CAAC,CAAC;QAC/BR,IAAI,EAAEM,MAAM,CAACI,kBAAkB,CAACd,gBAAgB,CAAC;QACjD4N,gBAAgB,EAAElN,MAAM,CAACkN,gBAAgB,CAAC,CAAC;QAC3CC,KAAK,GAAE,qBAAuBpM,WAAW,CAACqM,gBAAgB,CAACpN,MAAM,CAAC,CAAC;QACnEqN,aAAa,GAAE;QACdtM,WAAW,CAACqM,gBAAgB,CAACpN,MAAM,CAAC,CACpC;QACDsN,MAAM,GAAE,qBAAuBvM,WAAW,CAACwM,iBAAiB,CAACvN,MAAM,CAAC,CAAC;QACrEwN,cAAc,GAAE;QACfzM,WAAW,CAACwM,iBAAiB,CAACvN,MAAM,CAAC,CACrC;QACDyN,SAAS,EAAE,wBAA0BzN,MAAM,CAAC0N,SAAS,CAAED,SAAS;QAChEE,QAAQ,EAAE3N,MAAM,CAAC4N,UAAU,CAAC7M,WAAW,CAAC;QACxC8M,MAAM,EACL,CAAC7O,IAAI,CAACyC,QAAQ,CAAC,iCAAiC,CAAC,IACjDhD,WAAW,CAAC8B,UAAU,CAACuN,uBAAuB,CAAC9N,MAAM,CAAC,KAAK,CAAC;QAC7D+N,SAAS,EAAEjB,WAAW,GAAG,CAACA,WAAW,CAAC5L,GAAG,CAAClB,MAAM,CAAC,GAAG4E,SAAS;QAC7DmI,MAAM,EAAEA,MAAM,IAAIA,MAAM,CAAC7M,UAAU,CAAC,CAAC;QACrC8N,UAAU,EAAEjB,MAAM,IAAIA,MAAM,CAAC3M,kBAAkB,CAACd,gBAAgB,CAAC;QACjE2O,UAAU,EACTlB,MAAM,IACNjM,OAAO,CAACzC,MAAM,CAAC,GAAGW,IAAI,CAACyF,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,aAAa,EAAEoB,IAAI,EAAExG,OAAO,CAAC;QACjE6O,MAAM,EAAE9E,WAAW,GAAG,CAAC;QACvBhH,MAAM,EAAEgH,WAAW;QACnB9G,QAAQ,EAAEkH;MACX,CAAC;MACDpL,MAAM,CAACiM,MAAM,CAAClL,MAAM,EAAEsN,WAAW,CAAC;MAClC,IAAIpJ,OAAO,EAAE;QACZlE,MAAM,CAACkE,OAAO,GAAGvC,OAAO,CAACzC,MAAM,CAC9B,GAAGW,IAAI,CAACyF,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,UAAU,EAC9BpB,OAAO,EACPhE,OACD,CAAC;MACF;IACD,CAAC;IACDiB,GAAG,EAAEA,CAACnB,MAAM,EAAEa,MAAM,EAAE;MAAEvB,WAAW,EAAE;QAAE8B,UAAU;QAAEQ;MAAY;IAAE,CAAC,KAAK;MACtE5B,MAAM,CAACsB,EAAE,GAAG,uBAAyBF,UAAU,CAACI,WAAW,CAACX,MAAM,CAAE;MACpE,MAAM+M,MAAM,GAAGhM,WAAW,CAACK,SAAS,CAACpB,MAAM,CAAC;MAC5Cb,MAAM,CAACgP,QAAQ,GAAGpB,MAAM,IAAIxM,UAAU,CAACI,WAAW,CAACoM,MAAM,CAAC;MAC1D5N,MAAM,CAAC+G,MAAM,GACZ;;MAECvI,KAAK,CAACC,IAAI,CACT2C,UAAU,CAAC6N,8BAA8B,CACxCpO,MAAM,EACNrD,iBACD,CAAC,EACD6C,KAAK,IAAIA,KAAK,CAACiB,EAChB,CACA;IACH,CAAC;IACD4N,YAAY,EAAEA,CAAClP,MAAM,EAAEa,MAAM,KAAK;MACjCb,MAAM,CAAC2G,MAAM,GAAG,wBAA0B9F,MAAM,CAAC0N,SAAS,CAAE5H,MAAM,GAC/D1H,MAAM,CAACG,IAAI,CAAC,wBAA0ByB,MAAM,CAAC0N,SAAS,CAAE5H,MAAM,CAAC,GAC/D,EAAE;IACN,CAAC;IACDwI,OAAO,EAAEA,CAACnP,MAAM,EAAEa,MAAM,EAAEX,OAAO,EAAEwB,OAAO,EAAEC,OAAO,KAAK;MACvD,MAAM;QACL9B,IAAI;QACJP,WAAW,EAAE;UAAEsC;QAAY;MAC5B,CAAC,GAAG1B,OAAO;MACX,MAAMkP,aAAa,GAAGzN,OAAO,CAACzC,MAAM,CACnC,GAAGW,IAAI,CAACyF,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,UAAU,EAC9B9G,KAAK,CAACC,IAAI,CAACmD,WAAW,CAACyN,sBAAsB,CAACxO,MAAM,CAAC,CAAC,EACtDX,OACD,CAAC;MACD,MAAMiI,OAAO,GAAGC,YAAY,CAC3BgH,aAAa,EACb;MACC1N,OAAO,CAAC4N,YACV,CAAC;MACDtP,MAAM,CAACmP,OAAO,GAAGhH,OAAO,CAACxI,QAAQ;MACjCK,MAAM,CAACuP,eAAe,GAAGpH,OAAO,CAACI,gBAAgB;IAClD,CAAC;IACDiH,WAAW,EAAEA,CACZxP,MAAM,EACNa,MAAM,EACN;MAAE4O,OAAO;MAAEnQ,WAAW,EAAE;QAAEsC;MAAY;IAAE,CAAC,KACrC;MACJ,MAAM4N,WAAW,GAAG5N,WAAW,CAAC8N,cAAc,CAAC7O,MAAM,EAAE4O,OAAO,CAAC;MAC/D,IAAID,WAAW,KAAK,IAAI,EAAE;QACzBxP,MAAM,CAACwP,WAAW,GAAG,IAAI;MAC1B,CAAC,MAAM,IAAI,OAAOA,WAAW,KAAK,SAAS,EAAE;QAC5CxP,MAAM,CAACwP,WAAW,GAAGA,WAAW;MACjC,CAAC,MAAM;QACNxP,MAAM,CAACwP,WAAW,GAAGhR,KAAK,CAACC,IAAI,CAAC+Q,WAAW,CAAC;MAC7C;IACD,CAAC;IACDG,eAAe,EAAEA,CAAC3P,MAAM,EAAEa,MAAM,EAAE;MAAEvB,WAAW,EAAE;QAAEsC;MAAY;IAAE,CAAC,KAAK;MACtE,MAAM+N,eAAe,GAAG/N,WAAW,CAACgO,kBAAkB,CAAC/O,MAAM,CAAC;MAC9Db,MAAM,CAAC2P,eAAe,GAAGnR,KAAK,CAACkJ,OAAO,CAACiI,eAAe,CAAC,GACpDA,eAAe,GACf,IAAI;IACR,CAAC;IACDE,mBAAmB,EAAEA,CACpB7P,MAAM,EACNa,MAAM,EACN;MAAEvB,WAAW,EAAE;QAAEsC;MAAY;IAAE,CAAC,EAChC;MAAEzB;IAAiB,CAAC,KAChB;MACJH,MAAM,CAAC6P,mBAAmB,GAAGjO,WAAW,CACtCkO,sBAAsB,CAACjP,MAAM,CAAC,CAC9BiC,GAAG,CAACzE,IAAI,IAAI;QACZ,IAAI,OAAOA,IAAI,KAAK,UAAU,EAAE,OAAOA,IAAI,CAAC8B,gBAAgB,CAAC;QAC7D,OAAO9B,IAAI;MACZ,CAAC,CAAC;IACJ,CAAC;IACD0R,KAAK,EAAEA,CAAC/P,MAAM,EAAEa,MAAM,EAAE;MAAEvB,WAAW,EAAE;QAAEsC;MAAY;IAAE,CAAC,KAAK;MAC5D5B,MAAM,CAAC+P,KAAK,GAAGnO,WAAW,CAACoO,QAAQ,CAACnP,MAAM,CAAC;IAC5C,CAAC;IACDoP,aAAa,EAAEA,CAACjQ,MAAM,EAAEa,MAAM,EAAEX,OAAO,EAAEwB,OAAO,EAAEC,OAAO,KAAK;MAC7D,MAAM;QAAE9B;MAAK,CAAC,GAAGK,OAAO;MACxB,MAAMgQ,YAAY,GAAG,8CACpBrP,MAAM,CACL2H,OAAO;MACT,IAAIhK,KAAK,CAACkJ,OAAO,CAACwI,YAAY,CAAC,EAAE;QAChC,MAAMzH,cAAc,GAAG9G,OAAO,CAACzC,MAAM,CACpC,GAAGW,IAAI,CAACyF,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,UAAU,EAC9B4K,YAAY,EACZhQ,OACD,CAAC;QACD,MAAMiI,OAAO,GAAGC,YAAY,CAC3BK,cAAc,EACd/G,OAAO,CAACyO,kBACT,CAAC;QACDnQ,MAAM,CAACwI,OAAO,GAAGL,OAAO,CAACxI,QAAQ;QACjCK,MAAM,CAAC2I,eAAe,GAAGR,OAAO,CAACI,gBAAgB;MAClD;IACD,CAAC;IACDoC,MAAM,EAAEA,CAAC3K,MAAM,EAAEa,MAAM,KAAK;MAC3B,MAAMuP,cAAc,GAAGvP,MAAM,CAACuP,cAAc,CAAC,CAAC;MAC9C,IAAIA,cAAc,EAAE;QACnBpQ,MAAM,CAAC2K,MAAM,GAAGyF,cAAc,CAACzF,MAAM,CAAC,CAAC;MACxC;IACD;EACD,CAAC;EACDzG,OAAO,EAAE;IACRnE,CAAC,EAAEA,CAACC,MAAM,EAAEkE,OAAO,KAAK;MACvB;MACA,MAAMmM,YAAY,GAAG;QACpBlE,KAAK,EACJjI,OAAO,CAACvC,OAAO,GACfuC,OAAO,CAACoM,SAAS,GACjBpM,OAAO,CAACqM,WAAW,GACnBrM,OAAO,CAACsM,QAAQ,GAChBtM,OAAO,CAACuM,OAAO;QAChBC,SAAS,EAAExM,OAAO,CAACvC,OAAO;QAC1B2O,SAAS,EAAEpM,OAAO,CAACoM,SAAS;QAC5BE,QAAQ,EAAEtM,OAAO,CAACsM,QAAQ;QAC1BD,WAAW,EAAErM,OAAO,CAACqM,WAAW;QAChCE,OAAO,EAAEvM,OAAO,CAACuM,OAAO;QACxBE,mBAAmB,EAAEzM,OAAO,CAAC0M,mBAAmB;QAChDC,qBAAqB,EAAE3M,OAAO,CAAC2M,qBAAqB;QACpD;QACAlP,OAAO,EAAEuC,OAAO,CAACvC,OAAO;QACxB;QACAmP,YAAY,EAAE5M,OAAO,CAAC0M;MACvB,CAAC;MACD3R,MAAM,CAACiM,MAAM,CAAClL,MAAM,EAAEqQ,YAAY,CAAC;IACpC;EACD,CAAC;EACDU,YAAY,EAAE;IACbhR,CAAC,EAAEA,CAACC,MAAM,EAAEa,MAAM,EAAEX,OAAO,EAAE;MAAEC;IAAiB,CAAC,EAAEwB,OAAO,KAAK;MAC9D,MAAM;QAAE9B;MAAK,CAAC,GAAGK,OAAO;MACxB,MAAMZ,WAAW,GAAG,0BAA4BY,OAAO,CAACZ,WAAY;MACpE,MAAM;QAAEsC;MAAY,CAAC,GAAGtC,WAAW;MACnC,MAAM4E,OAAO,GAAGtC,WAAW,CAACkM,UAAU,CAACjN,MAAM,CAAC;MAC9C;MACA,MAAMmQ,iBAAiB,GAAG;QACzBjQ,UAAU,EAAEF,MAAM,CAACE,UAAU,CAAC,CAAC;QAC/BR,IAAI,EAAEM,MAAM,CAACI,kBAAkB,CAACd,gBAAgB;MACjD,CAAC;MACDlB,MAAM,CAACiM,MAAM,CAAClL,MAAM,EAAEgR,iBAAiB,CAAC;MACxC,IAAI9M,OAAO,EAAE;QACZlE,MAAM,CAACkE,OAAO,GAAGvC,OAAO,CAACzC,MAAM,CAAC,GAAGW,IAAI,UAAU,EAAEqE,OAAO,EAAEhE,OAAO,CAAC;MACrE;IACD,CAAC;IACDiB,GAAG,EAAEA,CAACnB,MAAM,EAAEa,MAAM,EAAE;MAAEvB,WAAW,EAAE;QAAE8B;MAAW;IAAE,CAAC,KAAK;MACzDpB,MAAM,CAACsB,EAAE,GAAG,uBAAyBF,UAAU,CAACI,WAAW,CAACX,MAAM,CAAE;IACrE;EACD,CAAC;EACDoQ,YAAY,EAAE;IACblR,CAAC,EAAEA,CAACC,MAAM,EAAEkR,MAAM,EAAE;MAAEzB;IAAQ,CAAC,EAAE;MAAEtP;IAAiB,CAAC,KAAK;MACzD,MAAMwH,GAAG,GAAGuJ,MAAM,CAACC,UAAU;MAC7B,MAAMC,SAAS,GACdzJ,GAAG,IAAIA,GAAG,YAAY1K,gBAAgB,GAAG0K,GAAG,GAAGlC,SAAS;MACzD;MACA,MAAM4L,iBAAiB,GAAG;QACzBvQ,gBAAgB,EAAEoQ,MAAM,CAACI,YAAY,GAClCJ,MAAM,CAACI,YAAY,CAACvQ,UAAU,CAAC,CAAC,GAChC,IAAI;QACPF,MAAM,EAAEqQ,MAAM,CAACI,YAAY,GACxBJ,MAAM,CAACI,YAAY,CAACrQ,kBAAkB,CAACd,gBAAgB,CAAC,GACxD,IAAI;QACPa,UAAU,EAAEkQ,MAAM,CAACI,YAAY,GAC5BJ,MAAM,CAACI,YAAY,CAACrQ,kBAAkB,CAACd,gBAAgB,CAAC,GACxD,IAAI;QACPoR,wBAAwB,EAAEL,MAAM,CAACM,oBAAoB,GAClDN,MAAM,CAACM,oBAAoB,CAACzQ,UAAU,CAAC,CAAC,GACxC,IAAI;QACP0Q,cAAc,EAAEP,MAAM,CAACM,oBAAoB,GACxCN,MAAM,CAACM,oBAAoB,CAACvQ,kBAAkB,CAACd,gBAAgB,CAAC,GAChE,IAAI;QACPN,IAAI,EAAEqR,MAAM,CAACC,UAAU,GAAGD,MAAM,CAACC,UAAU,CAACtR,IAAI,GAAG,IAAI;QACvD6R,MAAM,EAAER,MAAM,CAACS,QAAQ,CAAClC,OAAO,CAAC;QAChCmC,WAAW,EAAEV,MAAM,CAACU,WAAW;QAC/BC,WAAW,EAAGT,SAAS,IAAIA,SAAS,CAACS,WAAW,IAAK;MACtD,CAAC;MACD5S,MAAM,CAACiM,MAAM,CAAClL,MAAM,EAAEqR,iBAAiB,CAAC;MACxC,IAAIH,MAAM,CAACC,UAAU,EAAE;QACtB,MAAMW,OAAO,GAAG5U,cAAc,CAACgU,MAAM,CAACC,UAAU,CAACjQ,GAAG,CAAC;QACrD,IAAI4Q,OAAO,EAAE;UACZ9R,MAAM,CAACkB,GAAG,GAAG4Q,OAAO;QACrB;MACD;IACD,CAAC;IACD3Q,GAAG,EAAEA,CAACnB,MAAM,EAAEkR,MAAM,EAAE;MAAE5R,WAAW,EAAE;QAAE8B;MAAW;IAAE,CAAC,KAAK;MACzDpB,MAAM,CAACuB,QAAQ,GAAG2P,MAAM,CAACI,YAAY,GAClClQ,UAAU,CAACI,WAAW,CAAC0P,MAAM,CAACI,YAAY,CAAC,GAC3C,IAAI;MACPtR,MAAM,CAAC+R,gBAAgB,GAAGb,MAAM,CAACM,oBAAoB,GAClDpQ,UAAU,CAACI,WAAW,CAAC0P,MAAM,CAACM,oBAAoB,CAAC,GACnD,IAAI;IACR;EACD,CAAC;EACDnR,KAAK,EAAE;IACNN,CAAC,EAAEA,CAACC,MAAM,EAAEK,KAAK,EAAE;MAAEvC,iBAAiB;MAAEwB,WAAW,EAAE;QAAE8B;MAAW;IAAE,CAAC,KAAK;MACzE,MAAM4Q,cAAc,GAAG3R,KAAK,CAAC4R,mBAAmB,CAAC7Q,UAAU,CAAC;;MAE5D;MACA,MAAM8Q,UAAU,GAAG;QAClBC,QAAQ,EAAE9R,KAAK,CAAC8R,QAAQ;QACxBC,OAAO,EAAE/R,KAAK,CAACM,YAAY,CAAC,CAAC;QAC7BoE,KAAK,EAAE1E,KAAK,CAACI,UAAU,CAAC,CAAC;QACzB4R,QAAQ,EAAEjV,yBAAyB,CAACkV,gBAAgB,CAACjS,KAAK,CAAC;QAC3D6Q,MAAM,EAAE7Q,KAAK,CAACkS,WAAW;QACzBpJ,IAAI,EAAE/H,UAAU,CAACoR,mBAAmB,CAACnS,KAAK,CAAC;QAC3C8M,KAAK,EAAE/L,UAAU,CAACqR,oBAAoB,CAACpS,KAAK,CAAC;QAC7CqS,KAAK,EAAErS,KAAK,CAACE,IAAI,GAAG,CAACF,KAAK,CAACE,IAAI,CAAC,GAAG,EAAE;QACrCoS,OAAO,EAAEnU,KAAK,CAACC,IAAI,CAAC4B,KAAK,CAACkL,WAAW,CAAC;QACtCkE,OAAO,EACNpP,KAAK,CAACoP,OAAO,KAAKhK,SAAS,GACxBA,SAAS,GACT,OAAOpF,KAAK,CAACoP,OAAO,KAAK,QAAQ,GAChC,CAAC3R,iBAAiB,CAACuC,KAAK,CAACoP,OAAO,CAAC,CAAC,GAClCjR,KAAK,CAACC,IAAI,CAAC4B,KAAK,CAACoP,OAAO,CAAC7Q,IAAI,CAAC,CAAC,EAAEd,iBAAiB,CAAC;QACxDkJ,KAAK,EAAExI,KAAK,CAACC,IAAI,CAAC4B,KAAK,CAAC2G,KAAK,CAAC;QAC9BE,cAAc,EAAE1I,KAAK,CAACC,IAAI,CAAC4B,KAAK,CAAC6G,cAAc,CAAC,CAACtI,IAAI,CAAClB,UAAU,CAAC;QACjEoI,IAAI,GAAE,qBAAuBzF,KAAK,CAACuS,YAAY,CAAC;QAChDC,eAAe,EAAEb;MAClB,CAAC;MACD/S,MAAM,CAACiM,MAAM,CAAClL,MAAM,EAAEkS,UAAU,CAAC;IAClC,CAAC;IACD/Q,GAAG,EAAEA,CAACnB,MAAM,EAAEK,KAAK,KAAK;MACvBL,MAAM,CAACsB,EAAE,GAAG,sBAAwBjB,KAAK,CAACiB,EAAG;IAC9C,CAAC;IACDwR,cAAc,EAAEA,CAAC9S,MAAM,EAAEK,KAAK,EAAE;MAAEf,WAAW,EAAE;QAAE8B;MAAW;IAAE,CAAC,KAAK;MACnE;MACA,MAAM2R,OAAO,GAAG,IAAI3U,GAAG,CAAC,CAAC;MACzB;MACA,MAAMuB,QAAQ,GAAG,IAAIvB,GAAG,CAAC,CAAC;MAC1B;MACA,MAAM4U,QAAQ,GAAG,IAAI5U,GAAG,CAAC,CAAC;MAE1B,KAAK,MAAM6K,UAAU,IAAI5I,KAAK,CAAC4S,cAAc,EAAE;QAC9C,KAAK,MAAMC,WAAW,IAAIjK,UAAU,CAACkK,eAAe,EAAE;UACrD,KAAK,MAAM9S,KAAK,IAAI6S,WAAW,CAACnM,MAAM,EAAE;YACvCgM,OAAO,CAACxU,GAAG,CAAC,sBAAwB8B,KAAK,CAACiB,EAAG,CAAC;UAC/C;QACD;QACA,KAAK,MAAM8R,UAAU,IAAInK,UAAU,CAACoK,gBAAgB,EAAE;UACrD,KAAK,MAAMhT,KAAK,IAAI+S,UAAU,CAACrM,MAAM,EAAE;YACtCpH,QAAQ,CAACpB,GAAG,CAAC,sBAAwB8B,KAAK,CAACiB,EAAG,CAAC;UAChD;QACD;QACA,KAAK,MAAMgS,OAAO,IAAIrK,UAAU,CAAClC,MAAM,EAAE;UACxC,IAAIuM,OAAO,KAAKjT,KAAK,EACpB2S,QAAQ,CAACzU,GAAG,CAAC,sBAAwB+U,OAAO,CAAChS,EAAG,CAAC;QACnD;MACD;MACAtB,MAAM,CAACgT,QAAQ,GAAGxU,KAAK,CAACC,IAAI,CAACuU,QAAQ,CAAC,CAACpU,IAAI,CAAClB,UAAU,CAAC;MACvDsC,MAAM,CAAC+S,OAAO,GAAGvU,KAAK,CAACC,IAAI,CAACsU,OAAO,CAAC,CAACnU,IAAI,CAAClB,UAAU,CAAC;MACrDsC,MAAM,CAACL,QAAQ,GAAGnB,KAAK,CAACC,IAAI,CAACkB,QAAQ,CAAC,CAACf,IAAI,CAAClB,UAAU,CAAC;IACxD,CAAC;IACD6V,YAAY,EAAEA,CAACvT,MAAM,EAAEK,KAAK,EAAEH,OAAO,EAAEwB,OAAO,EAAEC,OAAO,KAAK;MAC3D,MAAM;QACL9B,IAAI;QACJP,WAAW,EAAE;UAAE8B;QAAW;MAC3B,CAAC,GAAGlB,OAAO;MACX,MAAM+G,KAAK,GAAG7F,UAAU,CAACoS,eAAe,CAACnT,KAAK,CAAC;MAC/C,MAAMoI,cAAc,GAAG9G,OAAO,CAACzC,MAAM,CAAC,GAAGW,IAAI,UAAU,EAAEoH,KAAK,EAAE;QAC/D,GAAG/G,OAAO;QACVuP,OAAO,EAAEpP,KAAK,CAACoP,OAAO;QACtB9B,WAAW,EAAE,IAAIvP,GAAG,CAACgD,UAAU,CAACqS,mBAAmB,CAACpT,KAAK,CAAC;MAC3D,CAAC,CAAC;MACF,MAAM8H,OAAO,GAAGC,YAAY,CAACK,cAAc,EAAE/G,OAAO,CAACgS,iBAAiB,CAAC;MACvE1T,MAAM,CAACwI,OAAO,GAAGL,OAAO,CAACxI,QAAQ;MACjCK,MAAM,CAAC2I,eAAe,GAAGR,OAAO,CAACI,gBAAgB;IAClD,CAAC;IACDoL,YAAY,EAAEA,CAAC3T,MAAM,EAAEK,KAAK,EAAEH,OAAO,EAAEwB,OAAO,EAAEC,OAAO,KAAK;MAC3D,MAAM;QACL9B,IAAI;QACJP,WAAW,EAAE;UAAE8B;QAAW;MAC3B,CAAC,GAAGlB,OAAO;MACX;MACA,MAAM0T,aAAa,GAAG,IAAIxV,GAAG,CAAC,CAAC;MAC/B,MAAMyV,OAAO,GAAG,EAAE;MAClB,KAAK,MAAMC,CAAC,IAAIzT,KAAK,CAAC4S,cAAc,EAAE;QACrCY,OAAO,CAAC3R,IAAI,CAAC,GAAG4R,CAAC,CAACD,OAAO,CAAC;MAC3B;MACA,MAAM5M,KAAK,GAAG4M,OAAO,CAACpK,MAAM,CAACzH,MAAM,IAAI;QACtC,MAAM7C,GAAG,GAAG,CACX6C,MAAM,CAACnB,MAAM,GAAGO,UAAU,CAACI,WAAW,CAACQ,MAAM,CAACnB,MAAM,CAAC,GAAG4E,SAAS,EACjEvI,cAAc,CAAC8E,MAAM,CAACd,GAAG,CAAC,EAC1Bc,MAAM,CAAC+R,OAAO,CACd,CAACrJ,IAAI,CAAC,CAAC;QACR,IAAIkJ,aAAa,CAAC7R,GAAG,CAAC5C,GAAG,CAAC,EAAE,OAAO,KAAK;QACxCyU,aAAa,CAACrV,GAAG,CAACY,GAAG,CAAC;QACtB,OAAO,IAAI;MACZ,CAAC,CAAC;MACFa,MAAM,CAAC6T,OAAO,GAAGlS,OAAO,CAACzC,MAAM,CAAC,GAAGW,IAAI,UAAU,EAAEoH,KAAK,EAAE/G,OAAO,CAAC;IACnE;EACD,CAAC;EACD8T,WAAW,EAAE;IACZjU,CAAC,EAAEA,CAACC,MAAM,EAAEgC,MAAM,EAAE9B,OAAO,EAAE;MAAEC;IAAiB,CAAC,KAAK;MACrD;MACA,MAAM8T,gBAAgB,GAAG;QACxBpT,MAAM,EAAEmB,MAAM,CAACnB,MAAM,GAAGmB,MAAM,CAACnB,MAAM,CAACE,UAAU,CAAC,CAAC,GAAG,EAAE;QACvDD,gBAAgB,EAAEkB,MAAM,CAACnB,MAAM,GAAGmB,MAAM,CAACnB,MAAM,CAACE,UAAU,CAAC,CAAC,GAAG,EAAE;QACjEC,UAAU,EAAEgB,MAAM,CAACnB,MAAM,GACtBmB,MAAM,CAACnB,MAAM,CAACI,kBAAkB,CAACd,gBAAgB,CAAC,GAClD,EAAE;QACLe,GAAG,EAAEhE,cAAc,CAAC8E,MAAM,CAACd,GAAG,CAAC;QAC/B6S,OAAO,EAAE/R,MAAM,CAAC+R;MACjB,CAAC;MACD9U,MAAM,CAACiM,MAAM,CAAClL,MAAM,EAAEiU,gBAAgB,CAAC;IACxC,CAAC;IACD9S,GAAG,EAAEA,CAACnB,MAAM,EAAEgC,MAAM,EAAE;MAAE1C,WAAW,EAAE;QAAE8B;MAAW;IAAE,CAAC,KAAK;MACzDpB,MAAM,CAACuB,QAAQ,GAAGS,MAAM,CAACnB,MAAM,IAC5B,uBAAyBO,UAAU,CAACI,WAAW,CAACQ,MAAM,CAACnB,MAAM,CAAC,IAC9D4E,SAAS;IACb;EACD,CAAC;EACDxF,KAAK,EAAEH,aAAa;EACpB0K,OAAO,EAAE1K,aAAa;EACtBoU,eAAe,EAAE;IAChBnU,CAAC,EAAEA,CAACC,MAAM,EAAE;MAAEgC,MAAM;MAAEnB;IAAO,CAAC,EAAEX,OAAO,EAAE;MAAEC;IAAiB,CAAC,EAAEwB,OAAO,KAAK;MAC1E,MAAM;QACL9B,IAAI;QACJP,WAAW,EAAE;UAAEsC;QAAY;MAC5B,CAAC,GAAG1B,OAAO;MACXF,MAAM,CAACmU,gBAAgB,GAAGnS,MAAM,CAACjB,UAAU,CAAC,CAAC;MAC7Cf,MAAM,CAACoU,UAAU,GAAGpS,MAAM,CAACf,kBAAkB,CAACd,gBAAgB,CAAC;MAC/DH,MAAM,CAACc,gBAAgB,GAAGD,MAAM,CAACE,UAAU,CAAC,CAAC;MAC7Cf,MAAM,CAACgB,UAAU,GAAGH,MAAM,CAACI,kBAAkB,CAACd,gBAAgB,CAAC;MAC/D,MAAM2Q,YAAY,GAAGtS,KAAK,CAACC,IAAI,CAC9BmD,WAAW,CAACyN,sBAAsB,CAACxO,MAAM,CAC1C,CAAC,CACC4I,MAAM,CAAC7J,CAAC,IAAIA,CAAC,CAAC4R,oBAAoB,KAAKxP,MAAM,IAAIpC,CAAC,CAACuR,UAAU,CAAC,CAC9DrO,GAAG,CAAClD,CAAC,IAAIA,CAAC,CAACuR,UAAU,CAAC;MACxBnR,MAAM,CAAC8Q,YAAY,GAAGnP,OAAO,CAACzC,MAAM,CACnC,GAAGW,IAAI,eAAe,EACtBrB,KAAK,CAACC,IAAI,CAAC,IAAIL,GAAG,CAAC0S,YAAY,CAAC,CAAC,EACjC5Q,OACD,CAAC;IACF,CAAC;IACDiB,GAAG,EAAEA,CAACnB,MAAM,EAAE;MAAEgC,MAAM;MAAEnB;IAAO,CAAC,EAAE;MAAEvB,WAAW,EAAE;QAAE8B;MAAW;IAAE,CAAC,KAAK;MACrEpB,MAAM,CAACqU,QAAQ,GACd;MACCjT,UAAU,CAACI,WAAW,CAACQ,MAAM,CAAE;MACjChC,MAAM,CAACuB,QAAQ,GACd;MACCH,UAAU,CAACI,WAAW,CAACX,MAAM,CAAE;IAClC;EACD,CAAC;EACDyT,qBAAqB,EAAE;IACtBvU,CAAC,EAAEA,CAACC,MAAM,EAAEmR,UAAU,KAAK;MAC1BnR,MAAM,CAACkB,GAAG,GAAGhE,cAAc,CAACiU,UAAU,CAACjQ,GAAG,CAAC;IAC5C;EACD;AACD,CAAC;;AAED;AACA,MAAMqT,MAAM,GAAG;EACd,gBAAgB,EAAE;IACjB,gBAAgB,EAAEC,CAACtD,MAAM,EAAE;MAAE5R,WAAW,EAAE;QAAE8B;MAAW;IAAE,CAAC,KAAK;MAC9D,IACC8P,MAAM,CAACI,YAAY,IACnBlQ,UAAU,CAACuN,uBAAuB,CAACuC,MAAM,CAACI,YAAY,CAAC,KAAK,CAAC,EAC5D;QACD,OAAO,KAAK;MACb;IACD;EACD;AACD,CAAC;;AAED;AACA,MAAMmD,cAAc,GAAG;EACtB,sBAAsB,EAAE;IACvBnK,cAAc,EAAExN,IAAI,CAAC4X,SAAS,CAC7B,CAAClK,OAAO,EAAEtK,OAAO,EAAE;MAAEoK;IAAe,CAAC,KAAK;MACzC,MAAMG,aAAa,GAAGxL,MAAM,CAACG,IAAI,CAACoL,OAAO,CAAC,CACxC1H,GAAG,CAAC3D,GAAG,IAAI,GAAGqL,OAAO,EAAC,oCAAsCrL,GAAG,EAAE,EAAE,CAAC,CACpEuL,IAAI,CAAC,IAAI,CAAC;MACZ,OAAO,CAACJ,cAAc,CAAC5F,IAAI,CAAC+E,MAAM,IAAIA,MAAM,CAACe,OAAO,EAAEC,aAAa,CAAC,CAAC;IACtE,CAAC,EACD,6EAA6E,EAC7E,mCACD;EACD;AACD,CAAC;;AAED;AACA,MAAMkK,cAAc,GAAG;EACtB5U,CAAC,EAAEA,CAAC6U,WAAW,EAAE;IAAEtV,WAAW,EAAE;MAAEsC;IAAY;EAAE,CAAC,KAAK;IACrDgT,WAAW,CAAC1S,IAAI,CACftE,aAAa;IACZ;AACJ;AACA;AACA;IACIiX,CAAC,IAAIjT,WAAW,CAACoO,QAAQ,CAAC6E,CAAC,CAAC,EAC5BpX,cACD,CAAC,EACDG,aAAa;IACZ;AACJ;AACA;AACA;IACIiX,CAAC,IAAIjT,WAAW,CAACqM,gBAAgB,CAAC4G,CAAC,CAAC,EACpCpX,cACD,CAAC,EACDG,aAAa;IACZ;AACJ;AACA;AACA;IACIiX,CAAC,IAAIA,CAAC,CAAC9T,UAAU,CAAC,CAAC,EACnBrD,UACD,CACD,CAAC;EACF;AACD,CAAC;;AAED;AACA,MAAMoX,OAAO,GAAG;EACf,oBAAoB,EAAE;IACrB/U,CAAC,EAAE6U,WAAW,IAAI;MACjBA,WAAW,CAAC1S,IAAI,CAACtE,aAAa,CAACgC,CAAC,IAAIA,CAAC,CAAC0B,EAAE,EAAE5D,UAAU,CAAC,CAAC;IACvD;EACD,CAAC;EACD,qBAAqB,EAAEiX,cAAc;EACrC,mBAAmB,EAAEA,cAAc;EACnC,eAAe,EAAEA,cAAc;EAC/B,gBAAgB,EAAEA,cAAc;EAChC,gBAAgB,EAAE;IACjB5U,CAAC,EAAEA,CAAC6U,WAAW,EAAE;MAAEtV,WAAW,EAAE;QAAE8B;MAAW;IAAE,CAAC,KAAK;MACpDwT,WAAW,CAAC1S,IAAI,CACftE,aAAa,CAACmX,CAAC,IAAIA,CAAC,CAACzD,YAAY,EAAEzT,0BAA0B,CAC9D,CAAC;MACD+W,WAAW,CAAC1S,IAAI,CACftE,aAAa,CAACmX,CAAC,IAAIA,CAAC,CAACvD,oBAAoB,EAAE3T,0BAA0B,CACtE,CAAC;MACD+W,WAAW,CAAC1S,IAAI,CACftE,aAAa,CACZmX,CAAC,IAAIA,CAAC,CAAC5D,UAAU,EACjBxT,iBAAiB,CAChBC,aAAa;MACZ;AACP;AACA;AACA;MACOmX,CAAC,IAAIA,CAAC,CAAC7T,GAAG,EACV3D,gBACD,CAAC,EACDK,aAAa,CAACmX,CAAC,IAAIA,CAAC,CAAClV,IAAI,EAAEnC,UAAU,CACtC,CACD,CACD,CAAC;IACF;EACD,CAAC;EACD,eAAe,EAAE;IAChBqC,CAAC,EAAEA,CAAC6U,WAAW,EAAE;MAAEtV,WAAW,EAAE;QAAE8B;MAAW;IAAE,CAAC,KAAK;MACpDwT,WAAW,CAAC1S,IAAI,CACftE,aAAa,CACZoE,MAAM,IACLA,MAAM,CAACnB,MAAM,GAAGO,UAAU,CAACI,WAAW,CAACQ,MAAM,CAACnB,MAAM,CAAC,GAAG4E,SAAS,EAClE/H,UACD,CAAC,EACDE,aAAa,CAACoE,MAAM,IAAI9E,cAAc,CAAC8E,MAAM,CAACd,GAAG,CAAC,EAAExD,UAAU,CAAC,EAC/DE,aAAa,CAACoE,MAAM,IAAIA,MAAM,CAAC+R,OAAO,EAAErW,UAAU,CACnD,CAAC;IACF;EACD;AACD,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMsX,WAAW,GAAG3W,IAAI;AACvB;AACA;AACA;AACA,CAACA,IAAI,CAACsB,QAAQ,GACX,CAAC,GACDtB,IAAI,CAACkK,gBAAgB,GACpB,CAAC,GAAG0M,YAAY,CAAC5W,IAAI,CAACsB,QAAQ,CAAC,GAC/B,CAAC,GAAGsV,YAAY,CAAC5W,IAAI,CAACsB,QAAQ,CAAC;;AAEpC;AACA;AACA;AACA;AACA;AACA,MAAMsV,YAAY,GAAGtV,QAAQ,IAAI;EAChC,IAAIwJ,IAAI,GAAG,CAAC;EACZ,KAAK,MAAMzJ,KAAK,IAAIC,QAAQ,EAAE;IAC7BwJ,IAAI,IAAI6L,WAAW,CAACtV,KAAK,CAAC;EAC3B;EACA,OAAOyJ,IAAI;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAM+L,aAAa,GAAGvV,QAAQ,IAAI;EACjC,IAAIH,KAAK,GAAG,CAAC;EACb,KAAK,MAAME,KAAK,IAAIC,QAAQ,EAAE;IAC7B,IAAI,CAACD,KAAK,CAACC,QAAQ,IAAI,CAACD,KAAK,CAAC6I,gBAAgB,EAAE;MAC/C/I,KAAK,EAAE;IACR,CAAC,MAAM;MACN,IAAIE,KAAK,CAACC,QAAQ,EAAEH,KAAK,IAAI0V,aAAa,CAACxV,KAAK,CAACC,QAAQ,CAAC;MAC1D,IAAID,KAAK,CAAC6I,gBAAgB,EAAE/I,KAAK,IAAIE,KAAK,CAAC6I,gBAAgB;IAC5D;EACD;EACA,OAAO/I,KAAK;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAM2V,QAAQ,GAAGxV,QAAQ,IAAI;EAC5B;EACA,MAAMyV,WAAW,GAAG,EAAE;EACtB,KAAK,MAAM1V,KAAK,IAAIC,QAAQ,EAAE;IAC7B,IAAID,KAAK,CAACC,QAAQ,EAAE;MACnB,IAAI4I,gBAAgB,GAAG7I,KAAK,CAAC6I,gBAAgB,IAAI,CAAC;MAClDA,gBAAgB,IAAI2M,aAAa,CAACxV,KAAK,CAACC,QAAQ,CAAC;MACjDyV,WAAW,CAAClT,IAAI,CAAC;QAChB,GAAGxC,KAAK;QACRC,QAAQ,EAAE8F,SAAS;QACnB8C;MACD,CAAC,CAAC;IACH,CAAC,MAAM;MACN6M,WAAW,CAAClT,IAAI,CAACxC,KAAK,CAAC;IACxB;EACD;EACA,OAAO0V,WAAW;AACnB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMhN,YAAY,GAAGA,CACpBiN,cAAc,EACdC,GAAG,EACHC,4BAA4B,GAAG,KAAK,KAChC;EACJ,IAAID,GAAG,GAAG,CAAC,EAAE;IACZ,OAAO,0BAA4B;MAClC3V,QAAQ,EAAE8F,SAAS;MACnB8C,gBAAgB,EAAE2M,aAAa,CAACG,cAAc;IAC/C,CAAC;EACF;EACA;EACA,IAAI1V,QAAQ;EACZ;EACA,IAAI4I,gBAAgB;EACpB;EACA;EACA,MAAMmE,MAAM,GAAG,EAAE;EACjB;EACA;EACA,MAAM8I,UAAU,GAAG,EAAE;EACrB;EACA,MAAMvX,KAAK,GAAG,EAAE;EAChB;EACA,IAAIwX,UAAU,GAAG,CAAC;EAElB,KAAK,MAAMC,WAAW,IAAIL,cAAc,EAAE;IACzC;IACA,IAAI,CAACK,WAAW,CAAC/V,QAAQ,IAAI,CAAC+V,WAAW,CAACnN,gBAAgB,EAAE;MAC3DtK,KAAK,CAACiE,IAAI,CAACwT,WAAW,CAAC;IACxB,CAAC,MAAM;MACNhJ,MAAM,CAACxK,IAAI,CAACwT,WAAW,CAAC;MACxB,MAAMvM,IAAI,GAAG6L,WAAW,CAACU,WAAW,CAAC;MACrCF,UAAU,CAACtT,IAAI,CAACiH,IAAI,CAAC;MACrBsM,UAAU,IAAItM,IAAI;IACnB;EACD;EAEA,IAAIsM,UAAU,GAAGxX,KAAK,CAACwB,MAAM,IAAI6V,GAAG,EAAE;IACrC;IACA;IACA3V,QAAQ,GAAG+M,MAAM,CAACjN,MAAM,GAAG,CAAC,GAAGiN,MAAM,CAACiJ,MAAM,CAAC1X,KAAK,CAAC,GAAGA,KAAK;EAC5D,CAAC,MAAM,IAAIyO,MAAM,CAACjN,MAAM,KAAK,CAAC,EAAE;IAC/B;IACA;IACA,MAAMmW,KAAK,GAAGN,GAAG,IAAIC,4BAA4B,GAAG,CAAC,GAAG,CAAC,CAAC;IAC1DhN,gBAAgB,GAAGtK,KAAK,CAACwB,MAAM,GAAGmW,KAAK;IACvC3X,KAAK,CAACwB,MAAM,GAAGmW,KAAK;IACpBjW,QAAQ,GAAG1B,KAAK;EACjB,CAAC,MAAM;IACN;IACA,MAAM2X,KAAK,GACVlJ,MAAM,CAACjN,MAAM,IACZ8V,4BAA4B,IAAItX,KAAK,CAACwB,MAAM,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAC7D,IAAImW,KAAK,GAAGN,GAAG,EAAE;MAChB;MACA;MACA,IAAIO,QAAQ;MACZ;MACA;MACA,OACC,CAACA,QAAQ,GACRJ,UAAU,GACVxX,KAAK,CAACwB,MAAM,IACX8I,gBAAgB,IAAI,CAACgN,4BAA4B,GAAG,CAAC,GAAG,CAAC,CAAC,GAC3DD,GAAG,IAAI,CAAC,EACR;QACD;QACA,MAAMQ,YAAY,GAAGC,IAAI,CAACT,GAAG,CAAC,GAAGE,UAAU,CAAC;QAC5C,IAAIM,YAAY,GAAG7X,KAAK,CAACwB,MAAM,EAAE;UAChC8I,gBAAgB,GAAGtK,KAAK,CAACwB,MAAM;UAC/BxB,KAAK,CAACwB,MAAM,GAAG,CAAC;UAChB;QACD;QACA,KAAK,IAAInB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoO,MAAM,CAACjN,MAAM,EAAEnB,CAAC,EAAE,EAAE;UACvC,IAAIkX,UAAU,CAAClX,CAAC,CAAC,KAAKwX,YAAY,EAAE;YACnC,MAAMhS,KAAK,GAAG4I,MAAM,CAACpO,CAAC,CAAC;YACvB;YACA;YACA;YACA,MAAM0X,UAAU,GAAGlS,KAAK,CAACyE,gBAAgB,GAAG,CAAC,GAAG,CAAC;YACjD,MAAMJ,OAAO,GAAGC,YAAY,CAC3B,0BAA4BtE,KAAK,CAACnE,QAAQ,EAC1CmW,YAAY;YACX;YACAC,IAAI,CAACE,IAAI,CAACJ,QAAQ,GAAGnJ,MAAM,CAACjN,MAAM,CAAC;YACnC;YACAuW,UAAU,EACXA,UAAU,KAAK,CAChB,CAAC;YACDtJ,MAAM,CAACpO,CAAC,CAAC,GAAG;cACX,GAAGwF,KAAK;cACRnE,QAAQ,EAAEwI,OAAO,CAACxI,QAAQ;cAC1B4I,gBAAgB,EAAEJ,OAAO,CAACI,gBAAgB,GACvC,CAACzE,KAAK,CAACyE,gBAAgB,IAAI,CAAC,IAAIJ,OAAO,CAACI,gBAAgB,GACxDzE,KAAK,CAACyE;YACV,CAAC;YACD,MAAM2N,OAAO,GAAGlB,WAAW,CAACtI,MAAM,CAACpO,CAAC,CAAC,CAAC;YACtCmX,UAAU,IAAIK,YAAY,GAAGI,OAAO;YACpCV,UAAU,CAAClX,CAAC,CAAC,GAAG4X,OAAO;YACvB;UACD;QACD;MACD;MACAvW,QAAQ,GAAG+M,MAAM,CAACiJ,MAAM,CAAC1X,KAAK,CAAC;IAChC,CAAC,MAAM,IAAI2X,KAAK,KAAKN,GAAG,EAAE;MACzB;MACA;MACA3V,QAAQ,GAAGwV,QAAQ,CAACzI,MAAM,CAAC;MAC3BnE,gBAAgB,GAAGtK,KAAK,CAACwB,MAAM;IAChC,CAAC,MAAM;MACN;MACA;MACA8I,gBAAgB,GAAG2M,aAAa,CAACG,cAAc,CAAC;IACjD;EACD;EAEA,OAAO,0BAA4B;IAAE1V,QAAQ;IAAE4I;EAAiB,CAAC;AAClE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMyB,gBAAgB,GAAGA,CAAC/G,MAAM,EAAEqS,GAAG,KAAK;EACzC,IAAI/L,QAAQ,GAAG,CAAC;EAChB;EACA;EACA,IAAItG,MAAM,CAACxD,MAAM,GAAG,CAAC,IAAI6V,GAAG,EAC3B,OAAO,CACNrS,MAAM,CAACH,GAAG,CAAC7C,KAAK,IAAI;IACnB,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,CAACA,KAAK,CAACsC,OAAO,EAAE,OAAOtC,KAAK;IAC7DsJ,QAAQ,EAAE;IACV,OAAO;MAAE,GAAGtJ,KAAK;MAAEsC,OAAO,EAAE;IAAG,CAAC;EACjC,CAAC,CAAC,EACFgH,QAAQ,CACR;EACF,IAAI4M,UAAU,GAAGlT,MAAM,CAACxD,MAAM;EAC9B,IAAI2W,MAAM,GAAGnT,MAAM;EAEnB,IAAI3E,CAAC,GAAG,CAAC;EACT,OAAOA,CAAC,GAAG2E,MAAM,CAACxD,MAAM,EAAEnB,CAAC,EAAE,EAAE;IAC9B,MAAM2B,KAAK,GAAGgD,MAAM,CAAC3E,CAAC,CAAC;IACvB,IAAI,OAAO2B,KAAK,KAAK,QAAQ,IAAIA,KAAK,CAACsC,OAAO,EAAE;MAC/C,MAAM8T,QAAQ,GAAGpW,KAAK,CAACsC,OAAO,CAAC+T,KAAK,CAAC,IAAI,CAAC;MAC1C,MAAMC,GAAG,GAAGF,QAAQ,CAAC5W,MAAM;MAC3B0W,UAAU,IAAII,GAAG;MACjB,IAAIJ,UAAU,GAAGb,GAAG,EAAE;QACrBc,MAAM,GAAG9X,CAAC,GAAG,CAAC,GAAG2E,MAAM,CAACqC,KAAK,CAAC,CAAC,EAAEhH,CAAC,CAAC,GAAG,EAAE;QACxC,MAAMkY,SAAS,GAAGL,UAAU,GAAGb,GAAG,GAAG,CAAC;QACtC,MAAMrV,KAAK,GAAGgD,MAAM,CAAC3E,CAAC,EAAE,CAAC;QACzB8X,MAAM,CAAClU,IAAI,CAAC;UACX,GAAGjC,KAAK;UACRsC,OAAO,EAAEtC,KAAK,CAACsC,OAAO,CAAC+T,KAAK,CAAC,IAAI,CAAC,CAAChR,KAAK,CAAC,CAAC,EAAE,CAACkR,SAAS,CAAC,CAAC9L,IAAI,CAAC,IAAI,CAAC;UAClE+L,eAAe,EAAED;QAClB,CAAC,CAAC;QACFjN,QAAQ,GAAGtG,MAAM,CAACxD,MAAM,GAAGnB,CAAC;QAC5B,OAAOA,CAAC,GAAG2E,MAAM,CAACxD,MAAM,EAAEnB,CAAC,EAAE,EAAE;UAC9B,MAAM2B,KAAK,GAAGgD,MAAM,CAAC3E,CAAC,CAAC;UACvB,IAAI,OAAO2B,KAAK,KAAK,QAAQ,IAAI,CAACA,KAAK,CAACsC,OAAO,EAAE6T,MAAM,CAAClU,IAAI,CAACjC,KAAK,CAAC;UACnEmW,MAAM,CAAClU,IAAI,CAAC;YAAE,GAAGjC,KAAK;YAAEsC,OAAO,EAAE;UAAG,CAAC,CAAC;QACvC;QACA;MACD,CAAC,MAAM,IAAI4T,UAAU,KAAKb,GAAG,EAAE;QAC9Bc,MAAM,GAAGnT,MAAM,CAACqC,KAAK,CAAC,CAAC,EAAE,EAAEhH,CAAC,CAAC;QAC7BiL,QAAQ,GAAGtG,MAAM,CAACxD,MAAM,GAAGnB,CAAC;QAC5B,OAAOA,CAAC,GAAG2E,MAAM,CAACxD,MAAM,EAAEnB,CAAC,EAAE,EAAE;UAC9B,MAAM2B,KAAK,GAAGgD,MAAM,CAAC3E,CAAC,CAAC;UACvB,IAAI,OAAO2B,KAAK,KAAK,QAAQ,IAAI,CAACA,KAAK,CAACsC,OAAO,EAAE6T,MAAM,CAAClU,IAAI,CAACjC,KAAK,CAAC;UACnEmW,MAAM,CAAClU,IAAI,CAAC;YAAE,GAAGjC,KAAK;YAAEsC,OAAO,EAAE;UAAG,CAAC,CAAC;QACvC;QACA;MACD;IACD;EACD;EAEA,OAAO,CAAC6T,MAAM,EAAE7M,QAAQ,CAAC;AAC1B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMmN,UAAU,GAAGA,CAAC/W,QAAQ,EAAEgH,MAAM,KAAK;EACxC,IAAIwC,IAAI,GAAG,CAAC;EACZ,KAAK,MAAM/B,KAAK,IAAIzH,QAAQ,EAAE;IAC7BwJ,IAAI,IAAI/B,KAAK,CAAC+B,IAAI;EACnB;EACA,OAAO;IAAEA;EAAK,CAAC;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMwN,WAAW,GAAGA,CAAChX,QAAQ,EAAE6I,OAAO,KAAK;EAC1C,IAAIW,IAAI,GAAG,CAAC;EACZ;EACA,MAAMgE,KAAK,GAAG,CAAC,CAAC;EAChB,KAAK,MAAMtM,MAAM,IAAIlB,QAAQ,EAAE;IAC9BwJ,IAAI,IAAItI,MAAM,CAACsI,IAAI;IACnB,KAAK,MAAMhK,GAAG,IAAIF,MAAM,CAACG,IAAI,CAACyB,MAAM,CAACsM,KAAK,CAAC,EAAE;MAC5CA,KAAK,CAAChO,GAAG,CAAC,GAAG,CAACgO,KAAK,CAAChO,GAAG,CAAC,IAAI,CAAC,IAAI0B,MAAM,CAACsM,KAAK,CAAChO,GAAG,CAAC;IACnD;EACD;EACA,OAAO;IACNgK,IAAI;IACJgE;EACD,CAAC;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMyJ,WAAW,GAAGA,CAACjX,QAAQ,EAAEwP,OAAO,KAAK;EAC1C,IAAIuC,MAAM,GAAG,KAAK;EAClB,KAAK,MAAMR,MAAM,IAAIvR,QAAQ,EAAE;IAC9B+R,MAAM,GAAGA,MAAM,IAAIR,MAAM,CAACQ,MAAM;EACjC;EACA,OAAO;IACNA;EACD,CAAC;AACF,CAAC;AAED,MAAMmF,sBAAsB,GAAG,yCAAyC;AACxE,MAAMC,iBAAiB,GAAG,gDAAgD;;AAE1E;;AAEA;AACA,MAAMC,eAAe,GAAG;EACvBhX,CAAC,EAAEA,CAACiX,YAAY,EAAE9W,OAAO,EAAEwB,OAAO,KAAK;IACtC;AACF;AACA;AACA;IACE,MAAMuV,WAAW,GAAGA,CAAC1W,IAAI,EAAE2W,OAAO,KAAK;MACtCF,YAAY,CAAC9U,IAAI,CAAC;QACjBiV,OAAO,EAAE/P,KAAK,IAAKA,KAAK,CAAC7G,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAGkF,SAAU;QACnD2R,UAAU,EAAEA,CAAA,MAAO;UAClBC,aAAa,EAAE,CAACH,OAAO;UACvBI,KAAK,EAAEJ;QACR,CAAC,CAAC;QACFK,WAAW,EAAEA,CAACpY,GAAG,EAAEQ,QAAQ,EAAEgH,MAAM,KAClCuQ,OAAO,GACJ;UACArX,IAAI,EAAE,kBAAkB;UACxB,CAACU,IAAI,GAAGmJ,OAAO,CAACvK,GAAG,CAAC;UACpBoJ,gBAAgB,EAAE5B,MAAM,CAAClH,MAAM;UAC/B,GAAGiX,UAAU,CAAC/W,QAAQ,EAAEgH,MAAM;QAC/B,CAAC,GACA;UACA9G,IAAI,EAAE,kBAAkB;UACxB,CAACU,IAAI,GAAGmJ,OAAO,CAACvK,GAAG,CAAC;UACpBQ,QAAQ;UACR,GAAG+W,UAAU,CAAC/W,QAAQ,EAAEgH,MAAM;QAC/B;MACJ,CAAC,CAAC;IACH,CAAC;IACD,MAAM;MACL6Q,uBAAuB;MACvBC,iBAAiB;MACjBC;IACD,CAAC,GAAGhW,OAAO;IACX,IAAI8V,uBAAuB,EAAE;MAC5BP,WAAW,CAAC,SAAS,CAAC;MACtBA,WAAW,CAAC,iBAAiB,CAAC;MAC9BA,WAAW,CAAC,iBAAiB,CAAC;IAC/B;IACA,IAAIO,uBAAuB,IAAI,CAAC9V,OAAO,CAACuJ,YAAY,EAAE;MACrDgM,WAAW,CAAC,QAAQ,EAAE,CAACvV,OAAO,CAACuJ,YAAY,CAAC;IAC7C;IACA,IAAIwM,iBAAiB,IAAIC,sBAAsB,EAAE;MAChDV,YAAY,CAAC9U,IAAI,CAAC;QACjBiV,OAAO,EAAE/P,KAAK,IAAI;UACjB,MAAMuQ,cAAc,GACnBD,sBAAsB,IAAIb,sBAAsB,CAACe,IAAI,CAACxQ,KAAK,CAAC7G,IAAI,CAAC;UAClE,MAAMsX,SAAS,GAAGF,cAAc,GAAGA,cAAc,CAAC,CAAC,CAAC,GAAG,EAAE;UACzD,MAAMG,SAAS,GACdL,iBAAiB,IAAIX,iBAAiB,CAACc,IAAI,CAACxQ,KAAK,CAAC7G,IAAI,CAAC;UACxD,MAAMmG,IAAI,GAAGoR,SAAS,GAAGA,SAAS,CAAC,CAAC,CAAC,CAACxB,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE;UACzD,MAAMlX,IAAI,GAAG,EAAE;UACf,IAAIqY,iBAAiB,EAAE;YACtBrY,IAAI,CAAC8C,IAAI,CAAC,GAAG,CAAC;YACd,IAAI2V,SAAS,EACZzY,IAAI,CAAC8C,IAAI,CACRwE,IAAI,CAACjH,MAAM,GACR,GAAGiH,IAAI,CAACgE,IAAI,CAAC,GAAG,CAAC,KAAKmN,SAAS,EAAE,GACjC,IAAIA,SAAS,EACjB,CAAC;YACF,OAAOnR,IAAI,CAACjH,MAAM,GAAG,CAAC,EAAE;cACvBL,IAAI,CAAC8C,IAAI,CAAC,GAAGwE,IAAI,CAACgE,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;cAC/BhE,IAAI,CAAC1B,GAAG,CAAC,CAAC;YACX;UACD,CAAC,MAAM,IAAI6S,SAAS,EAAE;YACrBzY,IAAI,CAAC8C,IAAI,CAAC,IAAI2V,SAAS,EAAE,CAAC;UAC3B;UACA,OAAOzY,IAAI;QACZ,CAAC;QACDmY,WAAW,EAAEA,CAACpY,GAAG,EAAEQ,QAAQ,EAAEgH,MAAM,MAAM;UACxC9G,IAAI,EAAE4X,iBAAiB,GAAG,gBAAgB,GAAG,qBAAqB;UAClElX,IAAI,EAAEpB,GAAG;UACTQ,QAAQ;UACR,GAAG+W,UAAU,CAAC/W,QAAQ,EAAEgH,MAAM;QAC/B,CAAC;MACF,CAAC,CAAC;IACH;EACD,CAAC;EACDoR,iBAAiB,EAAEA,CAACf,YAAY,EAAE9W,OAAO,EAAEwB,OAAO,KAAK;IACtD;AACF;AACA;IACE,MAAMsW,oBAAoB,GAAGzX,IAAI,IAAI;MACpCyW,YAAY,CAAC9U,IAAI,CAAC;QACjBiV,OAAO,EAAE/P,KAAK,IAAKA,KAAK,CAACxD,IAAI,IAAIwD,KAAK,CAACxD,IAAI,CAACrD,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAGkF,SAAU;QACtE8R,WAAW,EAAEA,CAACpY,GAAG,EAAEQ,QAAQ,EAAEgH,MAAM,MAAM;UACxC9G,IAAI,EAAE,gBAAgB;UACtB+D,IAAI,EAAE;YACL,CAACrD,IAAI,GAAGmJ,OAAO,CAACvK,GAAG;UACpB,CAAC;UACDQ,QAAQ;UACR,GAAG+W,UAAU,CAAC/W,QAAQ,EAAEgH,MAAM;QAC/B,CAAC;MACF,CAAC,CAAC;IACH,CAAC;IACDqR,oBAAoB,CAAC,WAAW,CAAC;IACjCA,oBAAoB,CAAC,aAAa,CAAC;IACnCA,oBAAoB,CAAC,sBAAsB,CAAC;EAC7C,CAAC;EACDC,kBAAkB,EAAEA,CAACjB,YAAY,EAAE9W,OAAO,EAAEwB,OAAO,KAAK;IACvD;AACF;AACA;IACE,MAAMwW,YAAY,GAAG3X,IAAI,IAAI;MAC5ByW,YAAY,CAAC9U,IAAI,CAAC;QACjBiV,OAAO,EAAE/P,KAAK,KAAI,uBAAyBA,KAAK,CAAC7G,IAAI,CAAC,CAAC;QACvDgX,WAAW,EAAEA,CAACpY,GAAG,EAAEQ,QAAQ,EAAEgH,MAAM,MAAM;UACxC9G,IAAI,EAAE,iBAAiB;UACvB,CAACU,IAAI,GAAG,CAACpB,GAAG,CAAC;UACbQ,QAAQ;UACR,GAAG+W,UAAU,CAAC/W,QAAQ,EAAEgH,MAAM;QAC/B,CAAC;MACF,CAAC,CAAC;IACH,CAAC;IACDuR,YAAY,CAAC,YAAY,CAAC;IAC1BA,YAAY,CAAC,qBAAqB,CAAC;IACnCA,YAAY,CAAC,cAAc,CAAC;IAC5BA,YAAY,CAAC,uBAAuB,CAAC;EACtC,CAAC;EACDC,aAAa,EAAEA,CAACnB,YAAY,EAAE9W,OAAO,EAAE;IAAEiY;EAAc,CAAC,KAAK;IAC5DnB,YAAY,CAAC9U,IAAI,CAAC;MACjBiV,OAAO,EAAE/P,KAAK,IAAI;QACjB,MAAMgR,KAAK,GAAGhR,KAAK,CAAC7G,IAAI;QACxB,MAAM8X,QAAQ,GAAGF,aAAa,CAACzT,IAAI,CAAC3F,EAAE,IAAIA,EAAE,CAACqZ,KAAK,EAAEhR,KAAK,CAAC,CAAC;QAC3D,IAAIiR,QAAQ,EAAE,OAAO,CAAC,UAAU,CAAC;MAClC,CAAC;MACDjB,UAAU,EAAEA,CAAA,MAAO;QAClBC,aAAa,EAAE,KAAK;QACpBC,KAAK,EAAE;MACR,CAAC,CAAC;MACFC,WAAW,EAAEA,CAACpY,GAAG,EAAEQ,QAAQ,EAAEgH,MAAM,MAAM;QACxC9G,IAAI,EAAE,eAAe;QACrB0I,gBAAgB,EAAE5B,MAAM,CAAClH,MAAM;QAC/B,GAAGiX,UAAU,CAAC/W,QAAQ,EAAEgH,MAAM;MAC/B,CAAC;IACF,CAAC,CAAC;EACH;AACD,CAAC;;AAED;;AAEA;AACA,MAAM2R,gBAAgB,GAAGzY,IAAI,KAAK;EACjCE,CAAC,EAAEA,CAACiX,YAAY,EAAE9W,OAAO,EAAEwB,OAAO,KAAK;IACtC;AACF;AACA;AACA;AACA;IACE,MAAMuV,WAAW,GAAGA,CAAC1W,IAAI,EAAEV,IAAI,EAAEqX,OAAO,KAAK;MAC5CF,YAAY,CAAC9U,IAAI,CAAC;QACjBiV,OAAO,EAAEtW,MAAM,IAAKA,MAAM,CAACN,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAGkF,SAAU;QACrD2R,UAAU,EAAEA,CAAA,MAAO;UAClBC,aAAa,EAAE,CAACH,OAAO;UACvBI,KAAK,EAAEJ;QACR,CAAC,CAAC;QACFK,WAAW,EAAEA,CAACpY,GAAG,EAAEQ,QAAQ,EAAE6I,OAAO,MAAM;UACzC3I,IAAI;UACJ,CAACU,IAAI,GAAGmJ,OAAO,CAACvK,GAAG,CAAC;UACpB,IAAI+X,OAAO,GAAG;YAAE3O,gBAAgB,EAAEC,OAAO,CAAC/I;UAAO,CAAC,GAAG;YAAEE;UAAS,CAAC,CAAC;UAClE,GAAGgX,WAAW,CAAChX,QAAQ,EAAE6I,OAAO;QACjC,CAAC;MACF,CAAC,CAAC;IACH,CAAC;IACD,MAAM;MACL+P,yBAAyB;MACzBC,mBAAmB;MACnBC,wBAAwB;MACxBC,kBAAkB;MAClBC,kBAAkB;MAClBC;IACD,CAAC,GAAGlX,OAAO;IACX,IAAI+W,wBAAwB,EAAE;MAC7BxB,WAAW,CAAC,QAAQ,EAAE,qBAAqB,CAAC;MAC5CA,WAAW,CAAC,UAAU,EAAE,uBAAuB,CAAC;MAChDA,WAAW,CAAC,QAAQ,EAAE,qBAAqB,CAAC;MAC5CA,WAAW,CAAC,UAAU,EAAE,kBAAkB,CAAC;IAC5C;IACA,IAAIsB,yBAAyB,EAAE;MAC9BtB,WAAW,CAAC,WAAW,EAAE,mBAAmB,CAAC;MAC7CA,WAAW,CAAC,OAAO,EAAE,eAAe,CAAC;MACrCA,WAAW,CAAC,eAAe,EAAE,wBAAwB,CAAC;IACvD;IACA,IAAIsB,yBAAyB,IAAI,CAAC7W,OAAO,CAAC+L,aAAa,EAAE;MACxDwJ,WAAW,CAAC,QAAQ,EAAE,gBAAgB,EAAE,CAACvV,OAAO,CAAC+L,aAAa,CAAC;IAChE;IACA,IAAIgL,wBAAwB,IAAI,CAAC/W,OAAO,CAACmX,aAAa,EAAE;MACvD5B,WAAW,CAAC,QAAQ,EAAE,gBAAgB,EAAE,CAACvV,OAAO,CAACmX,aAAa,CAAC;IAChE;IACA,IAAIJ,wBAAwB,IAAI,CAAC/W,OAAO,CAACoX,gBAAgB,EAAE;MAC1D7B,WAAW,CAAC,WAAW,EAAE,mBAAmB,EAAE,CAACvV,OAAO,CAACoX,gBAAgB,CAAC;IACzE;IACA,IAAIJ,kBAAkB,IAAI,CAAChX,OAAO,CAACqX,cAAc,EAAE;MAClD/B,YAAY,CAAC9U,IAAI,CAAC;QACjBiV,OAAO,EAAEtW,MAAM,IAAI;UAClB,IAAI,CAACA,MAAM,CAAC0M,UAAU,EAAE;UACxB,IAAImL,kBAAkB,EAAE;YACvB,OAAO,CAAC7X,MAAM,CAAC0M,UAAU,CAAC+I,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;UAC5C,CAAC,MAAM,IAAIzV,MAAM,CAAC0M,UAAU,KAAKvQ,2BAA2B,EAAE;YAC7D,OAAO,CAACA,2BAA2B,CAAC;UACrC;QACD,CAAC;QACDoa,UAAU,EAAEjY,GAAG,IAAI;UAClB,MAAM+X,OAAO,GACZ/X,GAAG,KAAKnC,2BAA2B,IAAI,CAAC0E,OAAO,CAACqX,cAAc;UAC/D,OAAO;YACN1B,aAAa,EAAE,CAACH,OAAO;YACvBI,KAAK,EAAEJ;UACR,CAAC;QACF,CAAC;QACDK,WAAW,EAAEA,CAACpY,GAAG,EAAEQ,QAAQ,EAAE6I,OAAO,KAAK;UACxC,MAAM0O,OAAO,GACZ/X,GAAG,KAAKnC,2BAA2B,IAAI,CAAC0E,OAAO,CAACqX,cAAc;UAC/D,OAAO;YACNlZ,IAAI,EAAE,GAAGV,GAAG,UAAU;YACtBoO,UAAU,EAAEpO,GAAG;YACf,IAAI+X,OAAO,GAAG;cAAE3O,gBAAgB,EAAEC,OAAO,CAAC/I;YAAO,CAAC,GAAG;cAAEE;YAAS,CAAC,CAAC;YAClE,GAAGgX,WAAW,CAAChX,QAAQ,EAAE6I,OAAO;UACjC,CAAC;QACF;MACD,CAAC,CAAC;IACH;IACA,IAAIgQ,mBAAmB,EAAE;MACxBxB,YAAY,CAAC9U,IAAI,CAAC;QACjBiV,OAAO,EAAEtW,MAAM,KAAI,uBAAyB,CAACA,MAAM,CAAC2M,KAAK,CAAC,CAAC;QAC3D+J,WAAW,EAAEA,CAACpY,GAAG,EAAEQ,QAAQ,EAAE6I,OAAO,MAAM;UACzC3I,IAAI,EAAE,kBAAkB;UACxB2N,KAAK,EAAErO,GAAG;UACVQ,QAAQ;UACR,GAAGgX,WAAW,CAAChX,QAAQ,EAAE6I,OAAO;QACjC,CAAC;MACF,CAAC,CAAC;IACH;IACA,IAAImQ,kBAAkB,IAAIC,uBAAuB,EAAE;MAClD5B,YAAY,CAAC9U,IAAI,CAAC;QACjBiV,OAAO,EAAEtW,MAAM,IAAI;UAClB,IAAI,CAACA,MAAM,CAACN,IAAI,EAAE;UAClB,MAAMyY,QAAQ,GAAGjb,aAAa,CAC7B,qBAAuB8C,MAAM,CAACN,IAAI,CAAC+V,KAAK,CAAC,GAAG,CAAC,CAACtR,GAAG,CAAC,CACnD,CAAC,CAAC0B,IAAI;UACN,MAAMuS,OAAO,GAAG,cAAc,CAACrB,IAAI,CAACoB,QAAQ,CAAC;UAC7C,IAAIC,OAAO,EAAE,OAAO,CAACA,OAAO,CAAC,CAAC,CAAC,CAAC;UAChC,MAAMtB,cAAc,GACnBiB,uBAAuB,IAAI/B,sBAAsB,CAACe,IAAI,CAACoB,QAAQ,CAAC;UACjE,MAAMnB,SAAS,GAAGF,cAAc,GAAGA,cAAc,CAAC,CAAC,CAAC,GAAG,EAAE;UACzD,MAAMG,SAAS,GACda,kBAAkB,IAAI7B,iBAAiB,CAACc,IAAI,CAACoB,QAAQ,CAAC;UACvD,MAAMtS,IAAI,GAAGoR,SAAS,GAAGA,SAAS,CAAC,CAAC,CAAC,CAACxB,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE;UACzD,MAAMlX,IAAI,GAAG,EAAE;UACf,IAAIuZ,kBAAkB,EAAE;YACvB,IAAId,SAAS,EACZzY,IAAI,CAAC8C,IAAI,CACRwE,IAAI,CAACjH,MAAM,GACR,GAAGiH,IAAI,CAACgE,IAAI,CAAC,GAAG,CAAC,KAAKmN,SAAS,EAAE,GACjC,IAAIA,SAAS,EACjB,CAAC;YACF,OAAOnR,IAAI,CAACjH,MAAM,GAAG,CAAC,EAAE;cACvBL,IAAI,CAAC8C,IAAI,CAAC,GAAGwE,IAAI,CAACgE,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;cAC/BhE,IAAI,CAAC1B,GAAG,CAAC,CAAC;YACX;UACD,CAAC,MAAM,IAAI6S,SAAS,EAAE;YACrBzY,IAAI,CAAC8C,IAAI,CAAC,IAAI2V,SAAS,EAAE,CAAC;UAC3B;UACA,OAAOzY,IAAI;QACZ,CAAC;QACDmY,WAAW,EAAEA,CAACpY,GAAG,EAAEQ,QAAQ,EAAE6I,OAAO,KAAK;UACxC,MAAM0Q,SAAS,GAAG/Z,GAAG,CAACga,UAAU,CAAC,OAAO,CAAC;UACzC,OAAO;YACNtZ,IAAI,EAAEqZ,SAAS,GACZ,sBAAsB,GACtBP,kBAAkB,GACjB,iBAAiB,GACjB,sBAAsB;YAC1BpY,IAAI,EAAE2Y,SAAS,GAAG/Z,GAAG,CAACmG,KAAK,CAAC,oBAAqB,CAAC,CAAC,GAAGnG,GAAG;YACzDQ,QAAQ;YACR,GAAGgX,WAAW,CAAChX,QAAQ,EAAE6I,OAAO;UACjC,CAAC;QACF;MACD,CAAC,CAAC;IACH;EACD,CAAC;EACD4Q,cAAc,EAAEA,CAACpC,YAAY,EAAE9W,OAAO,EAAE;IAAEkZ;EAAe,CAAC,KAAK;IAC9DpC,YAAY,CAAC9U,IAAI,CAAC;MACjBiV,OAAO,EAAEtW,MAAM,IAAI;QAClB,MAAMN,IAAI,GAAGM,MAAM,CAACN,IAAI;QACxB,IAAIA,IAAI,EAAE;UACT,MAAM8X,QAAQ,GAAGe,cAAc,CAAC1U,IAAI,CAAC3F,EAAE,IAAIA,EAAE,CAACwB,IAAI,EAAEM,MAAM,EAAEhB,IAAI,CAAC,CAAC;UAClE,IAAIwY,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC;QAC3B;MACD,CAAC;MACDjB,UAAU,EAAEA,CAAA,MAAO;QAClBC,aAAa,EAAE,KAAK;QACpBC,KAAK,EAAE;MACR,CAAC,CAAC;MACFC,WAAW,EAAEA,CAACpY,GAAG,EAAEQ,QAAQ,EAAE6I,OAAO,MAAM;QACzC3I,IAAI,EAAE,gBAAgB;QACtB0I,gBAAgB,EAAE5I,QAAQ,CAACF,MAAM;QACjC,GAAGkX,WAAW,CAAChX,QAAQ,EAAE6I,OAAO;MACjC,CAAC;IACF,CAAC,CAAC;EACH;AACD,CAAC,CAAC;;AAEF;;AAEA;AACA,MAAM6Q,uBAAuB,GAAG;EAC/BC,oBAAoB,EAAEtC,YAAY,IAAI;IACrCA,YAAY,CAAC9U,IAAI,CAAC;MACjBiV,OAAO,EAAEjG,MAAM,KAAI,uBAAyB,CAACA,MAAM,CAACrQ,MAAM,CAAC,CAAC;MAC5D0W,WAAW,EAAEA,CAACpY,GAAG,EAAEQ,QAAQ,EAAEwP,OAAO,MAAM;QACzCtP,IAAI,EAAE,aAAa;QACnBgB,MAAM,EAAE1B,GAAG;QACXQ,QAAQ;QACR,GAAGiX,WAAW,CAACjX,QAAQ,EAAEwP,OAAO;MACjC,CAAC;IACF,CAAC,CAAC;EACH;AACD,CAAC;;AAED;AACA,MAAMoK,eAAe,GAAG;EACvB,oBAAoB,EAAExC,eAAe;EACrC,eAAe,EAAEA,eAAe;EAChC,qBAAqB,EAAEuB,gBAAgB,CAAC,QAAQ,CAAC;EACjD,eAAe,EAAEA,gBAAgB,CAAC,OAAO,CAAC;EAC1C,mBAAmB,EAAEA,gBAAgB,CAAC,eAAe,CAAC;EACtD,gBAAgB,EAAEA,gBAAgB,CAAC,QAAQ,CAAC;EAC5C,gBAAgB,EAAEe;AACnB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMG,iBAAiB,GAAGC,KAAK,IAAI;EAClC,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;IACrB,OAAOA,KAAK,CAACnU,KAAK,CAAC,CAAC,CAAC;EACtB;EACA,OAAOmU,KAAK;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMC,gBAAgB,GAAGD,KAAK,IAAI;EACjC,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;IACrB,OAAO,KAAK;EACb;EACA,OAAO,IAAI;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAME,WAAW,GAAGF,KAAK,IAAI;EAC5B,IAAI,CAACA,KAAK,EAAE;IACX;AACF;AACA;AACA;AACA;IACE,MAAMG,MAAM,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAK,CAAC;IAC1B,OAAOF,MAAM;EACd;EAEA,MAAMG,QAAQ,GAAGP,iBAAiB,CAACC,KAAK,CAAC;EAEzC,IAAIO,MAAM,GAAGpc,aAAa,CAACiX,CAAC,IAAIA,CAAC,CAACkF,QAAQ,CAAC,EAAErc,UAAU,CAAC;;EAExD;EACA,MAAMuc,aAAa,GAAGP,gBAAgB,CAACD,KAAK,CAAC;EAE7C,IAAI,CAACQ,aAAa,EAAE;IACnB,MAAMC,SAAS,GAAGF,MAAM;IACxBA,MAAM,GAAGA,CAACH,CAAC,EAAEC,CAAC,KAAKI,SAAS,CAACJ,CAAC,EAAED,CAAC,CAAC;EACnC;EAEA,OAAOG,MAAM;AACd,CAAC;;AAED;AACA,MAAMG,aAAa,GAAG;EACrBC,UAAU,EAAEA,CAACxF,WAAW,EAAE1U,OAAO,EAAE;IAAEka;EAAW,CAAC,KAAK;IACrDxF,WAAW,CAAC1S,IAAI,CAACyX,WAAW,CAACS,UAAU,CAAC,CAAC;EAC1C,CAAC;EACDra,CAAC,EAAE6U,WAAW,IAAI;IACjBA,WAAW,CAAC1S,IAAI,CAACtE,aAAa,CAACic,CAAC,IAAIA,CAAC,CAACtZ,IAAI,EAAE7C,UAAU,CAAC,CAAC;EACzD;AACD,CAAC;;AAED;AACA,MAAM2c,cAAc,GAAG;EACtB,oBAAoB,EAAE;IACrBC,UAAU,EAAEA,CAAC1F,WAAW,EAAE1U,OAAO,EAAE;MAAEoa;IAAW,CAAC,KAAK;MACrD1F,WAAW,CAAC1S,IAAI,CAACyX,WAAW,CAACW,UAAU,CAAC,CAAC;IAC1C;EACD,CAAC;EACD,qBAAqB,EAAE;IACtBC,WAAW,EAAEA,CAAC3F,WAAW,EAAE1U,OAAO,EAAE;MAAEqa;IAAY,CAAC,KAAK;MACvD3F,WAAW,CAAC1S,IAAI,CAACyX,WAAW,CAACY,WAAW,CAAC,CAAC;IAC3C;EACD,CAAC;EACD,eAAe,EAAE;IAChBC,gBAAgB,EAAEA,CAAC5F,WAAW,EAAE1U,OAAO,EAAE;MAAEsa;IAAiB,CAAC,KAAK;MACjE5F,WAAW,CAAC1S,IAAI,CAACyX,WAAW,CAACa,gBAAgB,CAAC,CAAC;IAChD;EACD,CAAC;EACD,gBAAgB,EAAE;IACjBC,iBAAiB,EAAEA,CAAC7F,WAAW,EAAE1U,OAAO,EAAE;MAAEua;IAAkB,CAAC,KAAK;MACnE7F,WAAW,CAAC1S,IAAI,CAACyX,WAAW,CAACc,iBAAiB,CAAC,CAAC;IACjD;EACD,CAAC;EACD,oBAAoB,EAAEN,aAAa;EACnC,eAAe,EAAEA;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMO,aAAa,GAAGA,CAACC,MAAM,EAAEjZ,OAAO,EAAE3C,EAAE,KAAK;EAC9C,KAAK,MAAM6b,OAAO,IAAI3b,MAAM,CAACG,IAAI,CAACub,MAAM,CAAC,EAAE;IAC1C,MAAME,SAAS,GAAGF,MAAM,CAACC,OAAO,CAAC;IACjC,KAAK,MAAME,MAAM,IAAI7b,MAAM,CAACG,IAAI,CAACyb,SAAS,CAAC,EAAE;MAC5C,IAAIC,MAAM,KAAK,GAAG,EAAE;QACnB,IAAIA,MAAM,CAAC3B,UAAU,CAAC,GAAG,CAAC,EAAE;UAC3B,IAAIzX,OAAO,CAACoZ,MAAM,CAACxV,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;QAC/B,CAAC,MAAM;UACN,MAAM0D,KAAK,GAAGtH,OAAO,CAACoZ,MAAM,CAAC;UAC7B,IACC9R,KAAK,KAAK,KAAK,IACfA,KAAK,KAAKvD,SAAS,IAClBjH,KAAK,CAACkJ,OAAO,CAACsB,KAAK,CAAC,IAAIA,KAAK,CAACvJ,MAAM,KAAK,CAAE,EAE5C;QACF;MACD;MACAV,EAAE,CAAC6b,OAAO,EAAEC,SAAS,CAACC,MAAM,CAAC,CAAC;IAC/B;EACD;AACD,CAAC;;AAED;AACA,MAAMC,UAAU,GAAG;EAClB,wBAAwB,EAAE,aAAa;EACvC,uBAAuB,EAAE,QAAQ;EACjC,2BAA2B,EAAE,YAAY;EACzC,gCAAgC,EAAE,YAAY;EAC9C,sBAAsB,EAAE,OAAO;EAC/B,wBAAwB,EAAE,SAAS;EACnC,iBAAiB,EAAE,QAAQ;EAC3B,qBAAqB,EAAE,QAAQ;EAC/B,iBAAiB,EAAE,aAAa;EAChC,sBAAsB,EAAE,OAAO;EAC/B,sBAAsB,EAAE,OAAO;EAC/B,iBAAiB,EAAE,OAAO;EAC1B,qBAAqB,EAAE,cAAc;EACrC,kBAAkB,EAAE,cAAc;EAClC,kBAAkB,EAAE,QAAQ;EAC5B,mBAAmB,EAAE,QAAQ;EAC7B,eAAe,EAAE,iBAAiB;EAClC,gCAAgC,EAAE;AACnC,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMC,aAAa,GAAG/c,KAAK,IAAI;EAC9B,MAAMa,GAAG,GAAGG,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EAC/B,KAAK,MAAMb,IAAI,IAAIJ,KAAK,EAAE;IACzBa,GAAG,CAACT,IAAI,CAACkC,IAAI,CAAC,GAAGlC,IAAI;EACtB;EACA,OAAOS,GAAG;AACX,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMmc,MAAM,GAAG;EACd,yBAAyB,EAAED,aAAa;EACxC,8BAA8B,EAAEA;AACjC,CAAC;AAED,MAAME,yBAAyB,CAAC;EAC/B;AACD;AACA;AACA;AACA;EACCC,KAAKA,CAACvY,QAAQ,EAAE;IACfA,QAAQ,CAACwY,KAAK,CAAC9b,WAAW,CAAC+b,GAAG,CAAC,2BAA2B,EAAE/b,WAAW,IAAI;MAC1EA,WAAW,CAAC8b,KAAK,CAACE,YAAY,CAACD,GAAG,CACjC,2BAA2B;MAC3B;AACJ;AACA;AACA;MACI,CAACE,KAAK,EAAE7Z,OAAO,KAAK;QACnBgZ,aAAa,CAAChY,iBAAiB,EAAEhB,OAAO,EAAE,CAACkZ,OAAO,EAAE7b,EAAE,KAAK;UAC1Dwc,KAAK,CAACH,KAAK,CAACI,OAAO,CACjBC,GAAG,CAACb,OAAO,CAAC,CACZS,GAAG,CAAC,2BAA2B,EAAE,CAACvc,GAAG,EAAE4c,IAAI,EAAEC,GAAG,KAChD5c,EAAE,CAACD,GAAG,EAAE4c,IAAI,EAAEC,GAAG,EAAEja,OAAO,EAAE6Z,KAAK,CAClC,CAAC;QACH,CAAC,CAAC;QACFb,aAAa,CAACnG,MAAM,EAAE7S,OAAO,EAAE,CAACkZ,OAAO,EAAE7b,EAAE,KAAK;UAC/Cwc,KAAK,CAACH,KAAK,CAAC3R,MAAM,CAChBgS,GAAG,CAACb,OAAO,CAAC,CACZS,GAAG,CAAC,2BAA2B,EAAE,CAAChd,IAAI,EAAEsd,GAAG,EAAEC,GAAG,EAAEtd,CAAC,KACnDS,EAAE,CAACV,IAAI,EAAEsd,GAAG,EAAEja,OAAO,EAAEka,GAAG,EAAEtd,CAAC,CAC9B,CAAC;QACH,CAAC,CAAC;QACFoc,aAAa,CAACjG,cAAc,EAAE/S,OAAO,EAAE,CAACkZ,OAAO,EAAE7b,EAAE,KAAK;UACvDwc,KAAK,CAACH,KAAK,CAACS,aAAa,CACvBJ,GAAG,CAACb,OAAO,CAAC,CACZS,GAAG,CAAC,2BAA2B,EAAE,CAAChd,IAAI,EAAEsd,GAAG,EAAEC,GAAG,EAAEtd,CAAC,KACnDS,EAAE,CAACV,IAAI,EAAEsd,GAAG,EAAEja,OAAO,EAAEka,GAAG,EAAEtd,CAAC,CAC9B,CAAC;QACH,CAAC,CAAC;QACFoc,aAAa,CAAC5F,OAAO,EAAEpT,OAAO,EAAE,CAACkZ,OAAO,EAAE7b,EAAE,KAAK;UAChDwc,KAAK,CAACH,KAAK,CAACxc,IAAI,CACd6c,GAAG,CAACb,OAAO,CAAC,CACZS,GAAG,CAAC,2BAA2B,EAAE,CAACzG,WAAW,EAAE+G,GAAG,KAClD5c,EAAE,CAAC6V,WAAW,EAAE+G,GAAG,EAAEja,OAAO,CAC7B,CAAC;QACH,CAAC,CAAC;QACFgZ,aAAa,CAACL,cAAc,EAAE3Y,OAAO,EAAE,CAACkZ,OAAO,EAAE7b,EAAE,KAAK;UACvDwc,KAAK,CAACH,KAAK,CAACU,WAAW,CACrBL,GAAG,CAACb,OAAO,CAAC,CACZS,GAAG,CAAC,2BAA2B,EAAE,CAACzG,WAAW,EAAE+G,GAAG,KAClD5c,EAAE,CAAC6V,WAAW,EAAE+G,GAAG,EAAEja,OAAO,CAC7B,CAAC;QACH,CAAC,CAAC;QACFgZ,aAAa,CAACnB,eAAe,EAAE7X,OAAO,EAAE,CAACkZ,OAAO,EAAE7b,EAAE,KAAK;UACxDwc,KAAK,CAACH,KAAK,CAACW,YAAY,CACtBN,GAAG,CAACb,OAAO,CAAC,CACZS,GAAG,CAAC,2BAA2B,EAAE,CAACrE,YAAY,EAAE2E,GAAG,KACnD5c,EAAE,CAACiY,YAAY,EAAE2E,GAAG,EAAEja,OAAO,CAC9B,CAAC;QACH,CAAC,CAAC;QACF,KAAK,MAAMvC,GAAG,IAAIF,MAAM,CAACG,IAAI,CAAC2b,UAAU,CAAC,EAAE;UAC1C,MAAMiB,QAAQ,GAAGjB,UAAU,CAAC5b,GAAG,CAAC;UAChCoc,KAAK,CAACH,KAAK,CAACa,WAAW,CACrBR,GAAG,CAACtc,GAAG,CAAC,CACRkc,GAAG,CAAC,2BAA2B,EAAE,MAAMW,QAAQ,CAAC;QACnD;QACA,KAAK,MAAM7c,GAAG,IAAIF,MAAM,CAACG,IAAI,CAAC6b,MAAM,CAAC,EAAE;UACtC,MAAMiB,MAAM,GAAGjB,MAAM,CAAC9b,GAAG,CAAC;UAC1Boc,KAAK,CAACH,KAAK,CAACe,KAAK,CAACV,GAAG,CAACtc,GAAG,CAAC,CAACkc,GAAG,CAAC,2BAA2B,EAAEa,MAAM,CAAC;QACpE;QACA,IAAIxa,OAAO,CAAC/B,QAAQ,EAAE;UACrB,IAAInB,KAAK,CAACkJ,OAAO,CAAChG,OAAO,CAAC/B,QAAQ,CAAC,EAAE;YACpC4b,KAAK,CAACH,KAAK,CAACgB,cAAc,CACxBX,GAAG,CAAC,oCAAoC,CAAC,CACzCJ,GAAG,CACH,2BAA2B;YAC3B;AACT;AACA;AACA;AACA;YACS,CAACgB,IAAI,EAAE;cAAEC,MAAM,EAAEV;YAAI,CAAC,KAAK;cAC1B,MAAMjc,QAAQ,GACb;cACC+B,OAAO,CAAC/B,QAAS;cACnB,IAAIic,GAAG,GAAGjc,QAAQ,CAACF,MAAM,EAAE;gBAC1B,OAAOH,WAAW,CAACid,kBAAkB,CACpCjd,WAAW,CAACkd,kBAAkB,CAAC7c,QAAQ,CAACic,GAAG,CAAC,CAC7C,CAAC;cACF;YACD,CACD,CAAC;UACH,CAAC,MAAM,IAAIla,OAAO,CAAC/B,QAAQ,KAAK,IAAI,EAAE;YACrC,MAAM8c,YAAY,GAAGnd,WAAW,CAACid,kBAAkB,CAClDjd,WAAW,CAACkd,kBAAkB,CAAC9a,OAAO,CAAC/B,QAAQ,CAChD,CAAC;YACD4b,KAAK,CAACH,KAAK,CAACgB,cAAc,CACxBX,GAAG,CAAC,oCAAoC,CAAC,CACzCJ,GAAG,CAAC,2BAA2B,EAAE,MAAMoB,YAAY,CAAC;UACvD;QACD;MACD,CACD,CAAC;IACF,CAAC,CAAC;EACH;AACD;AACA5b,MAAM,CAAC6b,OAAO,GAAGxB,yBAAyB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}