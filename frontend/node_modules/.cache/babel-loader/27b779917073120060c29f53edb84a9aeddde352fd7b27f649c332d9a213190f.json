{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport { CompileError } from \"@webassemblyjs/helper-api-error\";\nimport * as ieee754 from \"@webassemblyjs/ieee754\";\nimport * as utf8 from \"@webassemblyjs/utf8\";\nimport * as t from \"@webassemblyjs/ast\";\nimport { decodeInt32, decodeUInt32, MAX_NUMBER_OF_BYTE_U32, decodeInt64, decodeUInt64, MAX_NUMBER_OF_BYTE_U64 } from \"@webassemblyjs/leb128\";\nimport constants from \"@webassemblyjs/helper-wasm-bytecode\";\nfunction toHex(n) {\n  return \"0x\" + Number(n).toString(16);\n}\nfunction byteArrayEq(l, r) {\n  if (l.length !== r.length) {\n    return false;\n  }\n  for (var i = 0; i < l.length; i++) {\n    if (l[i] !== r[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function decode(ab, opts) {\n  var buf = new Uint8Array(ab);\n  var getUniqueName = t.getUniqueNameGenerator();\n  var offset = 0;\n  function getPosition() {\n    return {\n      line: -1,\n      column: offset\n    };\n  }\n  function dump(b, msg) {\n    if (opts.dump === false) return;\n    var pad = \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\";\n    var str = \"\";\n    if (b.length < 5) {\n      str = b.map(toHex).join(\" \");\n    } else {\n      str = \"...\";\n    }\n    console.log(toHex(offset) + \":\\t\", str, pad, \";\", msg);\n  }\n  function dumpSep(msg) {\n    if (opts.dump === false) return;\n    console.log(\";\", msg);\n  }\n  /**\n   * TODO(sven): we can atually use a same structure\n   * we are adding incrementally new features\n   */\n\n  var state = {\n    elementsInFuncSection: [],\n    elementsInExportSection: [],\n    elementsInCodeSection: [],\n    /**\n     * Decode memory from:\n     * - Memory section\n     */\n    memoriesInModule: [],\n    /**\n     * Decoded types from:\n     * - Type section\n     */\n    typesInModule: [],\n    /**\n     * Decoded functions from:\n     * - Function section\n     * - Import section\n     */\n    functionsInModule: [],\n    /**\n     * Decoded tables from:\n     * - Table section\n     */\n    tablesInModule: [],\n    /**\n     * Decoded globals from:\n     * - Global section\n     */\n    globalsInModule: []\n  };\n  function isEOF() {\n    return offset >= buf.length;\n  }\n  function eatBytes(n) {\n    offset = offset + n;\n  }\n  function readBytesAtOffset(_offset, numberOfBytes) {\n    var arr = [];\n    for (var i = 0; i < numberOfBytes; i++) {\n      arr.push(buf[_offset + i]);\n    }\n    return arr;\n  }\n  function readBytes(numberOfBytes) {\n    return readBytesAtOffset(offset, numberOfBytes);\n  }\n  function readF64() {\n    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F64);\n    var value = ieee754.decodeF64(bytes);\n    if (Math.sign(value) * value === Infinity) {\n      return {\n        value: Math.sign(value),\n        inf: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F64\n      };\n    }\n    if (isNaN(value)) {\n      var sign = bytes[bytes.length - 1] >> 7 ? -1 : 1;\n      var mantissa = 0;\n      for (var i = 0; i < bytes.length - 2; ++i) {\n        mantissa += bytes[i] * Math.pow(256, i);\n      }\n      mantissa += bytes[bytes.length - 2] % 16 * Math.pow(256, bytes.length - 2);\n      return {\n        value: sign * mantissa,\n        nan: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F64\n      };\n    }\n    return {\n      value: value,\n      nextIndex: ieee754.NUMBER_OF_BYTE_F64\n    };\n  }\n  function readF32() {\n    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F32);\n    var value = ieee754.decodeF32(bytes);\n    if (Math.sign(value) * value === Infinity) {\n      return {\n        value: Math.sign(value),\n        inf: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F32\n      };\n    }\n    if (isNaN(value)) {\n      var sign = bytes[bytes.length - 1] >> 7 ? -1 : 1;\n      var mantissa = 0;\n      for (var i = 0; i < bytes.length - 2; ++i) {\n        mantissa += bytes[i] * Math.pow(256, i);\n      }\n      mantissa += bytes[bytes.length - 2] % 128 * Math.pow(256, bytes.length - 2);\n      return {\n        value: sign * mantissa,\n        nan: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F32\n      };\n    }\n    return {\n      value: value,\n      nextIndex: ieee754.NUMBER_OF_BYTE_F32\n    };\n  }\n  function readUTF8String() {\n    var lenu32 = readU32(); // Don't eat any bytes. Instead, peek ahead of the current offset using\n    // readBytesAtOffset below. This keeps readUTF8String neutral with respect\n    // to the current offset, just like the other readX functions.\n\n    var strlen = lenu32.value;\n    dump([strlen], \"string length\");\n    var bytes = readBytesAtOffset(offset + lenu32.nextIndex, strlen);\n    var value = utf8.decode(bytes);\n    return {\n      value: value,\n      nextIndex: strlen + lenu32.nextIndex\n    };\n  }\n  /**\n   * Decode an unsigned 32bits integer\n   *\n   * The length will be handled by the leb librairy, we pass the max number of\n   * byte.\n   */\n\n  function readU32() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U32);\n    var buffer = new Uint8Array(bytes);\n    return decodeUInt32(buffer);\n  }\n  function readVaruint32() {\n    // where 32 bits = max 4 bytes\n    var bytes = readBytes(4);\n    var buffer = new Uint8Array(bytes);\n    return decodeUInt32(buffer);\n  }\n  function readVaruint7() {\n    // where 7 bits = max 1 bytes\n    var bytes = readBytes(1);\n    var buffer = new Uint8Array(bytes);\n    return decodeUInt32(buffer);\n  }\n  /**\n   * Decode a signed 32bits interger\n   */\n\n  function read32() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U32);\n    var buffer = new Uint8Array(bytes);\n    return decodeInt32(buffer);\n  }\n  /**\n   * Decode a signed 64bits integer\n   */\n\n  function read64() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U64);\n    var buffer = new Uint8Array(bytes);\n    return decodeInt64(buffer);\n  }\n  function readU64() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U64);\n    var buffer = new Uint8Array(bytes);\n    return decodeUInt64(buffer);\n  }\n  function readByte() {\n    return readBytes(1)[0];\n  }\n  function parseModuleHeader() {\n    if (isEOF() === true || offset + 4 > buf.length) {\n      throw new Error(\"unexpected end\");\n    }\n    var header = readBytes(4);\n    if (byteArrayEq(constants.magicModuleHeader, header) === false) {\n      throw new CompileError(\"magic header not detected\");\n    }\n    dump(header, \"wasm magic header\");\n    eatBytes(4);\n  }\n  function parseVersion() {\n    if (isEOF() === true || offset + 4 > buf.length) {\n      throw new Error(\"unexpected end\");\n    }\n    var version = readBytes(4);\n    if (byteArrayEq(constants.moduleVersion, version) === false) {\n      throw new CompileError(\"unknown binary version\");\n    }\n    dump(version, \"wasm version\");\n    eatBytes(4);\n  }\n  function parseVec(cast) {\n    var u32 = readU32();\n    var length = u32.value;\n    eatBytes(u32.nextIndex);\n    dump([length], \"number\");\n    if (length === 0) {\n      return [];\n    }\n    var elements = [];\n    for (var i = 0; i < length; i++) {\n      var _byte = readByte();\n      eatBytes(1);\n      var value = cast(_byte);\n      dump([_byte], value);\n      if (typeof value === \"undefined\") {\n        throw new CompileError(\"Internal failure: parseVec could not cast the value\");\n      }\n      elements.push(value);\n    }\n    return elements;\n  } // Type section\n  // https://webassembly.github.io/spec/binary/modules.html#binary-typesec\n\n  function parseTypeSection(numberOfTypes) {\n    var typeInstructionNodes = [];\n    dump([numberOfTypes], \"num types\");\n    for (var i = 0; i < numberOfTypes; i++) {\n      var _startLoc = getPosition();\n      dumpSep(\"type \" + i);\n      var type = readByte();\n      eatBytes(1);\n      if (type == constants.types.func) {\n        dump([type], \"func\");\n        var paramValtypes = parseVec(function (b) {\n          var valtype = constants.valtypes[b];\n          if (valtype === undefined) {\n            throw new Error(\"unexpected value type \".concat(b));\n          }\n          return valtype;\n        });\n        var params = paramValtypes.map(function (v) {\n          return t.funcParam(/*valtype*/\n          v);\n        });\n        var result = parseVec(function (b) {\n          return constants.valtypes[b];\n        });\n        typeInstructionNodes.push(function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.typeInstruction(undefined, t.signature(params, result)), endLoc, _startLoc);\n        }());\n        state.typesInModule.push({\n          params: params,\n          result: result\n        });\n      } else {\n        throw new Error(\"Unsupported type: \" + toHex(type));\n      }\n    }\n    return typeInstructionNodes;\n  } // Import section\n  // https://webassembly.github.io/spec/binary/modules.html#binary-importsec\n\n  function parseImportSection(numberOfImports) {\n    var imports = [];\n    for (var i = 0; i < numberOfImports; i++) {\n      dumpSep(\"import header \" + i);\n      var _startLoc2 = getPosition();\n      /**\n       * Module name\n       */\n\n      var moduleName = readUTF8String();\n      eatBytes(moduleName.nextIndex);\n      dump([], \"module name (\".concat(moduleName.value, \")\"));\n      /**\n       * Name\n       */\n\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      dump([], \"name (\".concat(name.value, \")\"));\n      /**\n       * Import descr\n       */\n\n      var descrTypeByte = readByte();\n      eatBytes(1);\n      var descrType = constants.importTypes[descrTypeByte];\n      dump([descrTypeByte], \"import kind\");\n      if (typeof descrType === \"undefined\") {\n        throw new CompileError(\"Unknown import description type: \" + toHex(descrTypeByte));\n      }\n      var importDescr = void 0;\n      if (descrType === \"func\") {\n        var indexU32 = readU32();\n        var typeindex = indexU32.value;\n        eatBytes(indexU32.nextIndex);\n        dump([typeindex], \"type index\");\n        var signature = state.typesInModule[typeindex];\n        if (typeof signature === \"undefined\") {\n          throw new CompileError(\"function signature not found (\".concat(typeindex, \")\"));\n        }\n        var id = getUniqueName(\"func\");\n        importDescr = t.funcImportDescr(id, t.signature(signature.params, signature.result));\n        state.functionsInModule.push({\n          id: t.identifier(name.value),\n          signature: signature,\n          isExternal: true\n        });\n      } else if (descrType === \"global\") {\n        importDescr = parseGlobalType();\n        var globalNode = t.global(importDescr, []);\n        state.globalsInModule.push(globalNode);\n      } else if (descrType === \"table\") {\n        importDescr = parseTableType(i);\n      } else if (descrType === \"memory\") {\n        var memoryNode = parseMemoryType(0);\n        state.memoriesInModule.push(memoryNode);\n        importDescr = memoryNode;\n      } else {\n        throw new CompileError(\"Unsupported import of type: \" + descrType);\n      }\n      imports.push(function () {\n        var endLoc = getPosition();\n        return t.withLoc(t.moduleImport(moduleName.value, name.value, importDescr), endLoc, _startLoc2);\n      }());\n    }\n    return imports;\n  } // Function section\n  // https://webassembly.github.io/spec/binary/modules.html#function-section\n\n  function parseFuncSection(numberOfFunctions) {\n    dump([numberOfFunctions], \"num funcs\");\n    for (var i = 0; i < numberOfFunctions; i++) {\n      var indexU32 = readU32();\n      var typeindex = indexU32.value;\n      eatBytes(indexU32.nextIndex);\n      dump([typeindex], \"type index\");\n      var signature = state.typesInModule[typeindex];\n      if (typeof signature === \"undefined\") {\n        throw new CompileError(\"function signature not found (\".concat(typeindex, \")\"));\n      } // preserve anonymous, a name might be resolved later\n\n      var id = t.withRaw(t.identifier(getUniqueName(\"func\")), \"\");\n      state.functionsInModule.push({\n        id: id,\n        signature: signature,\n        isExternal: false\n      });\n    }\n  } // Export section\n  // https://webassembly.github.io/spec/binary/modules.html#export-section\n\n  function parseExportSection(numberOfExport) {\n    dump([numberOfExport], \"num exports\"); // Parse vector of exports\n\n    for (var i = 0; i < numberOfExport; i++) {\n      var _startLoc3 = getPosition();\n      /**\n       * Name\n       */\n\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      dump([], \"export name (\".concat(name.value, \")\"));\n      /**\n       * exportdescr\n       */\n\n      var typeIndex = readByte();\n      eatBytes(1);\n      dump([typeIndex], \"export kind\");\n      var indexu32 = readU32();\n      var index = indexu32.value;\n      eatBytes(indexu32.nextIndex);\n      dump([index], \"export index\");\n      var id = void 0,\n        signature = void 0;\n      if (constants.exportTypes[typeIndex] === \"Func\") {\n        var func = state.functionsInModule[index];\n        if (typeof func === \"undefined\") {\n          throw new CompileError(\"unknown function (\".concat(index, \")\"));\n        }\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = func.signature;\n      } else if (constants.exportTypes[typeIndex] === \"Table\") {\n        var table = state.tablesInModule[index];\n        if (typeof table === \"undefined\") {\n          throw new CompileError(\"unknown table \".concat(index));\n        }\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else if (constants.exportTypes[typeIndex] === \"Memory\") {\n        var memNode = state.memoriesInModule[index];\n        if (typeof memNode === \"undefined\") {\n          throw new CompileError(\"unknown memory \".concat(index));\n        }\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else if (constants.exportTypes[typeIndex] === \"Global\") {\n        var global = state.globalsInModule[index];\n        if (typeof global === \"undefined\") {\n          throw new CompileError(\"unknown global \".concat(index));\n        }\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else {\n        console.warn(\"Unsupported export type: \" + toHex(typeIndex));\n        return;\n      }\n      var endLoc = getPosition();\n      state.elementsInExportSection.push({\n        name: name.value,\n        type: constants.exportTypes[typeIndex],\n        signature: signature,\n        id: id,\n        index: index,\n        endLoc: endLoc,\n        startLoc: _startLoc3\n      });\n    }\n  } // Code section\n  // https://webassembly.github.io/spec/binary/modules.html#code-section\n\n  function parseCodeSection(numberOfFuncs) {\n    dump([numberOfFuncs], \"number functions\"); // Parse vector of function\n\n    for (var i = 0; i < numberOfFuncs; i++) {\n      var _startLoc4 = getPosition();\n      dumpSep(\"function body \" + i); // the u32 size of the function code in bytes\n      // Ignore it for now\n\n      var bodySizeU32 = readU32();\n      eatBytes(bodySizeU32.nextIndex);\n      dump([bodySizeU32.value], \"function body size\");\n      var code = []; // Parse locals\n\n      var funcLocalNumU32 = readU32();\n      var funcLocalNum = funcLocalNumU32.value;\n      eatBytes(funcLocalNumU32.nextIndex);\n      dump([funcLocalNum], \"num locals\");\n      var locals = [];\n      for (var _i = 0; _i < funcLocalNum; _i++) {\n        var _startLoc5 = getPosition();\n        var localCountU32 = readU32();\n        var localCount = localCountU32.value;\n        eatBytes(localCountU32.nextIndex);\n        dump([localCount], \"num local\");\n        var valtypeByte = readByte();\n        eatBytes(1);\n        var type = constants.valtypes[valtypeByte];\n        var args = [];\n        for (var _i2 = 0; _i2 < localCount; _i2++) {\n          args.push(t.valtypeLiteral(type));\n        }\n        var localNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.instruction(\"local\", args), endLoc, _startLoc5);\n        }();\n        locals.push(localNode);\n        dump([valtypeByte], type);\n        if (typeof type === \"undefined\") {\n          throw new CompileError(\"Unexpected valtype: \" + toHex(valtypeByte));\n        }\n      }\n      code.push.apply(code, locals); // Decode instructions until the end\n\n      parseInstructionBlock(code);\n      var endLoc = getPosition();\n      state.elementsInCodeSection.push({\n        code: code,\n        locals: locals,\n        endLoc: endLoc,\n        startLoc: _startLoc4,\n        bodySize: bodySizeU32.value\n      });\n    }\n  }\n  function parseInstructionBlock(code) {\n    while (true) {\n      var _startLoc6 = getPosition();\n      var instructionAlreadyCreated = false;\n      var instructionByte = readByte();\n      eatBytes(1);\n      if (instructionByte === 0xfe) {\n        instructionByte = 0xfe00 + readByte();\n        eatBytes(1);\n      } // Table instructions\n      // https://webassembly.github.io/spec/core/binary/instructions.html#table-instructions\n\n      if (instructionByte === 0xfc) {\n        instructionByte = 0xfc00 + readByte();\n        eatBytes(1);\n      }\n      var instruction = constants.symbolsByByte[instructionByte];\n      if (typeof instruction === \"undefined\") {\n        throw new CompileError(\"Unexpected instruction: \" + toHex(instructionByte));\n      }\n      if (instruction === \"illegal\") {\n        throw new Error(\"tried to decode an illegal bytecode: \".concat(toHex(instructionByte)));\n      }\n      if (typeof instruction.object === \"string\") {\n        dump([instructionByte], \"\".concat(instruction.object, \".\").concat(instruction.name));\n      } else {\n        dump([instructionByte], instruction.name);\n      }\n      /**\n       * End of the function\n       */\n\n      if (instruction.name === \"end\") {\n        var node = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.instruction(instruction.name), endLoc, _startLoc6);\n        }();\n        code.push(node);\n        break;\n      }\n      var args = [];\n      var namedArgs = void 0;\n      if (instruction.name === \"loop\") {\n        var _startLoc7 = getPosition();\n        var blocktype = parseBlockType();\n        var instr = [];\n        parseInstructionBlock(instr); // preserve anonymous\n\n        var label = t.withRaw(t.identifier(getUniqueName(\"loop\")), \"\");\n        var loopNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.loopInstruction(label, blocktype, instr), endLoc, _startLoc7);\n        }();\n        code.push(loopNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"if\") {\n        var _startLoc8 = getPosition();\n        var _blocktype = parseBlockType();\n        var testIndex = t.withRaw(t.identifier(getUniqueName(\"if\")), \"\");\n        var ifBody = [];\n        parseInstructionBlock(ifBody); // Defaults to no alternate\n\n        var elseIndex = 0;\n        for (elseIndex = 0; elseIndex < ifBody.length; ++elseIndex) {\n          var _instr = ifBody[elseIndex];\n          if (_instr.type === \"Instr\" && _instr.id === \"else\") {\n            break;\n          }\n        }\n        var consequentInstr = ifBody.slice(0, elseIndex);\n        var alternate = ifBody.slice(elseIndex + 1); // wast sugar\n\n        var testInstrs = [];\n        var ifNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.ifInstruction(testIndex, testInstrs, _blocktype, consequentInstr, alternate), endLoc, _startLoc8);\n        }();\n        code.push(ifNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"block\") {\n        var _startLoc9 = getPosition();\n        var _blocktype2 = parseBlockType();\n        var _instr2 = [];\n        parseInstructionBlock(_instr2); // preserve anonymous\n\n        var _label = t.withRaw(t.identifier(getUniqueName(\"block\")), \"\");\n        var blockNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.blockInstruction(_label, _instr2, _blocktype2), endLoc, _startLoc9);\n        }();\n        code.push(blockNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"call\") {\n        var indexu32 = readU32();\n        var index = indexu32.value;\n        eatBytes(indexu32.nextIndex);\n        dump([index], \"index\");\n        var callNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.callInstruction(t.indexLiteral(index)), endLoc, _startLoc6);\n        }();\n        code.push(callNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"call_indirect\") {\n        var _startLoc10 = getPosition();\n        var indexU32 = readU32();\n        var typeindex = indexU32.value;\n        eatBytes(indexU32.nextIndex);\n        dump([typeindex], \"type index\");\n        var signature = state.typesInModule[typeindex];\n        if (typeof signature === \"undefined\") {\n          throw new CompileError(\"call_indirect signature not found (\".concat(typeindex, \")\"));\n        }\n        var _callNode = t.callIndirectInstruction(t.signature(signature.params, signature.result), []);\n        var flagU32 = readU32();\n        var flag = flagU32.value; // 0x00 - reserved byte\n\n        eatBytes(flagU32.nextIndex);\n        if (flag !== 0) {\n          throw new CompileError(\"zero flag expected\");\n        }\n        code.push(function () {\n          var endLoc = getPosition();\n          return t.withLoc(_callNode, endLoc, _startLoc10);\n        }());\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"br_table\") {\n        var indicesu32 = readU32();\n        var indices = indicesu32.value;\n        eatBytes(indicesu32.nextIndex);\n        dump([indices], \"num indices\");\n        for (var i = 0; i <= indices; i++) {\n          var _indexu = readU32();\n          var _index = _indexu.value;\n          eatBytes(_indexu.nextIndex);\n          dump([_index], \"index\");\n          args.push(t.numberLiteralFromRaw(_indexu.value.toString(), \"u32\"));\n        }\n      } else if (instructionByte >= 0x28 && instructionByte <= 0x40) {\n        /**\n         * Memory instructions\n         */\n        if (instruction.name === \"grow_memory\" || instruction.name === \"current_memory\") {\n          var _indexU = readU32();\n          var _index2 = _indexU.value;\n          eatBytes(_indexU.nextIndex);\n          if (_index2 !== 0) {\n            throw new Error(\"zero flag expected\");\n          }\n          dump([_index2], \"index\");\n        } else {\n          var aligun32 = readU32();\n          var align = aligun32.value;\n          eatBytes(aligun32.nextIndex);\n          dump([align], \"align\");\n          var offsetu32 = readU32();\n          var _offset2 = offsetu32.value;\n          eatBytes(offsetu32.nextIndex);\n          dump([_offset2], \"offset\");\n          if (namedArgs === undefined) namedArgs = {};\n          namedArgs.offset = t.numberLiteralFromRaw(_offset2);\n        }\n      } else if (instructionByte >= 0x41 && instructionByte <= 0x44) {\n        /**\n         * Numeric instructions\n         */\n        if (instruction.object === \"i32\") {\n          var value32 = read32();\n          var value = value32.value;\n          eatBytes(value32.nextIndex);\n          dump([value], \"i32 value\");\n          args.push(t.numberLiteralFromRaw(value));\n        }\n        if (instruction.object === \"u32\") {\n          var valueu32 = readU32();\n          var _value = valueu32.value;\n          eatBytes(valueu32.nextIndex);\n          dump([_value], \"u32 value\");\n          args.push(t.numberLiteralFromRaw(_value));\n        }\n        if (instruction.object === \"i64\") {\n          var value64 = read64();\n          var _value2 = value64.value;\n          eatBytes(value64.nextIndex);\n          dump([Number(_value2.toString())], \"i64 value\");\n          var high = _value2.high,\n            low = _value2.low;\n          var _node = {\n            type: \"LongNumberLiteral\",\n            value: {\n              high: high,\n              low: low\n            }\n          };\n          args.push(_node);\n        }\n        if (instruction.object === \"u64\") {\n          var valueu64 = readU64();\n          var _value3 = valueu64.value;\n          eatBytes(valueu64.nextIndex);\n          dump([Number(_value3.toString())], \"u64 value\");\n          var _high = _value3.high,\n            _low = _value3.low;\n          var _node2 = {\n            type: \"LongNumberLiteral\",\n            value: {\n              high: _high,\n              low: _low\n            }\n          };\n          args.push(_node2);\n        }\n        if (instruction.object === \"f32\") {\n          var valuef32 = readF32();\n          var _value4 = valuef32.value;\n          eatBytes(valuef32.nextIndex);\n          dump([_value4], \"f32 value\");\n          args.push(\n          // $FlowIgnore\n          t.floatLiteral(_value4, valuef32.nan, valuef32.inf, String(_value4)));\n        }\n        if (instruction.object === \"f64\") {\n          var valuef64 = readF64();\n          var _value5 = valuef64.value;\n          eatBytes(valuef64.nextIndex);\n          dump([_value5], \"f64 value\");\n          args.push(\n          // $FlowIgnore\n          t.floatLiteral(_value5, valuef64.nan, valuef64.inf, String(_value5)));\n        }\n      } else if (instructionByte >= 0xfe00 && instructionByte <= 0xfeff) {\n        /**\n         * Atomic memory instructions\n         */\n        var align32 = readU32();\n        var _align = align32.value;\n        eatBytes(align32.nextIndex);\n        dump([_align], \"align\");\n        var _offsetu = readU32();\n        var _offset3 = _offsetu.value;\n        eatBytes(_offsetu.nextIndex);\n        dump([_offset3], \"offset\");\n      } else {\n        for (var _i3 = 0; _i3 < instruction.numberOfArgs; _i3++) {\n          var u32 = readU32();\n          eatBytes(u32.nextIndex);\n          dump([u32.value], \"argument \" + _i3);\n          args.push(t.numberLiteralFromRaw(u32.value));\n        }\n      }\n      if (instructionAlreadyCreated === false) {\n        if (typeof instruction.object === \"string\") {\n          var _node3 = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.objectInstruction(instruction.name, instruction.object, args, namedArgs), endLoc, _startLoc6);\n          }();\n          code.push(_node3);\n        } else {\n          var _node4 = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.instruction(instruction.name, args, namedArgs), endLoc, _startLoc6);\n          }();\n          code.push(_node4);\n        }\n      }\n    }\n  } // https://webassembly.github.io/spec/core/binary/types.html#limits\n\n  function parseLimits() {\n    var limitType = readByte();\n    eatBytes(1);\n    var shared = limitType === 0x03;\n    dump([limitType], \"limit type\" + (shared ? \" (shared)\" : \"\"));\n    var min, max;\n    if (limitType === 0x01 || limitType === 0x03 // shared limits\n    ) {\n      var u32min = readU32();\n      min = parseInt(u32min.value);\n      eatBytes(u32min.nextIndex);\n      dump([min], \"min\");\n      var u32max = readU32();\n      max = parseInt(u32max.value);\n      eatBytes(u32max.nextIndex);\n      dump([max], \"max\");\n    }\n    if (limitType === 0x00) {\n      var _u32min = readU32();\n      min = parseInt(_u32min.value);\n      eatBytes(_u32min.nextIndex);\n      dump([min], \"min\");\n    }\n    return t.limit(min, max, shared);\n  } // https://webassembly.github.io/spec/core/binary/types.html#binary-tabletype\n\n  function parseTableType(index) {\n    var name = t.withRaw(t.identifier(getUniqueName(\"table\")), String(index));\n    var elementTypeByte = readByte();\n    eatBytes(1);\n    dump([elementTypeByte], \"element type\");\n    var elementType = constants.tableTypes[elementTypeByte];\n    if (typeof elementType === \"undefined\") {\n      throw new CompileError(\"Unknown element type in table: \" + toHex(elementTypeByte));\n    }\n    var limits = parseLimits();\n    return t.table(elementType, limits, name);\n  } // https://webassembly.github.io/spec/binary/types.html#global-types\n\n  function parseGlobalType() {\n    var valtypeByte = readByte();\n    eatBytes(1);\n    var type = constants.valtypes[valtypeByte];\n    dump([valtypeByte], type);\n    if (typeof type === \"undefined\") {\n      throw new CompileError(\"Unknown valtype: \" + toHex(valtypeByte));\n    }\n    var globalTypeByte = readByte();\n    eatBytes(1);\n    var globalType = constants.globalTypes[globalTypeByte];\n    dump([globalTypeByte], \"global type (\".concat(globalType, \")\"));\n    if (typeof globalType === \"undefined\") {\n      throw new CompileError(\"Invalid mutability: \" + toHex(globalTypeByte));\n    }\n    return t.globalType(type, globalType);\n  } // function parseNameModule() {\n  //   const lenu32 = readVaruint32();\n  //   eatBytes(lenu32.nextIndex);\n  //   console.log(\"len\", lenu32);\n  //   const strlen = lenu32.value;\n  //   dump([strlen], \"string length\");\n  //   const bytes = readBytes(strlen);\n  //   eatBytes(strlen);\n  //   const value = utf8.decode(bytes);\n  //   return [t.moduleNameMetadata(value)];\n  // }\n  // this section contains an array of function names and indices\n\n  function parseNameSectionFunctions() {\n    var functionNames = [];\n    var numberOfFunctionsu32 = readU32();\n    var numbeOfFunctions = numberOfFunctionsu32.value;\n    eatBytes(numberOfFunctionsu32.nextIndex);\n    for (var i = 0; i < numbeOfFunctions; i++) {\n      var indexu32 = readU32();\n      var index = indexu32.value;\n      eatBytes(indexu32.nextIndex);\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      functionNames.push(t.functionNameMetadata(name.value, index));\n    }\n    return functionNames;\n  }\n  function parseNameSectionLocals() {\n    var localNames = [];\n    var numbeOfFunctionsu32 = readU32();\n    var numbeOfFunctions = numbeOfFunctionsu32.value;\n    eatBytes(numbeOfFunctionsu32.nextIndex);\n    for (var i = 0; i < numbeOfFunctions; i++) {\n      var functionIndexu32 = readU32();\n      var functionIndex = functionIndexu32.value;\n      eatBytes(functionIndexu32.nextIndex);\n      var numLocalsu32 = readU32();\n      var numLocals = numLocalsu32.value;\n      eatBytes(numLocalsu32.nextIndex);\n      for (var _i4 = 0; _i4 < numLocals; _i4++) {\n        var localIndexu32 = readU32();\n        var localIndex = localIndexu32.value;\n        eatBytes(localIndexu32.nextIndex);\n        var name = readUTF8String();\n        eatBytes(name.nextIndex);\n        localNames.push(t.localNameMetadata(name.value, localIndex, functionIndex));\n      }\n    }\n    return localNames;\n  } // this is a custom section used for name resolution\n  // https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#name-section\n\n  function parseNameSection(remainingBytes) {\n    var nameMetadata = [];\n    var initialOffset = offset;\n    while (offset - initialOffset < remainingBytes) {\n      // name_type\n      var sectionTypeByte = readVaruint7();\n      eatBytes(sectionTypeByte.nextIndex); // name_payload_len\n\n      var subSectionSizeInBytesu32 = readVaruint32();\n      eatBytes(subSectionSizeInBytesu32.nextIndex);\n      switch (sectionTypeByte.value) {\n        // case 0: {\n        // TODO(sven): re-enable that\n        // Current status: it seems that when we decode the module's name\n        // no name_payload_len is used.\n        //\n        // See https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#name-section\n        //\n        // nameMetadata.push(...parseNameModule());\n        // break;\n        // }\n        case 1:\n          {\n            nameMetadata.push.apply(nameMetadata, _toConsumableArray(parseNameSectionFunctions()));\n            break;\n          }\n        case 2:\n          {\n            nameMetadata.push.apply(nameMetadata, _toConsumableArray(parseNameSectionLocals()));\n            break;\n          }\n        default:\n          {\n            // skip unknown subsection\n            eatBytes(subSectionSizeInBytesu32.value);\n          }\n      }\n    }\n    return nameMetadata;\n  } // this is a custom section used for information about the producers\n  // https://github.com/WebAssembly/tool-conventions/blob/master/ProducersSection.md\n\n  function parseProducersSection() {\n    var metadata = t.producersSectionMetadata([]); // field_count\n\n    var sectionTypeByte = readVaruint32();\n    eatBytes(sectionTypeByte.nextIndex);\n    dump([sectionTypeByte.value], \"num of producers\");\n    var fields = {\n      language: [],\n      \"processed-by\": [],\n      sdk: []\n    }; // fields\n\n    for (var fieldI = 0; fieldI < sectionTypeByte.value; fieldI++) {\n      // field_name\n      var fieldName = readUTF8String();\n      eatBytes(fieldName.nextIndex); // field_value_count\n\n      var valueCount = readVaruint32();\n      eatBytes(valueCount.nextIndex); // field_values\n\n      for (var producerI = 0; producerI < valueCount.value; producerI++) {\n        var producerName = readUTF8String();\n        eatBytes(producerName.nextIndex);\n        var producerVersion = readUTF8String();\n        eatBytes(producerVersion.nextIndex);\n        fields[fieldName.value].push(t.producerMetadataVersionedName(producerName.value, producerVersion.value));\n      }\n      metadata.producers.push(fields[fieldName.value]);\n    }\n    return metadata;\n  }\n  function parseGlobalSection(numberOfGlobals) {\n    var globals = [];\n    dump([numberOfGlobals], \"num globals\");\n    for (var i = 0; i < numberOfGlobals; i++) {\n      var _startLoc11 = getPosition();\n      var globalType = parseGlobalType();\n      /**\n       * Global expressions\n       */\n\n      var init = [];\n      parseInstructionBlock(init);\n      var node = function () {\n        var endLoc = getPosition();\n        return t.withLoc(t.global(globalType, init), endLoc, _startLoc11);\n      }();\n      globals.push(node);\n      state.globalsInModule.push(node);\n    }\n    return globals;\n  }\n  function parseElemSection(numberOfElements) {\n    var elems = [];\n    dump([numberOfElements], \"num elements\");\n    for (var i = 0; i < numberOfElements; i++) {\n      var _startLoc12 = getPosition();\n      var tableindexu32 = readU32();\n      var bitfield = tableindexu32.value;\n      eatBytes(tableindexu32.nextIndex);\n      dump([bitfield], \"bitfield\");\n      if (bitfield === 0) {\n        // Parse instructions\n        var instr = [];\n        parseInstructionBlock(instr); // Parse ( vector function index ) *\n\n        var indicesu32 = readU32();\n        var indices = indicesu32.value;\n        eatBytes(indicesu32.nextIndex);\n        dump([indices], \"num indices\");\n        var indexValues = [];\n        for (var _i5 = 0; _i5 < indices; _i5++) {\n          var indexu32 = readU32();\n          var index = indexu32.value;\n          eatBytes(indexu32.nextIndex);\n          dump([index], \"index\");\n          indexValues.push(t.indexLiteral(index));\n        }\n        var elemNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.elem(t.indexLiteral(bitfield), instr, indexValues), endLoc, _startLoc12);\n        }();\n        elems.push(elemNode);\n      } else if (bitfield === 1) {\n        var elemKind = readByte();\n        eatBytes(1);\n        if (elemKind !== 0) {\n          throw new Error(\"unexpected Elem kind: \".concat(toHex(elemKind)));\n        } // Parse ( vector function index ) *\n\n        var _indicesu = readU32();\n        var _indices = _indicesu.value;\n        eatBytes(_indicesu.nextIndex);\n        dump([_indices], \"num indices\");\n        var _indexValues = [];\n        for (var _i6 = 0; _i6 < _indices; _i6++) {\n          var _indexu2 = readU32();\n          var _index3 = _indexu2.value;\n          eatBytes(_indexu2.nextIndex);\n          dump([_index3], \"index\");\n          _indexValues.push(t.indexLiteral(_index3));\n        } // TODO: emit a AST node, for now just make it parse.\n      } else if (bitfield === 2) {\n        var u32 = readU32();\n        var tableidx = u32.value;\n        eatBytes(u32.nextIndex);\n        dump([tableidx], \"tableidx\"); // Parse instructions\n\n        var _instr3 = [];\n        parseInstructionBlock(_instr3);\n        var _elemKind = readByte();\n        eatBytes(1);\n        if (_elemKind !== 0) {\n          throw new Error(\"unexpected Elem kind: \".concat(toHex(_elemKind)));\n        } // Parse ( vector function index ) *\n\n        var _indicesu2 = readU32();\n        var _indices2 = _indicesu2.value;\n        eatBytes(_indicesu2.nextIndex);\n        dump([_indices2], \"num indices\");\n        var _indexValues2 = [];\n        for (var _i7 = 0; _i7 < _indices2; _i7++) {\n          var _indexu3 = readU32();\n          var _index4 = _indexu3.value;\n          eatBytes(_indexu3.nextIndex);\n          dump([_index4], \"index\");\n          _indexValues2.push(t.indexLiteral(_index4));\n        }\n        var _elemNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.elem(t.indexLiteral(bitfield), _instr3, _indexValues2), endLoc, _startLoc12);\n        }();\n        elems.push(_elemNode);\n      } else if (bitfield === 3) {\n        var _elemKind2 = readByte();\n        eatBytes(1);\n        if (_elemKind2 !== 0) {\n          throw new Error(\"unexpected Elem kind: \".concat(toHex(_elemKind2)));\n        } // Parse ( vector function index ) *\n\n        var countU32 = readU32();\n        var count = countU32.value;\n        eatBytes(countU32.nextIndex);\n        dump([count], \"count\");\n        for (var _i8 = 0; _i8 < count; _i8++) {\n          var _indexu4 = readU32();\n          var _index5 = _indexu4.value;\n          eatBytes(_indexu4.nextIndex);\n          dump([_index5], \"index\");\n        } // TODO: emit a AST node, for now just make it parse.\n      } else if (bitfield === 4) {\n        var expr = [];\n        parseInstructionBlock(expr);\n        var _countU = readU32();\n        var _count = _countU.value;\n        eatBytes(_countU.nextIndex);\n        dump([_count], \"count\");\n        for (var _i9 = 0; _i9 < _count; _i9++) {\n          var code = [];\n          parseInstructionBlock(code);\n        } // TODO: emit a AST node, for now just make it parse.\n      } else if (bitfield === 5) {\n        var reftype = readByte();\n        eatBytes(1);\n        dump([reftype], \"reftype\");\n        var _countU2 = readU32();\n        var _count2 = _countU2.value;\n        eatBytes(_countU2.nextIndex);\n        dump([_count2], \"count\");\n        for (var _i10 = 0; _i10 < _count2; _i10++) {\n          var _code = [];\n          parseInstructionBlock(_code);\n        } // TODO: emit a AST node, for now just make it parse.\n      } else if (bitfield === 7) {\n        var _reftype = readByte();\n        eatBytes(1);\n        dump([_reftype], \"reftype\");\n        var _countU3 = readU32();\n        var _count3 = _countU3.value;\n        eatBytes(_countU3.nextIndex);\n        dump([_count3], \"count\");\n        for (var _i11 = 0; _i11 < _count3; _i11++) {\n          var _code2 = [];\n          parseInstructionBlock(_code2);\n        } // TODO: emit a AST node, for now just make it parse.\n      } else {\n        throw new Error(\"unexpected Elem with bitfield \".concat(toHex(bitfield)));\n      }\n    }\n    return elems;\n  } // https://webassembly.github.io/spec/core/binary/types.html#memory-types\n\n  function parseMemoryType(i) {\n    var limits = parseLimits();\n    return t.memory(limits, t.indexLiteral(i));\n  } // https://webassembly.github.io/spec/binary/modules.html#table-section\n\n  function parseTableSection(numberOfElements) {\n    var tables = [];\n    dump([numberOfElements], \"num elements\");\n    for (var i = 0; i < numberOfElements; i++) {\n      var tablesNode = parseTableType(i);\n      state.tablesInModule.push(tablesNode);\n      tables.push(tablesNode);\n    }\n    return tables;\n  } // https://webassembly.github.io/spec/binary/modules.html#memory-section\n\n  function parseMemorySection(numberOfElements) {\n    var memories = [];\n    dump([numberOfElements], \"num elements\");\n    for (var i = 0; i < numberOfElements; i++) {\n      var memoryNode = parseMemoryType(i);\n      state.memoriesInModule.push(memoryNode);\n      memories.push(memoryNode);\n    }\n    return memories;\n  } // https://webassembly.github.io/spec/binary/modules.html#binary-startsec\n\n  function parseStartSection() {\n    var startLoc = getPosition();\n    var u32 = readU32();\n    var startFuncIndex = u32.value;\n    eatBytes(u32.nextIndex);\n    dump([startFuncIndex], \"index\");\n    return function () {\n      var endLoc = getPosition();\n      return t.withLoc(t.start(t.indexLiteral(startFuncIndex)), endLoc, startLoc);\n    }();\n  } // https://webassembly.github.io/spec/binary/modules.html#data-section\n\n  function parseDataSection(numberOfElements) {\n    var dataEntries = [];\n    dump([numberOfElements], \"num elements\");\n    for (var i = 0; i < numberOfElements; i++) {\n      var memoryIndexu32 = readU32();\n      var memoryIndex = memoryIndexu32.value;\n      eatBytes(memoryIndexu32.nextIndex);\n      dump([memoryIndex], \"memory index\");\n      var instrs = [];\n      parseInstructionBlock(instrs);\n      var hasExtraInstrs = instrs.filter(function (i) {\n        return i.id !== \"end\";\n      }).length !== 1;\n      if (hasExtraInstrs) {\n        throw new CompileError(\"data section offset must be a single instruction\");\n      }\n      var bytes = parseVec(function (b) {\n        return b;\n      });\n      dump([], \"init\");\n      dataEntries.push(t.data(t.memIndexLiteral(memoryIndex), instrs[0], t.byteArray(bytes)));\n    }\n    return dataEntries;\n  } // https://webassembly.github.io/spec/binary/modules.html#binary-section\n\n  function parseSection(sectionIndex) {\n    var sectionId = readByte();\n    eatBytes(1);\n    if (sectionId >= sectionIndex || sectionIndex === constants.sections.custom) {\n      sectionIndex = sectionId + 1;\n    } else {\n      if (sectionId !== constants.sections.custom) throw new CompileError(\"Unexpected section: \" + toHex(sectionId));\n    }\n    var nextSectionIndex = sectionIndex;\n    var startOffset = offset;\n    var startLoc = getPosition();\n    var u32 = readU32();\n    var sectionSizeInBytes = u32.value;\n    eatBytes(u32.nextIndex);\n    var sectionSizeInBytesNode = function () {\n      var endLoc = getPosition();\n      return t.withLoc(t.numberLiteralFromRaw(sectionSizeInBytes), endLoc, startLoc);\n    }();\n    switch (sectionId) {\n      case constants.sections.type:\n        {\n          dumpSep(\"section Type\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _startLoc13 = getPosition();\n          var _u = readU32();\n          var numberOfTypes = _u.value;\n          eatBytes(_u.nextIndex);\n          var metadata = t.sectionMetadata(\"type\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfTypes), endLoc, _startLoc13);\n          }());\n          var nodes = parseTypeSection(numberOfTypes);\n          return {\n            nodes: nodes,\n            metadata: metadata,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections.table:\n        {\n          dumpSep(\"section Table\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _startLoc14 = getPosition();\n          var _u2 = readU32();\n          var numberOfTable = _u2.value;\n          eatBytes(_u2.nextIndex);\n          dump([numberOfTable], \"num tables\");\n          var _metadata = t.sectionMetadata(\"table\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfTable), endLoc, _startLoc14);\n          }());\n          var _nodes = parseTableSection(numberOfTable);\n          return {\n            nodes: _nodes,\n            metadata: _metadata,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections[\"import\"]:\n        {\n          dumpSep(\"section Import\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _startLoc15 = getPosition();\n          var numberOfImportsu32 = readU32();\n          var numberOfImports = numberOfImportsu32.value;\n          eatBytes(numberOfImportsu32.nextIndex);\n          dump([numberOfImports], \"number of imports\");\n          var _metadata2 = t.sectionMetadata(\"import\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfImports), endLoc, _startLoc15);\n          }());\n          var _nodes2 = parseImportSection(numberOfImports);\n          return {\n            nodes: _nodes2,\n            metadata: _metadata2,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections.func:\n        {\n          dumpSep(\"section Function\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _startLoc16 = getPosition();\n          var numberOfFunctionsu32 = readU32();\n          var numberOfFunctions = numberOfFunctionsu32.value;\n          eatBytes(numberOfFunctionsu32.nextIndex);\n          var _metadata3 = t.sectionMetadata(\"func\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfFunctions), endLoc, _startLoc16);\n          }());\n          parseFuncSection(numberOfFunctions);\n          var _nodes3 = [];\n          return {\n            nodes: _nodes3,\n            metadata: _metadata3,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections[\"export\"]:\n        {\n          dumpSep(\"section Export\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _startLoc17 = getPosition();\n          var _u3 = readU32();\n          var numberOfExport = _u3.value;\n          eatBytes(_u3.nextIndex);\n          var _metadata4 = t.sectionMetadata(\"export\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfExport), endLoc, _startLoc17);\n          }());\n          parseExportSection(numberOfExport);\n          var _nodes4 = [];\n          return {\n            nodes: _nodes4,\n            metadata: _metadata4,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections.code:\n        {\n          dumpSep(\"section Code\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _startLoc18 = getPosition();\n          var _u4 = readU32();\n          var numberOfFuncs = _u4.value;\n          eatBytes(_u4.nextIndex);\n          var _metadata5 = t.sectionMetadata(\"code\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfFuncs), endLoc, _startLoc18);\n          }());\n          if (opts.ignoreCodeSection === true) {\n            var remainingBytes = sectionSizeInBytes - _u4.nextIndex;\n            eatBytes(remainingBytes); // eat the entire section\n          } else {\n            parseCodeSection(numberOfFuncs);\n          }\n          var _nodes5 = [];\n          return {\n            nodes: _nodes5,\n            metadata: _metadata5,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections.start:\n        {\n          dumpSep(\"section Start\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _metadata6 = t.sectionMetadata(\"start\", startOffset, sectionSizeInBytesNode);\n          var _nodes6 = [parseStartSection()];\n          return {\n            nodes: _nodes6,\n            metadata: _metadata6,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections.element:\n        {\n          dumpSep(\"section Element\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _startLoc19 = getPosition();\n          var numberOfElementsu32 = readU32();\n          var numberOfElements = numberOfElementsu32.value;\n          eatBytes(numberOfElementsu32.nextIndex);\n          var _metadata7 = t.sectionMetadata(\"element\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfElements), endLoc, _startLoc19);\n          }());\n          var _nodes7 = parseElemSection(numberOfElements);\n          return {\n            nodes: _nodes7,\n            metadata: _metadata7,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections.global:\n        {\n          dumpSep(\"section Global\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _startLoc20 = getPosition();\n          var numberOfGlobalsu32 = readU32();\n          var numberOfGlobals = numberOfGlobalsu32.value;\n          eatBytes(numberOfGlobalsu32.nextIndex);\n          var _metadata8 = t.sectionMetadata(\"global\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfGlobals), endLoc, _startLoc20);\n          }());\n          var _nodes8 = parseGlobalSection(numberOfGlobals);\n          return {\n            nodes: _nodes8,\n            metadata: _metadata8,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections.memory:\n        {\n          dumpSep(\"section Memory\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _startLoc21 = getPosition();\n          var _numberOfElementsu = readU32();\n          var _numberOfElements = _numberOfElementsu.value;\n          eatBytes(_numberOfElementsu.nextIndex);\n          var _metadata9 = t.sectionMetadata(\"memory\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(_numberOfElements), endLoc, _startLoc21);\n          }());\n          var _nodes9 = parseMemorySection(_numberOfElements);\n          return {\n            nodes: _nodes9,\n            metadata: _metadata9,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n      case constants.sections.data:\n        {\n          dumpSep(\"section Data\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _metadata10 = t.sectionMetadata(\"data\", startOffset, sectionSizeInBytesNode);\n          var _startLoc22 = getPosition();\n          var _numberOfElementsu2 = readU32();\n          var _numberOfElements2 = _numberOfElementsu2.value;\n          eatBytes(_numberOfElementsu2.nextIndex);\n          _metadata10.vectorOfSize = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(_numberOfElements2), endLoc, _startLoc22);\n          }();\n          if (opts.ignoreDataSection === true) {\n            var _remainingBytes = sectionSizeInBytes - _numberOfElementsu2.nextIndex;\n            eatBytes(_remainingBytes); // eat the entire section\n\n            dumpSep(\"ignore data (\" + sectionSizeInBytes + \" bytes)\");\n            return {\n              nodes: [],\n              metadata: _metadata10,\n              nextSectionIndex: nextSectionIndex\n            };\n          } else {\n            var _nodes10 = parseDataSection(_numberOfElements2);\n            return {\n              nodes: _nodes10,\n              metadata: _metadata10,\n              nextSectionIndex: nextSectionIndex\n            };\n          }\n        }\n      case constants.sections.custom:\n        {\n          dumpSep(\"section Custom\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _metadata11 = [t.sectionMetadata(\"custom\", startOffset, sectionSizeInBytesNode)];\n          var sectionName = readUTF8String();\n          eatBytes(sectionName.nextIndex);\n          dump([], \"section name (\".concat(sectionName.value, \")\"));\n          var _remainingBytes2 = sectionSizeInBytes - sectionName.nextIndex;\n          if (sectionName.value === \"name\") {\n            var initialOffset = offset;\n            try {\n              _metadata11.push.apply(_metadata11, _toConsumableArray(parseNameSection(_remainingBytes2)));\n            } catch (e) {\n              console.warn(\"Failed to decode custom \\\"name\\\" section @\".concat(offset, \"; ignoring (\").concat(e.message, \").\"));\n              eatBytes(offset - (initialOffset + _remainingBytes2));\n            }\n          } else if (sectionName.value === \"producers\") {\n            var _initialOffset = offset;\n            try {\n              _metadata11.push(parseProducersSection());\n            } catch (e) {\n              console.warn(\"Failed to decode custom \\\"producers\\\" section @\".concat(offset, \"; ignoring (\").concat(e.message, \").\"));\n              eatBytes(offset - (_initialOffset + _remainingBytes2));\n            }\n          } else {\n            // We don't parse the custom section\n            eatBytes(_remainingBytes2);\n            dumpSep(\"ignore custom \" + JSON.stringify(sectionName.value) + \" section (\" + _remainingBytes2 + \" bytes)\");\n          }\n          return {\n            nodes: [],\n            metadata: _metadata11,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n    }\n    if (opts.errorOnUnknownSection) {\n      throw new CompileError(\"Unexpected section: \" + toHex(sectionId));\n    } else {\n      dumpSep(\"section \" + toHex(sectionId));\n      dump([sectionId], \"section code\");\n      dump([sectionSizeInBytes], \"section size\");\n      eatBytes(sectionSizeInBytes);\n      dumpSep(\"ignoring (\" + sectionSizeInBytes + \" bytes)\");\n      return {\n        nodes: [],\n        metadata: [],\n        nextSectionIndex: 0\n      };\n    }\n  }\n  function parseBlockType() {\n    var blocktypeByte = readByte();\n    var blocktype = constants.blockTypes[blocktypeByte];\n    if (typeof blocktype !== \"undefined\") {\n      eatBytes(1);\n      dump([blocktypeByte], \"blocktype\"); // value type\n\n      return blocktype;\n    } else {\n      // type index\n      var u32 = readU32();\n      eatBytes(u32.nextIndex);\n      var signature = state.typesInModule[u32.value];\n      console.log({\n        signature: signature\n      });\n      dump([u32.value], \"typeidx\");\n      return u32.value;\n    }\n  }\n  parseModuleHeader();\n  parseVersion();\n  var moduleFields = [];\n  var sectionIndex = 0;\n  var moduleMetadata = {\n    sections: [],\n    functionNames: [],\n    localNames: [],\n    producers: []\n  };\n  /**\n   * All the generate declaration are going to be stored in our state\n   */\n\n  while (offset < buf.length) {\n    var _parseSection = parseSection(sectionIndex),\n      nodes = _parseSection.nodes,\n      metadata = _parseSection.metadata,\n      nextSectionIndex = _parseSection.nextSectionIndex;\n    moduleFields.push.apply(moduleFields, _toConsumableArray(nodes));\n    var metadataArray = Array.isArray(metadata) ? metadata : [metadata];\n    metadataArray.forEach(function (metadataItem) {\n      // $FlowIgnore\n      if (metadataItem.type === \"FunctionNameMetadata\") {\n        moduleMetadata.functionNames.push(metadataItem); // $FlowIgnore\n      } else if (metadataItem.type === \"LocalNameMetadata\") {\n        moduleMetadata.localNames.push(metadataItem); // $FlowIgnore\n      } else if (metadataItem.type === \"ProducersSectionMetadata\") {\n        moduleMetadata.producers.push(metadataItem);\n      } else {\n        moduleMetadata.sections.push(metadataItem);\n      }\n    }); // Ignore custom section\n\n    if (nextSectionIndex) {\n      sectionIndex = nextSectionIndex;\n    }\n  }\n  /**\n   * Transform the state into AST nodes\n   */\n\n  var funcIndex = 0;\n  state.functionsInModule.forEach(function (func) {\n    var params = func.signature.params;\n    var result = func.signature.result;\n    var body = []; // External functions doesn't provide any code, can skip it here\n\n    if (func.isExternal === true) {\n      return;\n    }\n    var decodedElementInCodeSection = state.elementsInCodeSection[funcIndex];\n    if (opts.ignoreCodeSection === false) {\n      if (typeof decodedElementInCodeSection === \"undefined\") {\n        throw new CompileError(\"func \" + toHex(funcIndex) + \" code not found\");\n      }\n      body = decodedElementInCodeSection.code;\n    }\n    funcIndex++;\n    var funcNode = t.func(func.id, t.signature(params, result), body);\n    if (func.isExternal === true) {\n      funcNode.isExternal = func.isExternal;\n    } // Add function position in the binary if possible\n\n    if (opts.ignoreCodeSection === false) {\n      var _startLoc23 = decodedElementInCodeSection.startLoc,\n        endLoc = decodedElementInCodeSection.endLoc,\n        bodySize = decodedElementInCodeSection.bodySize;\n      funcNode = t.withLoc(funcNode, endLoc, _startLoc23);\n      funcNode.metadata = {\n        bodySize: bodySize\n      };\n    }\n    moduleFields.push(funcNode);\n  });\n  state.elementsInExportSection.forEach(function (moduleExport) {\n    /**\n     * If the export has no id, we won't be able to call it from the outside\n     * so we can omit it\n     */\n    if (moduleExport.id != null) {\n      moduleFields.push(t.withLoc(t.moduleExport(moduleExport.name, t.moduleExportDescr(moduleExport.type, moduleExport.id)), moduleExport.endLoc, moduleExport.startLoc));\n    }\n  });\n  dumpSep(\"end of program\");\n  var module = t.module(null, moduleFields, t.moduleMetadata(moduleMetadata.sections, moduleMetadata.functionNames, moduleMetadata.localNames, moduleMetadata.producers));\n  return t.program([module]);\n}","map":{"version":3,"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","CompileError","ieee754","utf8","t","decodeInt32","decodeUInt32","MAX_NUMBER_OF_BYTE_U32","decodeInt64","decodeUInt64","MAX_NUMBER_OF_BYTE_U64","constants","toHex","Number","byteArrayEq","l","r","decode","ab","opts","buf","Uint8Array","getUniqueName","getUniqueNameGenerator","offset","getPosition","line","column","dump","b","msg","pad","str","map","join","console","log","dumpSep","state","elementsInFuncSection","elementsInExportSection","elementsInCodeSection","memoriesInModule","typesInModule","functionsInModule","tablesInModule","globalsInModule","isEOF","eatBytes","readBytesAtOffset","_offset","numberOfBytes","push","readBytes","readF64","bytes","NUMBER_OF_BYTE_F64","value","decodeF64","Math","sign","Infinity","inf","nextIndex","isNaN","mantissa","pow","nan","readF32","NUMBER_OF_BYTE_F32","decodeF32","readUTF8String","lenu32","readU32","strlen","buffer","readVaruint32","readVaruint7","read32","read64","readU64","readByte","parseModuleHeader","Error","header","magicModuleHeader","parseVersion","version","moduleVersion","parseVec","cast","u32","elements","_byte","parseTypeSection","numberOfTypes","typeInstructionNodes","_startLoc","type","types","func","paramValtypes","valtype","valtypes","undefined","concat","params","v","funcParam","result","endLoc","withLoc","typeInstruction","signature","parseImportSection","numberOfImports","imports","_startLoc2","moduleName","descrTypeByte","descrType","importTypes","importDescr","indexU32","typeindex","id","funcImportDescr","identifier","isExternal","parseGlobalType","globalNode","global","parseTableType","memoryNode","parseMemoryType","moduleImport","parseFuncSection","numberOfFunctions","withRaw","parseExportSection","numberOfExport","_startLoc3","typeIndex","indexu32","index","exportTypes","numberLiteralFromRaw","String","table","memNode","warn","startLoc","parseCodeSection","numberOfFuncs","_startLoc4","bodySizeU32","code","funcLocalNumU32","funcLocalNum","locals","_i","_startLoc5","localCountU32","localCount","valtypeByte","args","_i2","valtypeLiteral","localNode","instruction","apply","parseInstructionBlock","bodySize","_startLoc6","instructionAlreadyCreated","instructionByte","symbolsByByte","object","node","namedArgs","_startLoc7","blocktype","parseBlockType","instr","label","loopNode","loopInstruction","_startLoc8","_blocktype","testIndex","ifBody","elseIndex","_instr","consequentInstr","alternate","testInstrs","ifNode","ifInstruction","_startLoc9","_blocktype2","_instr2","_label","blockNode","blockInstruction","callNode","callInstruction","indexLiteral","_startLoc10","_callNode","callIndirectInstruction","flagU32","flag","indicesu32","indices","_indexu","_index","_indexU","_index2","aligun32","align","offsetu32","_offset2","value32","valueu32","_value","value64","_value2","high","low","_node","valueu64","_value3","_high","_low","_node2","valuef32","_value4","floatLiteral","valuef64","_value5","align32","_align","_offsetu","_offset3","_i3","numberOfArgs","_node3","objectInstruction","_node4","parseLimits","limitType","shared","min","max","u32min","parseInt","u32max","_u32min","limit","elementTypeByte","elementType","tableTypes","limits","globalTypeByte","globalType","globalTypes","parseNameSectionFunctions","functionNames","numberOfFunctionsu32","numbeOfFunctions","functionNameMetadata","parseNameSectionLocals","localNames","numbeOfFunctionsu32","functionIndexu32","functionIndex","numLocalsu32","numLocals","_i4","localIndexu32","localIndex","localNameMetadata","parseNameSection","remainingBytes","nameMetadata","initialOffset","sectionTypeByte","subSectionSizeInBytesu32","parseProducersSection","metadata","producersSectionMetadata","fields","language","sdk","fieldI","fieldName","valueCount","producerI","producerName","producerVersion","producerMetadataVersionedName","producers","parseGlobalSection","numberOfGlobals","globals","_startLoc11","init","parseElemSection","numberOfElements","elems","_startLoc12","tableindexu32","bitfield","indexValues","_i5","elemNode","elem","elemKind","_indicesu","_indices","_indexValues","_i6","_indexu2","_index3","tableidx","_instr3","_elemKind","_indicesu2","_indices2","_indexValues2","_i7","_indexu3","_index4","_elemNode","_elemKind2","countU32","count","_i8","_indexu4","_index5","expr","_countU","_count","_i9","reftype","_countU2","_count2","_i10","_code","_reftype","_countU3","_count3","_i11","_code2","memory","parseTableSection","tables","tablesNode","parseMemorySection","memories","parseStartSection","startFuncIndex","start","parseDataSection","dataEntries","memoryIndexu32","memoryIndex","instrs","hasExtraInstrs","filter","data","memIndexLiteral","byteArray","parseSection","sectionIndex","sectionId","sections","custom","nextSectionIndex","startOffset","sectionSizeInBytes","sectionSizeInBytesNode","_startLoc13","_u","sectionMetadata","nodes","_startLoc14","_u2","numberOfTable","_metadata","_nodes","_startLoc15","numberOfImportsu32","_metadata2","_nodes2","_startLoc16","_metadata3","_nodes3","_startLoc17","_u3","_metadata4","_nodes4","_startLoc18","_u4","_metadata5","ignoreCodeSection","_nodes5","_metadata6","_nodes6","element","_startLoc19","numberOfElementsu32","_metadata7","_nodes7","_startLoc20","numberOfGlobalsu32","_metadata8","_nodes8","_startLoc21","_numberOfElementsu","_numberOfElements","_metadata9","_nodes9","_metadata10","_startLoc22","_numberOfElementsu2","_numberOfElements2","vectorOfSize","ignoreDataSection","_remainingBytes","_nodes10","_metadata11","sectionName","_remainingBytes2","e","message","_initialOffset","JSON","stringify","errorOnUnknownSection","blocktypeByte","blockTypes","moduleFields","moduleMetadata","_parseSection","metadataArray","forEach","metadataItem","funcIndex","body","decodedElementInCodeSection","funcNode","_startLoc23","moduleExport","moduleExportDescr","module","program"],"sources":["/home/wickliff/Desktop/dev-waki/portfolio2/node_modules/@webassemblyjs/wasm-parser/esm/decoder.js"],"sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { CompileError } from \"@webassemblyjs/helper-api-error\";\nimport * as ieee754 from \"@webassemblyjs/ieee754\";\nimport * as utf8 from \"@webassemblyjs/utf8\";\nimport * as t from \"@webassemblyjs/ast\";\nimport { decodeInt32, decodeUInt32, MAX_NUMBER_OF_BYTE_U32, decodeInt64, decodeUInt64, MAX_NUMBER_OF_BYTE_U64 } from \"@webassemblyjs/leb128\";\nimport constants from \"@webassemblyjs/helper-wasm-bytecode\";\n\nfunction toHex(n) {\n  return \"0x\" + Number(n).toString(16);\n}\n\nfunction byteArrayEq(l, r) {\n  if (l.length !== r.length) {\n    return false;\n  }\n\n  for (var i = 0; i < l.length; i++) {\n    if (l[i] !== r[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function decode(ab, opts) {\n  var buf = new Uint8Array(ab);\n  var getUniqueName = t.getUniqueNameGenerator();\n  var offset = 0;\n\n  function getPosition() {\n    return {\n      line: -1,\n      column: offset\n    };\n  }\n\n  function dump(b, msg) {\n    if (opts.dump === false) return;\n    var pad = \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\";\n    var str = \"\";\n\n    if (b.length < 5) {\n      str = b.map(toHex).join(\" \");\n    } else {\n      str = \"...\";\n    }\n\n    console.log(toHex(offset) + \":\\t\", str, pad, \";\", msg);\n  }\n\n  function dumpSep(msg) {\n    if (opts.dump === false) return;\n    console.log(\";\", msg);\n  }\n  /**\n   * TODO(sven): we can atually use a same structure\n   * we are adding incrementally new features\n   */\n\n\n  var state = {\n    elementsInFuncSection: [],\n    elementsInExportSection: [],\n    elementsInCodeSection: [],\n\n    /**\n     * Decode memory from:\n     * - Memory section\n     */\n    memoriesInModule: [],\n\n    /**\n     * Decoded types from:\n     * - Type section\n     */\n    typesInModule: [],\n\n    /**\n     * Decoded functions from:\n     * - Function section\n     * - Import section\n     */\n    functionsInModule: [],\n\n    /**\n     * Decoded tables from:\n     * - Table section\n     */\n    tablesInModule: [],\n\n    /**\n     * Decoded globals from:\n     * - Global section\n     */\n    globalsInModule: []\n  };\n\n  function isEOF() {\n    return offset >= buf.length;\n  }\n\n  function eatBytes(n) {\n    offset = offset + n;\n  }\n\n  function readBytesAtOffset(_offset, numberOfBytes) {\n    var arr = [];\n\n    for (var i = 0; i < numberOfBytes; i++) {\n      arr.push(buf[_offset + i]);\n    }\n\n    return arr;\n  }\n\n  function readBytes(numberOfBytes) {\n    return readBytesAtOffset(offset, numberOfBytes);\n  }\n\n  function readF64() {\n    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F64);\n    var value = ieee754.decodeF64(bytes);\n\n    if (Math.sign(value) * value === Infinity) {\n      return {\n        value: Math.sign(value),\n        inf: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F64\n      };\n    }\n\n    if (isNaN(value)) {\n      var sign = bytes[bytes.length - 1] >> 7 ? -1 : 1;\n      var mantissa = 0;\n\n      for (var i = 0; i < bytes.length - 2; ++i) {\n        mantissa += bytes[i] * Math.pow(256, i);\n      }\n\n      mantissa += bytes[bytes.length - 2] % 16 * Math.pow(256, bytes.length - 2);\n      return {\n        value: sign * mantissa,\n        nan: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F64\n      };\n    }\n\n    return {\n      value: value,\n      nextIndex: ieee754.NUMBER_OF_BYTE_F64\n    };\n  }\n\n  function readF32() {\n    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F32);\n    var value = ieee754.decodeF32(bytes);\n\n    if (Math.sign(value) * value === Infinity) {\n      return {\n        value: Math.sign(value),\n        inf: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F32\n      };\n    }\n\n    if (isNaN(value)) {\n      var sign = bytes[bytes.length - 1] >> 7 ? -1 : 1;\n      var mantissa = 0;\n\n      for (var i = 0; i < bytes.length - 2; ++i) {\n        mantissa += bytes[i] * Math.pow(256, i);\n      }\n\n      mantissa += bytes[bytes.length - 2] % 128 * Math.pow(256, bytes.length - 2);\n      return {\n        value: sign * mantissa,\n        nan: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F32\n      };\n    }\n\n    return {\n      value: value,\n      nextIndex: ieee754.NUMBER_OF_BYTE_F32\n    };\n  }\n\n  function readUTF8String() {\n    var lenu32 = readU32(); // Don't eat any bytes. Instead, peek ahead of the current offset using\n    // readBytesAtOffset below. This keeps readUTF8String neutral with respect\n    // to the current offset, just like the other readX functions.\n\n    var strlen = lenu32.value;\n    dump([strlen], \"string length\");\n    var bytes = readBytesAtOffset(offset + lenu32.nextIndex, strlen);\n    var value = utf8.decode(bytes);\n    return {\n      value: value,\n      nextIndex: strlen + lenu32.nextIndex\n    };\n  }\n  /**\n   * Decode an unsigned 32bits integer\n   *\n   * The length will be handled by the leb librairy, we pass the max number of\n   * byte.\n   */\n\n\n  function readU32() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U32);\n    var buffer = new Uint8Array(bytes);\n    return decodeUInt32(buffer);\n  }\n\n  function readVaruint32() {\n    // where 32 bits = max 4 bytes\n    var bytes = readBytes(4);\n    var buffer = new Uint8Array(bytes);\n    return decodeUInt32(buffer);\n  }\n\n  function readVaruint7() {\n    // where 7 bits = max 1 bytes\n    var bytes = readBytes(1);\n    var buffer = new Uint8Array(bytes);\n    return decodeUInt32(buffer);\n  }\n  /**\n   * Decode a signed 32bits interger\n   */\n\n\n  function read32() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U32);\n    var buffer = new Uint8Array(bytes);\n    return decodeInt32(buffer);\n  }\n  /**\n   * Decode a signed 64bits integer\n   */\n\n\n  function read64() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U64);\n    var buffer = new Uint8Array(bytes);\n    return decodeInt64(buffer);\n  }\n\n  function readU64() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U64);\n    var buffer = new Uint8Array(bytes);\n    return decodeUInt64(buffer);\n  }\n\n  function readByte() {\n    return readBytes(1)[0];\n  }\n\n  function parseModuleHeader() {\n    if (isEOF() === true || offset + 4 > buf.length) {\n      throw new Error(\"unexpected end\");\n    }\n\n    var header = readBytes(4);\n\n    if (byteArrayEq(constants.magicModuleHeader, header) === false) {\n      throw new CompileError(\"magic header not detected\");\n    }\n\n    dump(header, \"wasm magic header\");\n    eatBytes(4);\n  }\n\n  function parseVersion() {\n    if (isEOF() === true || offset + 4 > buf.length) {\n      throw new Error(\"unexpected end\");\n    }\n\n    var version = readBytes(4);\n\n    if (byteArrayEq(constants.moduleVersion, version) === false) {\n      throw new CompileError(\"unknown binary version\");\n    }\n\n    dump(version, \"wasm version\");\n    eatBytes(4);\n  }\n\n  function parseVec(cast) {\n    var u32 = readU32();\n    var length = u32.value;\n    eatBytes(u32.nextIndex);\n    dump([length], \"number\");\n\n    if (length === 0) {\n      return [];\n    }\n\n    var elements = [];\n\n    for (var i = 0; i < length; i++) {\n      var _byte = readByte();\n\n      eatBytes(1);\n      var value = cast(_byte);\n      dump([_byte], value);\n\n      if (typeof value === \"undefined\") {\n        throw new CompileError(\"Internal failure: parseVec could not cast the value\");\n      }\n\n      elements.push(value);\n    }\n\n    return elements;\n  } // Type section\n  // https://webassembly.github.io/spec/binary/modules.html#binary-typesec\n\n\n  function parseTypeSection(numberOfTypes) {\n    var typeInstructionNodes = [];\n    dump([numberOfTypes], \"num types\");\n\n    for (var i = 0; i < numberOfTypes; i++) {\n      var _startLoc = getPosition();\n\n      dumpSep(\"type \" + i);\n      var type = readByte();\n      eatBytes(1);\n\n      if (type == constants.types.func) {\n        dump([type], \"func\");\n        var paramValtypes = parseVec(function (b) {\n          var valtype = constants.valtypes[b];\n\n          if (valtype === undefined) {\n            throw new Error(\"unexpected value type \".concat(b));\n          }\n\n          return valtype;\n        });\n        var params = paramValtypes.map(function (v) {\n          return t.funcParam(\n          /*valtype*/\n          v);\n        });\n        var result = parseVec(function (b) {\n          return constants.valtypes[b];\n        });\n        typeInstructionNodes.push(function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.typeInstruction(undefined, t.signature(params, result)), endLoc, _startLoc);\n        }());\n        state.typesInModule.push({\n          params: params,\n          result: result\n        });\n      } else {\n        throw new Error(\"Unsupported type: \" + toHex(type));\n      }\n    }\n\n    return typeInstructionNodes;\n  } // Import section\n  // https://webassembly.github.io/spec/binary/modules.html#binary-importsec\n\n\n  function parseImportSection(numberOfImports) {\n    var imports = [];\n\n    for (var i = 0; i < numberOfImports; i++) {\n      dumpSep(\"import header \" + i);\n\n      var _startLoc2 = getPosition();\n      /**\n       * Module name\n       */\n\n\n      var moduleName = readUTF8String();\n      eatBytes(moduleName.nextIndex);\n      dump([], \"module name (\".concat(moduleName.value, \")\"));\n      /**\n       * Name\n       */\n\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      dump([], \"name (\".concat(name.value, \")\"));\n      /**\n       * Import descr\n       */\n\n      var descrTypeByte = readByte();\n      eatBytes(1);\n      var descrType = constants.importTypes[descrTypeByte];\n      dump([descrTypeByte], \"import kind\");\n\n      if (typeof descrType === \"undefined\") {\n        throw new CompileError(\"Unknown import description type: \" + toHex(descrTypeByte));\n      }\n\n      var importDescr = void 0;\n\n      if (descrType === \"func\") {\n        var indexU32 = readU32();\n        var typeindex = indexU32.value;\n        eatBytes(indexU32.nextIndex);\n        dump([typeindex], \"type index\");\n        var signature = state.typesInModule[typeindex];\n\n        if (typeof signature === \"undefined\") {\n          throw new CompileError(\"function signature not found (\".concat(typeindex, \")\"));\n        }\n\n        var id = getUniqueName(\"func\");\n        importDescr = t.funcImportDescr(id, t.signature(signature.params, signature.result));\n        state.functionsInModule.push({\n          id: t.identifier(name.value),\n          signature: signature,\n          isExternal: true\n        });\n      } else if (descrType === \"global\") {\n        importDescr = parseGlobalType();\n        var globalNode = t.global(importDescr, []);\n        state.globalsInModule.push(globalNode);\n      } else if (descrType === \"table\") {\n        importDescr = parseTableType(i);\n      } else if (descrType === \"memory\") {\n        var memoryNode = parseMemoryType(0);\n        state.memoriesInModule.push(memoryNode);\n        importDescr = memoryNode;\n      } else {\n        throw new CompileError(\"Unsupported import of type: \" + descrType);\n      }\n\n      imports.push(function () {\n        var endLoc = getPosition();\n        return t.withLoc(t.moduleImport(moduleName.value, name.value, importDescr), endLoc, _startLoc2);\n      }());\n    }\n\n    return imports;\n  } // Function section\n  // https://webassembly.github.io/spec/binary/modules.html#function-section\n\n\n  function parseFuncSection(numberOfFunctions) {\n    dump([numberOfFunctions], \"num funcs\");\n\n    for (var i = 0; i < numberOfFunctions; i++) {\n      var indexU32 = readU32();\n      var typeindex = indexU32.value;\n      eatBytes(indexU32.nextIndex);\n      dump([typeindex], \"type index\");\n      var signature = state.typesInModule[typeindex];\n\n      if (typeof signature === \"undefined\") {\n        throw new CompileError(\"function signature not found (\".concat(typeindex, \")\"));\n      } // preserve anonymous, a name might be resolved later\n\n\n      var id = t.withRaw(t.identifier(getUniqueName(\"func\")), \"\");\n      state.functionsInModule.push({\n        id: id,\n        signature: signature,\n        isExternal: false\n      });\n    }\n  } // Export section\n  // https://webassembly.github.io/spec/binary/modules.html#export-section\n\n\n  function parseExportSection(numberOfExport) {\n    dump([numberOfExport], \"num exports\"); // Parse vector of exports\n\n    for (var i = 0; i < numberOfExport; i++) {\n      var _startLoc3 = getPosition();\n      /**\n       * Name\n       */\n\n\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      dump([], \"export name (\".concat(name.value, \")\"));\n      /**\n       * exportdescr\n       */\n\n      var typeIndex = readByte();\n      eatBytes(1);\n      dump([typeIndex], \"export kind\");\n      var indexu32 = readU32();\n      var index = indexu32.value;\n      eatBytes(indexu32.nextIndex);\n      dump([index], \"export index\");\n      var id = void 0,\n          signature = void 0;\n\n      if (constants.exportTypes[typeIndex] === \"Func\") {\n        var func = state.functionsInModule[index];\n\n        if (typeof func === \"undefined\") {\n          throw new CompileError(\"unknown function (\".concat(index, \")\"));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = func.signature;\n      } else if (constants.exportTypes[typeIndex] === \"Table\") {\n        var table = state.tablesInModule[index];\n\n        if (typeof table === \"undefined\") {\n          throw new CompileError(\"unknown table \".concat(index));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else if (constants.exportTypes[typeIndex] === \"Memory\") {\n        var memNode = state.memoriesInModule[index];\n\n        if (typeof memNode === \"undefined\") {\n          throw new CompileError(\"unknown memory \".concat(index));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else if (constants.exportTypes[typeIndex] === \"Global\") {\n        var global = state.globalsInModule[index];\n\n        if (typeof global === \"undefined\") {\n          throw new CompileError(\"unknown global \".concat(index));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else {\n        console.warn(\"Unsupported export type: \" + toHex(typeIndex));\n        return;\n      }\n\n      var endLoc = getPosition();\n      state.elementsInExportSection.push({\n        name: name.value,\n        type: constants.exportTypes[typeIndex],\n        signature: signature,\n        id: id,\n        index: index,\n        endLoc: endLoc,\n        startLoc: _startLoc3\n      });\n    }\n  } // Code section\n  // https://webassembly.github.io/spec/binary/modules.html#code-section\n\n\n  function parseCodeSection(numberOfFuncs) {\n    dump([numberOfFuncs], \"number functions\"); // Parse vector of function\n\n    for (var i = 0; i < numberOfFuncs; i++) {\n      var _startLoc4 = getPosition();\n\n      dumpSep(\"function body \" + i); // the u32 size of the function code in bytes\n      // Ignore it for now\n\n      var bodySizeU32 = readU32();\n      eatBytes(bodySizeU32.nextIndex);\n      dump([bodySizeU32.value], \"function body size\");\n      var code = []; // Parse locals\n\n      var funcLocalNumU32 = readU32();\n      var funcLocalNum = funcLocalNumU32.value;\n      eatBytes(funcLocalNumU32.nextIndex);\n      dump([funcLocalNum], \"num locals\");\n      var locals = [];\n\n      for (var _i = 0; _i < funcLocalNum; _i++) {\n        var _startLoc5 = getPosition();\n\n        var localCountU32 = readU32();\n        var localCount = localCountU32.value;\n        eatBytes(localCountU32.nextIndex);\n        dump([localCount], \"num local\");\n        var valtypeByte = readByte();\n        eatBytes(1);\n        var type = constants.valtypes[valtypeByte];\n        var args = [];\n\n        for (var _i2 = 0; _i2 < localCount; _i2++) {\n          args.push(t.valtypeLiteral(type));\n        }\n\n        var localNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.instruction(\"local\", args), endLoc, _startLoc5);\n        }();\n\n        locals.push(localNode);\n        dump([valtypeByte], type);\n\n        if (typeof type === \"undefined\") {\n          throw new CompileError(\"Unexpected valtype: \" + toHex(valtypeByte));\n        }\n      }\n\n      code.push.apply(code, locals); // Decode instructions until the end\n\n      parseInstructionBlock(code);\n      var endLoc = getPosition();\n      state.elementsInCodeSection.push({\n        code: code,\n        locals: locals,\n        endLoc: endLoc,\n        startLoc: _startLoc4,\n        bodySize: bodySizeU32.value\n      });\n    }\n  }\n\n  function parseInstructionBlock(code) {\n    while (true) {\n      var _startLoc6 = getPosition();\n\n      var instructionAlreadyCreated = false;\n      var instructionByte = readByte();\n      eatBytes(1);\n\n      if (instructionByte === 0xfe) {\n        instructionByte = 0xfe00 + readByte();\n        eatBytes(1);\n      } // Table instructions\n      // https://webassembly.github.io/spec/core/binary/instructions.html#table-instructions\n\n\n      if (instructionByte === 0xfc) {\n        instructionByte = 0xfc00 + readByte();\n        eatBytes(1);\n      }\n\n      var instruction = constants.symbolsByByte[instructionByte];\n\n      if (typeof instruction === \"undefined\") {\n        throw new CompileError(\"Unexpected instruction: \" + toHex(instructionByte));\n      }\n\n      if (instruction === \"illegal\") {\n        throw new Error(\"tried to decode an illegal bytecode: \".concat(toHex(instructionByte)));\n      }\n\n      if (typeof instruction.object === \"string\") {\n        dump([instructionByte], \"\".concat(instruction.object, \".\").concat(instruction.name));\n      } else {\n        dump([instructionByte], instruction.name);\n      }\n      /**\n       * End of the function\n       */\n\n\n      if (instruction.name === \"end\") {\n        var node = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.instruction(instruction.name), endLoc, _startLoc6);\n        }();\n\n        code.push(node);\n        break;\n      }\n\n      var args = [];\n      var namedArgs = void 0;\n\n      if (instruction.name === \"loop\") {\n        var _startLoc7 = getPosition();\n\n        var blocktype = parseBlockType();\n        var instr = [];\n        parseInstructionBlock(instr); // preserve anonymous\n\n        var label = t.withRaw(t.identifier(getUniqueName(\"loop\")), \"\");\n\n        var loopNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.loopInstruction(label, blocktype, instr), endLoc, _startLoc7);\n        }();\n\n        code.push(loopNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"if\") {\n        var _startLoc8 = getPosition();\n\n        var _blocktype = parseBlockType();\n\n        var testIndex = t.withRaw(t.identifier(getUniqueName(\"if\")), \"\");\n        var ifBody = [];\n        parseInstructionBlock(ifBody); // Defaults to no alternate\n\n        var elseIndex = 0;\n\n        for (elseIndex = 0; elseIndex < ifBody.length; ++elseIndex) {\n          var _instr = ifBody[elseIndex];\n\n          if (_instr.type === \"Instr\" && _instr.id === \"else\") {\n            break;\n          }\n        }\n\n        var consequentInstr = ifBody.slice(0, elseIndex);\n        var alternate = ifBody.slice(elseIndex + 1); // wast sugar\n\n        var testInstrs = [];\n\n        var ifNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.ifInstruction(testIndex, testInstrs, _blocktype, consequentInstr, alternate), endLoc, _startLoc8);\n        }();\n\n        code.push(ifNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"block\") {\n        var _startLoc9 = getPosition();\n\n        var _blocktype2 = parseBlockType();\n\n        var _instr2 = [];\n        parseInstructionBlock(_instr2); // preserve anonymous\n\n        var _label = t.withRaw(t.identifier(getUniqueName(\"block\")), \"\");\n\n        var blockNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.blockInstruction(_label, _instr2, _blocktype2), endLoc, _startLoc9);\n        }();\n\n        code.push(blockNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"call\") {\n        var indexu32 = readU32();\n        var index = indexu32.value;\n        eatBytes(indexu32.nextIndex);\n        dump([index], \"index\");\n\n        var callNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.callInstruction(t.indexLiteral(index)), endLoc, _startLoc6);\n        }();\n\n        code.push(callNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"call_indirect\") {\n        var _startLoc10 = getPosition();\n\n        var indexU32 = readU32();\n        var typeindex = indexU32.value;\n        eatBytes(indexU32.nextIndex);\n        dump([typeindex], \"type index\");\n        var signature = state.typesInModule[typeindex];\n\n        if (typeof signature === \"undefined\") {\n          throw new CompileError(\"call_indirect signature not found (\".concat(typeindex, \")\"));\n        }\n\n        var _callNode = t.callIndirectInstruction(t.signature(signature.params, signature.result), []);\n\n        var flagU32 = readU32();\n        var flag = flagU32.value; // 0x00 - reserved byte\n\n        eatBytes(flagU32.nextIndex);\n\n        if (flag !== 0) {\n          throw new CompileError(\"zero flag expected\");\n        }\n\n        code.push(function () {\n          var endLoc = getPosition();\n          return t.withLoc(_callNode, endLoc, _startLoc10);\n        }());\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"br_table\") {\n        var indicesu32 = readU32();\n        var indices = indicesu32.value;\n        eatBytes(indicesu32.nextIndex);\n        dump([indices], \"num indices\");\n\n        for (var i = 0; i <= indices; i++) {\n          var _indexu = readU32();\n\n          var _index = _indexu.value;\n          eatBytes(_indexu.nextIndex);\n          dump([_index], \"index\");\n          args.push(t.numberLiteralFromRaw(_indexu.value.toString(), \"u32\"));\n        }\n      } else if (instructionByte >= 0x28 && instructionByte <= 0x40) {\n        /**\n         * Memory instructions\n         */\n        if (instruction.name === \"grow_memory\" || instruction.name === \"current_memory\") {\n          var _indexU = readU32();\n\n          var _index2 = _indexU.value;\n          eatBytes(_indexU.nextIndex);\n\n          if (_index2 !== 0) {\n            throw new Error(\"zero flag expected\");\n          }\n\n          dump([_index2], \"index\");\n        } else {\n          var aligun32 = readU32();\n          var align = aligun32.value;\n          eatBytes(aligun32.nextIndex);\n          dump([align], \"align\");\n          var offsetu32 = readU32();\n          var _offset2 = offsetu32.value;\n          eatBytes(offsetu32.nextIndex);\n          dump([_offset2], \"offset\");\n          if (namedArgs === undefined) namedArgs = {};\n          namedArgs.offset = t.numberLiteralFromRaw(_offset2);\n        }\n      } else if (instructionByte >= 0x41 && instructionByte <= 0x44) {\n        /**\n         * Numeric instructions\n         */\n        if (instruction.object === \"i32\") {\n          var value32 = read32();\n          var value = value32.value;\n          eatBytes(value32.nextIndex);\n          dump([value], \"i32 value\");\n          args.push(t.numberLiteralFromRaw(value));\n        }\n\n        if (instruction.object === \"u32\") {\n          var valueu32 = readU32();\n          var _value = valueu32.value;\n          eatBytes(valueu32.nextIndex);\n          dump([_value], \"u32 value\");\n          args.push(t.numberLiteralFromRaw(_value));\n        }\n\n        if (instruction.object === \"i64\") {\n          var value64 = read64();\n          var _value2 = value64.value;\n          eatBytes(value64.nextIndex);\n          dump([Number(_value2.toString())], \"i64 value\");\n          var high = _value2.high,\n              low = _value2.low;\n          var _node = {\n            type: \"LongNumberLiteral\",\n            value: {\n              high: high,\n              low: low\n            }\n          };\n          args.push(_node);\n        }\n\n        if (instruction.object === \"u64\") {\n          var valueu64 = readU64();\n          var _value3 = valueu64.value;\n          eatBytes(valueu64.nextIndex);\n          dump([Number(_value3.toString())], \"u64 value\");\n          var _high = _value3.high,\n              _low = _value3.low;\n          var _node2 = {\n            type: \"LongNumberLiteral\",\n            value: {\n              high: _high,\n              low: _low\n            }\n          };\n          args.push(_node2);\n        }\n\n        if (instruction.object === \"f32\") {\n          var valuef32 = readF32();\n          var _value4 = valuef32.value;\n          eatBytes(valuef32.nextIndex);\n          dump([_value4], \"f32 value\");\n          args.push( // $FlowIgnore\n          t.floatLiteral(_value4, valuef32.nan, valuef32.inf, String(_value4)));\n        }\n\n        if (instruction.object === \"f64\") {\n          var valuef64 = readF64();\n          var _value5 = valuef64.value;\n          eatBytes(valuef64.nextIndex);\n          dump([_value5], \"f64 value\");\n          args.push( // $FlowIgnore\n          t.floatLiteral(_value5, valuef64.nan, valuef64.inf, String(_value5)));\n        }\n      } else if (instructionByte >= 0xfe00 && instructionByte <= 0xfeff) {\n        /**\n         * Atomic memory instructions\n         */\n        var align32 = readU32();\n        var _align = align32.value;\n        eatBytes(align32.nextIndex);\n        dump([_align], \"align\");\n\n        var _offsetu = readU32();\n\n        var _offset3 = _offsetu.value;\n        eatBytes(_offsetu.nextIndex);\n        dump([_offset3], \"offset\");\n      } else {\n        for (var _i3 = 0; _i3 < instruction.numberOfArgs; _i3++) {\n          var u32 = readU32();\n          eatBytes(u32.nextIndex);\n          dump([u32.value], \"argument \" + _i3);\n          args.push(t.numberLiteralFromRaw(u32.value));\n        }\n      }\n\n      if (instructionAlreadyCreated === false) {\n        if (typeof instruction.object === \"string\") {\n          var _node3 = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.objectInstruction(instruction.name, instruction.object, args, namedArgs), endLoc, _startLoc6);\n          }();\n\n          code.push(_node3);\n        } else {\n          var _node4 = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.instruction(instruction.name, args, namedArgs), endLoc, _startLoc6);\n          }();\n\n          code.push(_node4);\n        }\n      }\n    }\n  } // https://webassembly.github.io/spec/core/binary/types.html#limits\n\n\n  function parseLimits() {\n    var limitType = readByte();\n    eatBytes(1);\n    var shared = limitType === 0x03;\n    dump([limitType], \"limit type\" + (shared ? \" (shared)\" : \"\"));\n    var min, max;\n\n    if (limitType === 0x01 || limitType === 0x03 // shared limits\n    ) {\n      var u32min = readU32();\n      min = parseInt(u32min.value);\n      eatBytes(u32min.nextIndex);\n      dump([min], \"min\");\n      var u32max = readU32();\n      max = parseInt(u32max.value);\n      eatBytes(u32max.nextIndex);\n      dump([max], \"max\");\n    }\n\n    if (limitType === 0x00) {\n      var _u32min = readU32();\n\n      min = parseInt(_u32min.value);\n      eatBytes(_u32min.nextIndex);\n      dump([min], \"min\");\n    }\n\n    return t.limit(min, max, shared);\n  } // https://webassembly.github.io/spec/core/binary/types.html#binary-tabletype\n\n\n  function parseTableType(index) {\n    var name = t.withRaw(t.identifier(getUniqueName(\"table\")), String(index));\n    var elementTypeByte = readByte();\n    eatBytes(1);\n    dump([elementTypeByte], \"element type\");\n    var elementType = constants.tableTypes[elementTypeByte];\n\n    if (typeof elementType === \"undefined\") {\n      throw new CompileError(\"Unknown element type in table: \" + toHex(elementTypeByte));\n    }\n\n    var limits = parseLimits();\n    return t.table(elementType, limits, name);\n  } // https://webassembly.github.io/spec/binary/types.html#global-types\n\n\n  function parseGlobalType() {\n    var valtypeByte = readByte();\n    eatBytes(1);\n    var type = constants.valtypes[valtypeByte];\n    dump([valtypeByte], type);\n\n    if (typeof type === \"undefined\") {\n      throw new CompileError(\"Unknown valtype: \" + toHex(valtypeByte));\n    }\n\n    var globalTypeByte = readByte();\n    eatBytes(1);\n    var globalType = constants.globalTypes[globalTypeByte];\n    dump([globalTypeByte], \"global type (\".concat(globalType, \")\"));\n\n    if (typeof globalType === \"undefined\") {\n      throw new CompileError(\"Invalid mutability: \" + toHex(globalTypeByte));\n    }\n\n    return t.globalType(type, globalType);\n  } // function parseNameModule() {\n  //   const lenu32 = readVaruint32();\n  //   eatBytes(lenu32.nextIndex);\n  //   console.log(\"len\", lenu32);\n  //   const strlen = lenu32.value;\n  //   dump([strlen], \"string length\");\n  //   const bytes = readBytes(strlen);\n  //   eatBytes(strlen);\n  //   const value = utf8.decode(bytes);\n  //   return [t.moduleNameMetadata(value)];\n  // }\n  // this section contains an array of function names and indices\n\n\n  function parseNameSectionFunctions() {\n    var functionNames = [];\n    var numberOfFunctionsu32 = readU32();\n    var numbeOfFunctions = numberOfFunctionsu32.value;\n    eatBytes(numberOfFunctionsu32.nextIndex);\n\n    for (var i = 0; i < numbeOfFunctions; i++) {\n      var indexu32 = readU32();\n      var index = indexu32.value;\n      eatBytes(indexu32.nextIndex);\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      functionNames.push(t.functionNameMetadata(name.value, index));\n    }\n\n    return functionNames;\n  }\n\n  function parseNameSectionLocals() {\n    var localNames = [];\n    var numbeOfFunctionsu32 = readU32();\n    var numbeOfFunctions = numbeOfFunctionsu32.value;\n    eatBytes(numbeOfFunctionsu32.nextIndex);\n\n    for (var i = 0; i < numbeOfFunctions; i++) {\n      var functionIndexu32 = readU32();\n      var functionIndex = functionIndexu32.value;\n      eatBytes(functionIndexu32.nextIndex);\n      var numLocalsu32 = readU32();\n      var numLocals = numLocalsu32.value;\n      eatBytes(numLocalsu32.nextIndex);\n\n      for (var _i4 = 0; _i4 < numLocals; _i4++) {\n        var localIndexu32 = readU32();\n        var localIndex = localIndexu32.value;\n        eatBytes(localIndexu32.nextIndex);\n        var name = readUTF8String();\n        eatBytes(name.nextIndex);\n        localNames.push(t.localNameMetadata(name.value, localIndex, functionIndex));\n      }\n    }\n\n    return localNames;\n  } // this is a custom section used for name resolution\n  // https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#name-section\n\n\n  function parseNameSection(remainingBytes) {\n    var nameMetadata = [];\n    var initialOffset = offset;\n\n    while (offset - initialOffset < remainingBytes) {\n      // name_type\n      var sectionTypeByte = readVaruint7();\n      eatBytes(sectionTypeByte.nextIndex); // name_payload_len\n\n      var subSectionSizeInBytesu32 = readVaruint32();\n      eatBytes(subSectionSizeInBytesu32.nextIndex);\n\n      switch (sectionTypeByte.value) {\n        // case 0: {\n        // TODO(sven): re-enable that\n        // Current status: it seems that when we decode the module's name\n        // no name_payload_len is used.\n        //\n        // See https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#name-section\n        //\n        // nameMetadata.push(...parseNameModule());\n        // break;\n        // }\n        case 1:\n          {\n            nameMetadata.push.apply(nameMetadata, _toConsumableArray(parseNameSectionFunctions()));\n            break;\n          }\n\n        case 2:\n          {\n            nameMetadata.push.apply(nameMetadata, _toConsumableArray(parseNameSectionLocals()));\n            break;\n          }\n\n        default:\n          {\n            // skip unknown subsection\n            eatBytes(subSectionSizeInBytesu32.value);\n          }\n      }\n    }\n\n    return nameMetadata;\n  } // this is a custom section used for information about the producers\n  // https://github.com/WebAssembly/tool-conventions/blob/master/ProducersSection.md\n\n\n  function parseProducersSection() {\n    var metadata = t.producersSectionMetadata([]); // field_count\n\n    var sectionTypeByte = readVaruint32();\n    eatBytes(sectionTypeByte.nextIndex);\n    dump([sectionTypeByte.value], \"num of producers\");\n    var fields = {\n      language: [],\n      \"processed-by\": [],\n      sdk: []\n    }; // fields\n\n    for (var fieldI = 0; fieldI < sectionTypeByte.value; fieldI++) {\n      // field_name\n      var fieldName = readUTF8String();\n      eatBytes(fieldName.nextIndex); // field_value_count\n\n      var valueCount = readVaruint32();\n      eatBytes(valueCount.nextIndex); // field_values\n\n      for (var producerI = 0; producerI < valueCount.value; producerI++) {\n        var producerName = readUTF8String();\n        eatBytes(producerName.nextIndex);\n        var producerVersion = readUTF8String();\n        eatBytes(producerVersion.nextIndex);\n        fields[fieldName.value].push(t.producerMetadataVersionedName(producerName.value, producerVersion.value));\n      }\n\n      metadata.producers.push(fields[fieldName.value]);\n    }\n\n    return metadata;\n  }\n\n  function parseGlobalSection(numberOfGlobals) {\n    var globals = [];\n    dump([numberOfGlobals], \"num globals\");\n\n    for (var i = 0; i < numberOfGlobals; i++) {\n      var _startLoc11 = getPosition();\n\n      var globalType = parseGlobalType();\n      /**\n       * Global expressions\n       */\n\n      var init = [];\n      parseInstructionBlock(init);\n\n      var node = function () {\n        var endLoc = getPosition();\n        return t.withLoc(t.global(globalType, init), endLoc, _startLoc11);\n      }();\n\n      globals.push(node);\n      state.globalsInModule.push(node);\n    }\n\n    return globals;\n  }\n\n  function parseElemSection(numberOfElements) {\n    var elems = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var _startLoc12 = getPosition();\n\n      var tableindexu32 = readU32();\n      var bitfield = tableindexu32.value;\n      eatBytes(tableindexu32.nextIndex);\n      dump([bitfield], \"bitfield\");\n\n      if (bitfield === 0) {\n        // Parse instructions\n        var instr = [];\n        parseInstructionBlock(instr); // Parse ( vector function index ) *\n\n        var indicesu32 = readU32();\n        var indices = indicesu32.value;\n        eatBytes(indicesu32.nextIndex);\n        dump([indices], \"num indices\");\n        var indexValues = [];\n\n        for (var _i5 = 0; _i5 < indices; _i5++) {\n          var indexu32 = readU32();\n          var index = indexu32.value;\n          eatBytes(indexu32.nextIndex);\n          dump([index], \"index\");\n          indexValues.push(t.indexLiteral(index));\n        }\n\n        var elemNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.elem(t.indexLiteral(bitfield), instr, indexValues), endLoc, _startLoc12);\n        }();\n\n        elems.push(elemNode);\n      } else if (bitfield === 1) {\n        var elemKind = readByte();\n        eatBytes(1);\n\n        if (elemKind !== 0) {\n          throw new Error(\"unexpected Elem kind: \".concat(toHex(elemKind)));\n        } // Parse ( vector function index ) *\n\n\n        var _indicesu = readU32();\n\n        var _indices = _indicesu.value;\n        eatBytes(_indicesu.nextIndex);\n        dump([_indices], \"num indices\");\n        var _indexValues = [];\n\n        for (var _i6 = 0; _i6 < _indices; _i6++) {\n          var _indexu2 = readU32();\n\n          var _index3 = _indexu2.value;\n          eatBytes(_indexu2.nextIndex);\n          dump([_index3], \"index\");\n\n          _indexValues.push(t.indexLiteral(_index3));\n        } // TODO: emit a AST node, for now just make it parse.\n\n      } else if (bitfield === 2) {\n        var u32 = readU32();\n        var tableidx = u32.value;\n        eatBytes(u32.nextIndex);\n        dump([tableidx], \"tableidx\"); // Parse instructions\n\n        var _instr3 = [];\n        parseInstructionBlock(_instr3);\n\n        var _elemKind = readByte();\n\n        eatBytes(1);\n\n        if (_elemKind !== 0) {\n          throw new Error(\"unexpected Elem kind: \".concat(toHex(_elemKind)));\n        } // Parse ( vector function index ) *\n\n\n        var _indicesu2 = readU32();\n\n        var _indices2 = _indicesu2.value;\n        eatBytes(_indicesu2.nextIndex);\n        dump([_indices2], \"num indices\");\n        var _indexValues2 = [];\n\n        for (var _i7 = 0; _i7 < _indices2; _i7++) {\n          var _indexu3 = readU32();\n\n          var _index4 = _indexu3.value;\n          eatBytes(_indexu3.nextIndex);\n          dump([_index4], \"index\");\n\n          _indexValues2.push(t.indexLiteral(_index4));\n        }\n\n        var _elemNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.elem(t.indexLiteral(bitfield), _instr3, _indexValues2), endLoc, _startLoc12);\n        }();\n\n        elems.push(_elemNode);\n      } else if (bitfield === 3) {\n        var _elemKind2 = readByte();\n\n        eatBytes(1);\n\n        if (_elemKind2 !== 0) {\n          throw new Error(\"unexpected Elem kind: \".concat(toHex(_elemKind2)));\n        } // Parse ( vector function index ) *\n\n\n        var countU32 = readU32();\n        var count = countU32.value;\n        eatBytes(countU32.nextIndex);\n        dump([count], \"count\");\n\n        for (var _i8 = 0; _i8 < count; _i8++) {\n          var _indexu4 = readU32();\n\n          var _index5 = _indexu4.value;\n          eatBytes(_indexu4.nextIndex);\n          dump([_index5], \"index\");\n        } // TODO: emit a AST node, for now just make it parse.\n\n      } else if (bitfield === 4) {\n        var expr = [];\n        parseInstructionBlock(expr);\n\n        var _countU = readU32();\n\n        var _count = _countU.value;\n        eatBytes(_countU.nextIndex);\n        dump([_count], \"count\");\n\n        for (var _i9 = 0; _i9 < _count; _i9++) {\n          var code = [];\n          parseInstructionBlock(code);\n        } // TODO: emit a AST node, for now just make it parse.\n\n      } else if (bitfield === 5) {\n        var reftype = readByte();\n        eatBytes(1);\n        dump([reftype], \"reftype\");\n\n        var _countU2 = readU32();\n\n        var _count2 = _countU2.value;\n        eatBytes(_countU2.nextIndex);\n        dump([_count2], \"count\");\n\n        for (var _i10 = 0; _i10 < _count2; _i10++) {\n          var _code = [];\n          parseInstructionBlock(_code);\n        } // TODO: emit a AST node, for now just make it parse.\n\n      } else if (bitfield === 7) {\n        var _reftype = readByte();\n\n        eatBytes(1);\n        dump([_reftype], \"reftype\");\n\n        var _countU3 = readU32();\n\n        var _count3 = _countU3.value;\n        eatBytes(_countU3.nextIndex);\n        dump([_count3], \"count\");\n\n        for (var _i11 = 0; _i11 < _count3; _i11++) {\n          var _code2 = [];\n          parseInstructionBlock(_code2);\n        } // TODO: emit a AST node, for now just make it parse.\n\n      } else {\n        throw new Error(\"unexpected Elem with bitfield \".concat(toHex(bitfield)));\n      }\n    }\n\n    return elems;\n  } // https://webassembly.github.io/spec/core/binary/types.html#memory-types\n\n\n  function parseMemoryType(i) {\n    var limits = parseLimits();\n    return t.memory(limits, t.indexLiteral(i));\n  } // https://webassembly.github.io/spec/binary/modules.html#table-section\n\n\n  function parseTableSection(numberOfElements) {\n    var tables = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var tablesNode = parseTableType(i);\n      state.tablesInModule.push(tablesNode);\n      tables.push(tablesNode);\n    }\n\n    return tables;\n  } // https://webassembly.github.io/spec/binary/modules.html#memory-section\n\n\n  function parseMemorySection(numberOfElements) {\n    var memories = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var memoryNode = parseMemoryType(i);\n      state.memoriesInModule.push(memoryNode);\n      memories.push(memoryNode);\n    }\n\n    return memories;\n  } // https://webassembly.github.io/spec/binary/modules.html#binary-startsec\n\n\n  function parseStartSection() {\n    var startLoc = getPosition();\n    var u32 = readU32();\n    var startFuncIndex = u32.value;\n    eatBytes(u32.nextIndex);\n    dump([startFuncIndex], \"index\");\n    return function () {\n      var endLoc = getPosition();\n      return t.withLoc(t.start(t.indexLiteral(startFuncIndex)), endLoc, startLoc);\n    }();\n  } // https://webassembly.github.io/spec/binary/modules.html#data-section\n\n\n  function parseDataSection(numberOfElements) {\n    var dataEntries = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var memoryIndexu32 = readU32();\n      var memoryIndex = memoryIndexu32.value;\n      eatBytes(memoryIndexu32.nextIndex);\n      dump([memoryIndex], \"memory index\");\n      var instrs = [];\n      parseInstructionBlock(instrs);\n      var hasExtraInstrs = instrs.filter(function (i) {\n        return i.id !== \"end\";\n      }).length !== 1;\n\n      if (hasExtraInstrs) {\n        throw new CompileError(\"data section offset must be a single instruction\");\n      }\n\n      var bytes = parseVec(function (b) {\n        return b;\n      });\n      dump([], \"init\");\n      dataEntries.push(t.data(t.memIndexLiteral(memoryIndex), instrs[0], t.byteArray(bytes)));\n    }\n\n    return dataEntries;\n  } // https://webassembly.github.io/spec/binary/modules.html#binary-section\n\n\n  function parseSection(sectionIndex) {\n    var sectionId = readByte();\n    eatBytes(1);\n\n    if (sectionId >= sectionIndex || sectionIndex === constants.sections.custom) {\n      sectionIndex = sectionId + 1;\n    } else {\n      if (sectionId !== constants.sections.custom) throw new CompileError(\"Unexpected section: \" + toHex(sectionId));\n    }\n\n    var nextSectionIndex = sectionIndex;\n    var startOffset = offset;\n    var startLoc = getPosition();\n    var u32 = readU32();\n    var sectionSizeInBytes = u32.value;\n    eatBytes(u32.nextIndex);\n\n    var sectionSizeInBytesNode = function () {\n      var endLoc = getPosition();\n      return t.withLoc(t.numberLiteralFromRaw(sectionSizeInBytes), endLoc, startLoc);\n    }();\n\n    switch (sectionId) {\n      case constants.sections.type:\n        {\n          dumpSep(\"section Type\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc13 = getPosition();\n\n          var _u = readU32();\n\n          var numberOfTypes = _u.value;\n          eatBytes(_u.nextIndex);\n          var metadata = t.sectionMetadata(\"type\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfTypes), endLoc, _startLoc13);\n          }());\n          var nodes = parseTypeSection(numberOfTypes);\n          return {\n            nodes: nodes,\n            metadata: metadata,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.table:\n        {\n          dumpSep(\"section Table\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc14 = getPosition();\n\n          var _u2 = readU32();\n\n          var numberOfTable = _u2.value;\n          eatBytes(_u2.nextIndex);\n          dump([numberOfTable], \"num tables\");\n\n          var _metadata = t.sectionMetadata(\"table\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfTable), endLoc, _startLoc14);\n          }());\n\n          var _nodes = parseTableSection(numberOfTable);\n\n          return {\n            nodes: _nodes,\n            metadata: _metadata,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections[\"import\"]:\n        {\n          dumpSep(\"section Import\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc15 = getPosition();\n\n          var numberOfImportsu32 = readU32();\n          var numberOfImports = numberOfImportsu32.value;\n          eatBytes(numberOfImportsu32.nextIndex);\n          dump([numberOfImports], \"number of imports\");\n\n          var _metadata2 = t.sectionMetadata(\"import\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfImports), endLoc, _startLoc15);\n          }());\n\n          var _nodes2 = parseImportSection(numberOfImports);\n\n          return {\n            nodes: _nodes2,\n            metadata: _metadata2,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.func:\n        {\n          dumpSep(\"section Function\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc16 = getPosition();\n\n          var numberOfFunctionsu32 = readU32();\n          var numberOfFunctions = numberOfFunctionsu32.value;\n          eatBytes(numberOfFunctionsu32.nextIndex);\n\n          var _metadata3 = t.sectionMetadata(\"func\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfFunctions), endLoc, _startLoc16);\n          }());\n\n          parseFuncSection(numberOfFunctions);\n          var _nodes3 = [];\n          return {\n            nodes: _nodes3,\n            metadata: _metadata3,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections[\"export\"]:\n        {\n          dumpSep(\"section Export\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc17 = getPosition();\n\n          var _u3 = readU32();\n\n          var numberOfExport = _u3.value;\n          eatBytes(_u3.nextIndex);\n\n          var _metadata4 = t.sectionMetadata(\"export\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfExport), endLoc, _startLoc17);\n          }());\n\n          parseExportSection(numberOfExport);\n          var _nodes4 = [];\n          return {\n            nodes: _nodes4,\n            metadata: _metadata4,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.code:\n        {\n          dumpSep(\"section Code\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc18 = getPosition();\n\n          var _u4 = readU32();\n\n          var numberOfFuncs = _u4.value;\n          eatBytes(_u4.nextIndex);\n\n          var _metadata5 = t.sectionMetadata(\"code\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfFuncs), endLoc, _startLoc18);\n          }());\n\n          if (opts.ignoreCodeSection === true) {\n            var remainingBytes = sectionSizeInBytes - _u4.nextIndex;\n            eatBytes(remainingBytes); // eat the entire section\n          } else {\n            parseCodeSection(numberOfFuncs);\n          }\n\n          var _nodes5 = [];\n          return {\n            nodes: _nodes5,\n            metadata: _metadata5,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.start:\n        {\n          dumpSep(\"section Start\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _metadata6 = t.sectionMetadata(\"start\", startOffset, sectionSizeInBytesNode);\n\n          var _nodes6 = [parseStartSection()];\n          return {\n            nodes: _nodes6,\n            metadata: _metadata6,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.element:\n        {\n          dumpSep(\"section Element\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc19 = getPosition();\n\n          var numberOfElementsu32 = readU32();\n          var numberOfElements = numberOfElementsu32.value;\n          eatBytes(numberOfElementsu32.nextIndex);\n\n          var _metadata7 = t.sectionMetadata(\"element\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfElements), endLoc, _startLoc19);\n          }());\n\n          var _nodes7 = parseElemSection(numberOfElements);\n\n          return {\n            nodes: _nodes7,\n            metadata: _metadata7,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.global:\n        {\n          dumpSep(\"section Global\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc20 = getPosition();\n\n          var numberOfGlobalsu32 = readU32();\n          var numberOfGlobals = numberOfGlobalsu32.value;\n          eatBytes(numberOfGlobalsu32.nextIndex);\n\n          var _metadata8 = t.sectionMetadata(\"global\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfGlobals), endLoc, _startLoc20);\n          }());\n\n          var _nodes8 = parseGlobalSection(numberOfGlobals);\n\n          return {\n            nodes: _nodes8,\n            metadata: _metadata8,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.memory:\n        {\n          dumpSep(\"section Memory\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc21 = getPosition();\n\n          var _numberOfElementsu = readU32();\n\n          var _numberOfElements = _numberOfElementsu.value;\n          eatBytes(_numberOfElementsu.nextIndex);\n\n          var _metadata9 = t.sectionMetadata(\"memory\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(_numberOfElements), endLoc, _startLoc21);\n          }());\n\n          var _nodes9 = parseMemorySection(_numberOfElements);\n\n          return {\n            nodes: _nodes9,\n            metadata: _metadata9,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.data:\n        {\n          dumpSep(\"section Data\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _metadata10 = t.sectionMetadata(\"data\", startOffset, sectionSizeInBytesNode);\n\n          var _startLoc22 = getPosition();\n\n          var _numberOfElementsu2 = readU32();\n\n          var _numberOfElements2 = _numberOfElementsu2.value;\n          eatBytes(_numberOfElementsu2.nextIndex);\n\n          _metadata10.vectorOfSize = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(_numberOfElements2), endLoc, _startLoc22);\n          }();\n\n          if (opts.ignoreDataSection === true) {\n            var _remainingBytes = sectionSizeInBytes - _numberOfElementsu2.nextIndex;\n\n            eatBytes(_remainingBytes); // eat the entire section\n\n            dumpSep(\"ignore data (\" + sectionSizeInBytes + \" bytes)\");\n            return {\n              nodes: [],\n              metadata: _metadata10,\n              nextSectionIndex: nextSectionIndex\n            };\n          } else {\n            var _nodes10 = parseDataSection(_numberOfElements2);\n\n            return {\n              nodes: _nodes10,\n              metadata: _metadata10,\n              nextSectionIndex: nextSectionIndex\n            };\n          }\n        }\n\n      case constants.sections.custom:\n        {\n          dumpSep(\"section Custom\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _metadata11 = [t.sectionMetadata(\"custom\", startOffset, sectionSizeInBytesNode)];\n          var sectionName = readUTF8String();\n          eatBytes(sectionName.nextIndex);\n          dump([], \"section name (\".concat(sectionName.value, \")\"));\n\n          var _remainingBytes2 = sectionSizeInBytes - sectionName.nextIndex;\n\n          if (sectionName.value === \"name\") {\n            var initialOffset = offset;\n\n            try {\n              _metadata11.push.apply(_metadata11, _toConsumableArray(parseNameSection(_remainingBytes2)));\n            } catch (e) {\n              console.warn(\"Failed to decode custom \\\"name\\\" section @\".concat(offset, \"; ignoring (\").concat(e.message, \").\"));\n              eatBytes(offset - (initialOffset + _remainingBytes2));\n            }\n          } else if (sectionName.value === \"producers\") {\n            var _initialOffset = offset;\n\n            try {\n              _metadata11.push(parseProducersSection());\n            } catch (e) {\n              console.warn(\"Failed to decode custom \\\"producers\\\" section @\".concat(offset, \"; ignoring (\").concat(e.message, \").\"));\n              eatBytes(offset - (_initialOffset + _remainingBytes2));\n            }\n          } else {\n            // We don't parse the custom section\n            eatBytes(_remainingBytes2);\n            dumpSep(\"ignore custom \" + JSON.stringify(sectionName.value) + \" section (\" + _remainingBytes2 + \" bytes)\");\n          }\n\n          return {\n            nodes: [],\n            metadata: _metadata11,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n    }\n\n    if (opts.errorOnUnknownSection) {\n      throw new CompileError(\"Unexpected section: \" + toHex(sectionId));\n    } else {\n      dumpSep(\"section \" + toHex(sectionId));\n      dump([sectionId], \"section code\");\n      dump([sectionSizeInBytes], \"section size\");\n      eatBytes(sectionSizeInBytes);\n      dumpSep(\"ignoring (\" + sectionSizeInBytes + \" bytes)\");\n      return {\n        nodes: [],\n        metadata: [],\n        nextSectionIndex: 0\n      };\n    }\n  }\n\n  function parseBlockType() {\n    var blocktypeByte = readByte();\n    var blocktype = constants.blockTypes[blocktypeByte];\n\n    if (typeof blocktype !== \"undefined\") {\n      eatBytes(1);\n      dump([blocktypeByte], \"blocktype\"); // value type\n\n      return blocktype;\n    } else {\n      // type index\n      var u32 = readU32();\n      eatBytes(u32.nextIndex);\n      var signature = state.typesInModule[u32.value];\n      console.log({\n        signature: signature\n      });\n      dump([u32.value], \"typeidx\");\n      return u32.value;\n    }\n  }\n\n  parseModuleHeader();\n  parseVersion();\n  var moduleFields = [];\n  var sectionIndex = 0;\n  var moduleMetadata = {\n    sections: [],\n    functionNames: [],\n    localNames: [],\n    producers: []\n  };\n  /**\n   * All the generate declaration are going to be stored in our state\n   */\n\n  while (offset < buf.length) {\n    var _parseSection = parseSection(sectionIndex),\n        nodes = _parseSection.nodes,\n        metadata = _parseSection.metadata,\n        nextSectionIndex = _parseSection.nextSectionIndex;\n\n    moduleFields.push.apply(moduleFields, _toConsumableArray(nodes));\n    var metadataArray = Array.isArray(metadata) ? metadata : [metadata];\n    metadataArray.forEach(function (metadataItem) {\n      // $FlowIgnore\n      if (metadataItem.type === \"FunctionNameMetadata\") {\n        moduleMetadata.functionNames.push(metadataItem); // $FlowIgnore\n      } else if (metadataItem.type === \"LocalNameMetadata\") {\n        moduleMetadata.localNames.push(metadataItem); // $FlowIgnore\n      } else if (metadataItem.type === \"ProducersSectionMetadata\") {\n        moduleMetadata.producers.push(metadataItem);\n      } else {\n        moduleMetadata.sections.push(metadataItem);\n      }\n    }); // Ignore custom section\n\n    if (nextSectionIndex) {\n      sectionIndex = nextSectionIndex;\n    }\n  }\n  /**\n   * Transform the state into AST nodes\n   */\n\n\n  var funcIndex = 0;\n  state.functionsInModule.forEach(function (func) {\n    var params = func.signature.params;\n    var result = func.signature.result;\n    var body = []; // External functions doesn't provide any code, can skip it here\n\n    if (func.isExternal === true) {\n      return;\n    }\n\n    var decodedElementInCodeSection = state.elementsInCodeSection[funcIndex];\n\n    if (opts.ignoreCodeSection === false) {\n      if (typeof decodedElementInCodeSection === \"undefined\") {\n        throw new CompileError(\"func \" + toHex(funcIndex) + \" code not found\");\n      }\n\n      body = decodedElementInCodeSection.code;\n    }\n\n    funcIndex++;\n    var funcNode = t.func(func.id, t.signature(params, result), body);\n\n    if (func.isExternal === true) {\n      funcNode.isExternal = func.isExternal;\n    } // Add function position in the binary if possible\n\n\n    if (opts.ignoreCodeSection === false) {\n      var _startLoc23 = decodedElementInCodeSection.startLoc,\n          endLoc = decodedElementInCodeSection.endLoc,\n          bodySize = decodedElementInCodeSection.bodySize;\n      funcNode = t.withLoc(funcNode, endLoc, _startLoc23);\n      funcNode.metadata = {\n        bodySize: bodySize\n      };\n    }\n\n    moduleFields.push(funcNode);\n  });\n  state.elementsInExportSection.forEach(function (moduleExport) {\n    /**\n     * If the export has no id, we won't be able to call it from the outside\n     * so we can omit it\n     */\n    if (moduleExport.id != null) {\n      moduleFields.push(t.withLoc(t.moduleExport(moduleExport.name, t.moduleExportDescr(moduleExport.type, moduleExport.id)), moduleExport.endLoc, moduleExport.startLoc));\n    }\n  });\n  dumpSep(\"end of program\");\n  var module = t.module(null, moduleFields, t.moduleMetadata(moduleMetadata.sections, moduleMetadata.functionNames, moduleMetadata.localNames, moduleMetadata.producers));\n  return t.program([module]);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}