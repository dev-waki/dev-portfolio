{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  SyncHook,\n  AsyncSeriesHook\n} = require(\"tapable\");\nconst {\n  makeWebpackError\n} = require(\"../HookWebpackError\");\nconst WebpackError = require(\"../WebpackError\");\nconst ArrayQueue = require(\"./ArrayQueue\");\nconst QUEUED_STATE = 0;\nconst PROCESSING_STATE = 1;\nconst DONE_STATE = 2;\nlet inHandleResult = 0;\n\n/**\n * @template T\n * @callback Callback\n * @param {(WebpackError | null)=} err\n * @param {(T | null)=} result\n */\n\n/**\n * @template T\n * @template K\n * @template R\n */\nclass AsyncQueueEntry {\n  /**\n   * @param {T} item the item\n   * @param {Callback<R>} callback the callback\n   */\n  constructor(item, callback) {\n    this.item = item;\n    /** @type {typeof QUEUED_STATE | typeof PROCESSING_STATE | typeof DONE_STATE} */\n    this.state = QUEUED_STATE;\n    /** @type {Callback<R> | undefined} */\n    this.callback = callback;\n    /** @type {Callback<R>[] | undefined} */\n    this.callbacks = undefined;\n    /** @type {R | null | undefined} */\n    this.result = undefined;\n    /** @type {WebpackError | null | undefined} */\n    this.error = undefined;\n  }\n}\n\n/**\n * @template T, K\n * @typedef {function(T): K} getKey\n */\n\n/**\n * @template T, R\n * @typedef {function(T, Callback<R>): void} Processor\n */\n\n/**\n * @template T\n * @template K\n * @template R\n */\nclass AsyncQueue {\n  /**\n   * @param {object} options options object\n   * @param {string=} options.name name of the queue\n   * @param {number=} options.parallelism how many items should be processed at once\n   * @param {string=} options.context context of execution\n   * @param {AsyncQueue<any, any, any>=} options.parent parent queue, which will have priority over this queue and with shared parallelism\n   * @param {getKey<T, K>=} options.getKey extract key from item\n   * @param {Processor<T, R>} options.processor async function to process items\n   */\n  constructor({\n    name,\n    context,\n    parallelism,\n    parent,\n    processor,\n    getKey\n  }) {\n    this._name = name;\n    this._context = context || \"normal\";\n    this._parallelism = parallelism || 1;\n    this._processor = processor;\n    this._getKey = getKey || (/** @type {getKey<T, K>} */item => (/** @type {T & K} */item));\n    /** @type {Map<K, AsyncQueueEntry<T, K, R>>} */\n    this._entries = new Map();\n    /** @type {ArrayQueue<AsyncQueueEntry<T, K, R>>} */\n    this._queued = new ArrayQueue();\n    /** @type {AsyncQueue<any, any, any>[] | undefined} */\n    this._children = undefined;\n    this._activeTasks = 0;\n    this._willEnsureProcessing = false;\n    this._needProcessing = false;\n    this._stopped = false;\n    /** @type {AsyncQueue<any, any, any>} */\n    this._root = parent ? parent._root : this;\n    if (parent) {\n      if (this._root._children === undefined) {\n        this._root._children = [this];\n      } else {\n        this._root._children.push(this);\n      }\n    }\n    this.hooks = {\n      /** @type {AsyncSeriesHook<[T]>} */\n      beforeAdd: new AsyncSeriesHook([\"item\"]),\n      /** @type {SyncHook<[T]>} */\n      added: new SyncHook([\"item\"]),\n      /** @type {AsyncSeriesHook<[T]>} */\n      beforeStart: new AsyncSeriesHook([\"item\"]),\n      /** @type {SyncHook<[T]>} */\n      started: new SyncHook([\"item\"]),\n      /** @type {SyncHook<[T, WebpackError | null | undefined, R | null | undefined]>} */\n      result: new SyncHook([\"item\", \"error\", \"result\"])\n    };\n    this._ensureProcessing = this._ensureProcessing.bind(this);\n  }\n\n  /**\n   * @returns {string} context of execution\n   */\n  getContext() {\n    return this._context;\n  }\n\n  /**\n   * @param {string} value context of execution\n   */\n  setContext(value) {\n    this._context = value;\n  }\n\n  /**\n   * @param {T} item an item\n   * @param {Callback<R>} callback callback function\n   * @returns {void}\n   */\n  add(item, callback) {\n    if (this._stopped) return callback(new WebpackError(\"Queue was stopped\"));\n    this.hooks.beforeAdd.callAsync(item, err => {\n      if (err) {\n        callback(makeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeAdd`));\n        return;\n      }\n      const key = this._getKey(item);\n      const entry = this._entries.get(key);\n      if (entry !== undefined) {\n        if (entry.state === DONE_STATE) {\n          if (inHandleResult++ > 3) {\n            process.nextTick(() => callback(entry.error, entry.result));\n          } else {\n            callback(entry.error, entry.result);\n          }\n          inHandleResult--;\n        } else if (entry.callbacks === undefined) {\n          entry.callbacks = [callback];\n        } else {\n          entry.callbacks.push(callback);\n        }\n        return;\n      }\n      const newEntry = new AsyncQueueEntry(item, callback);\n      if (this._stopped) {\n        this.hooks.added.call(item);\n        this._root._activeTasks++;\n        process.nextTick(() => this._handleResult(newEntry, new WebpackError(\"Queue was stopped\")));\n      } else {\n        this._entries.set(key, newEntry);\n        this._queued.enqueue(newEntry);\n        const root = this._root;\n        root._needProcessing = true;\n        if (root._willEnsureProcessing === false) {\n          root._willEnsureProcessing = true;\n          setImmediate(root._ensureProcessing);\n        }\n        this.hooks.added.call(item);\n      }\n    });\n  }\n\n  /**\n   * @param {T} item an item\n   * @returns {void}\n   */\n  invalidate(item) {\n    const key = this._getKey(item);\n    const entry = /** @type {AsyncQueueEntry<T, K, R>} */\n    this._entries.get(key);\n    this._entries.delete(key);\n    if (entry.state === QUEUED_STATE) {\n      this._queued.delete(entry);\n    }\n  }\n\n  /**\n   * Waits for an already started item\n   * @param {T} item an item\n   * @param {Callback<R>} callback callback function\n   * @returns {void}\n   */\n  waitFor(item, callback) {\n    const key = this._getKey(item);\n    const entry = this._entries.get(key);\n    if (entry === undefined) {\n      return callback(new WebpackError(\"waitFor can only be called for an already started item\"));\n    }\n    if (entry.state === DONE_STATE) {\n      process.nextTick(() => callback(entry.error, entry.result));\n    } else if (entry.callbacks === undefined) {\n      entry.callbacks = [callback];\n    } else {\n      entry.callbacks.push(callback);\n    }\n  }\n\n  /**\n   * @returns {void}\n   */\n  stop() {\n    this._stopped = true;\n    const queue = this._queued;\n    this._queued = new ArrayQueue();\n    const root = this._root;\n    for (const entry of queue) {\n      this._entries.delete(this._getKey(/** @type {AsyncQueueEntry<T, K, R>} */entry.item));\n      root._activeTasks++;\n      this._handleResult(/** @type {AsyncQueueEntry<T, K, R>} */entry, new WebpackError(\"Queue was stopped\"));\n    }\n  }\n\n  /**\n   * @returns {void}\n   */\n  increaseParallelism() {\n    const root = this._root;\n    root._parallelism++;\n    /* istanbul ignore next */\n    if (root._willEnsureProcessing === false && root._needProcessing) {\n      root._willEnsureProcessing = true;\n      setImmediate(root._ensureProcessing);\n    }\n  }\n\n  /**\n   * @returns {void}\n   */\n  decreaseParallelism() {\n    const root = this._root;\n    root._parallelism--;\n  }\n\n  /**\n   * @param {T} item an item\n   * @returns {boolean} true, if the item is currently being processed\n   */\n  isProcessing(item) {\n    const key = this._getKey(item);\n    const entry = this._entries.get(key);\n    return entry !== undefined && entry.state === PROCESSING_STATE;\n  }\n\n  /**\n   * @param {T} item an item\n   * @returns {boolean} true, if the item is currently queued\n   */\n  isQueued(item) {\n    const key = this._getKey(item);\n    const entry = this._entries.get(key);\n    return entry !== undefined && entry.state === QUEUED_STATE;\n  }\n\n  /**\n   * @param {T} item an item\n   * @returns {boolean} true, if the item is currently queued\n   */\n  isDone(item) {\n    const key = this._getKey(item);\n    const entry = this._entries.get(key);\n    return entry !== undefined && entry.state === DONE_STATE;\n  }\n\n  /**\n   * @returns {void}\n   */\n  _ensureProcessing() {\n    while (this._activeTasks < this._parallelism) {\n      const entry = this._queued.dequeue();\n      if (entry === undefined) break;\n      this._activeTasks++;\n      entry.state = PROCESSING_STATE;\n      this._startProcessing(entry);\n    }\n    this._willEnsureProcessing = false;\n    if (this._queued.length > 0) return;\n    if (this._children !== undefined) {\n      for (const child of this._children) {\n        while (this._activeTasks < this._parallelism) {\n          const entry = child._queued.dequeue();\n          if (entry === undefined) break;\n          this._activeTasks++;\n          entry.state = PROCESSING_STATE;\n          child._startProcessing(entry);\n        }\n        if (child._queued.length > 0) return;\n      }\n    }\n    if (!this._willEnsureProcessing) this._needProcessing = false;\n  }\n\n  /**\n   * @param {AsyncQueueEntry<T, K, R>} entry the entry\n   * @returns {void}\n   */\n  _startProcessing(entry) {\n    this.hooks.beforeStart.callAsync(entry.item, err => {\n      if (err) {\n        this._handleResult(entry, makeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeStart`));\n        return;\n      }\n      let inCallback = false;\n      try {\n        this._processor(entry.item, (e, r) => {\n          inCallback = true;\n          this._handleResult(entry, e, r);\n        });\n      } catch (err) {\n        if (inCallback) throw err;\n        this._handleResult(entry, /** @type {WebpackError} */err, null);\n      }\n      this.hooks.started.call(entry.item);\n    });\n  }\n\n  /**\n   * @param {AsyncQueueEntry<T, K, R>} entry the entry\n   * @param {(WebpackError | null)=} err error, if any\n   * @param {(R | null)=} result result, if any\n   * @returns {void}\n   */\n  _handleResult(entry, err, result) {\n    this.hooks.result.callAsync(entry.item, err, result, hookError => {\n      const error = hookError ? makeWebpackError(hookError, `AsyncQueue(${this._name}).hooks.result`) : err;\n      const callback = /** @type {Callback<R>} */entry.callback;\n      const callbacks = entry.callbacks;\n      entry.state = DONE_STATE;\n      entry.callback = undefined;\n      entry.callbacks = undefined;\n      entry.result = result;\n      entry.error = error;\n      const root = this._root;\n      root._activeTasks--;\n      if (root._willEnsureProcessing === false && root._needProcessing) {\n        root._willEnsureProcessing = true;\n        setImmediate(root._ensureProcessing);\n      }\n      if (inHandleResult++ > 3) {\n        process.nextTick(() => {\n          callback(error, result);\n          if (callbacks !== undefined) {\n            for (const callback of callbacks) {\n              callback(error, result);\n            }\n          }\n        });\n      } else {\n        callback(error, result);\n        if (callbacks !== undefined) {\n          for (const callback of callbacks) {\n            callback(error, result);\n          }\n        }\n      }\n      inHandleResult--;\n    });\n  }\n  clear() {\n    this._entries.clear();\n    this._queued.clear();\n    this._activeTasks = 0;\n    this._willEnsureProcessing = false;\n    this._needProcessing = false;\n    this._stopped = false;\n  }\n}\nmodule.exports = AsyncQueue;","map":{"version":3,"names":["SyncHook","AsyncSeriesHook","require","makeWebpackError","WebpackError","ArrayQueue","QUEUED_STATE","PROCESSING_STATE","DONE_STATE","inHandleResult","AsyncQueueEntry","constructor","item","callback","state","callbacks","undefined","result","error","AsyncQueue","name","context","parallelism","parent","processor","getKey","_name","_context","_parallelism","_processor","_getKey","_entries","Map","_queued","_children","_activeTasks","_willEnsureProcessing","_needProcessing","_stopped","_root","push","hooks","beforeAdd","added","beforeStart","started","_ensureProcessing","bind","getContext","setContext","value","add","callAsync","err","key","entry","get","process","nextTick","newEntry","call","_handleResult","set","enqueue","root","setImmediate","invalidate","delete","waitFor","stop","queue","increaseParallelism","decreaseParallelism","isProcessing","isQueued","isDone","dequeue","_startProcessing","length","child","inCallback","e","r","hookError","clear","module","exports"],"sources":["/home/wickliff/Desktop/dev-waki/portfolio2/node_modules/webpack/lib/util/AsyncQueue.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { SyncHook, AsyncSeriesHook } = require(\"tapable\");\nconst { makeWebpackError } = require(\"../HookWebpackError\");\nconst WebpackError = require(\"../WebpackError\");\nconst ArrayQueue = require(\"./ArrayQueue\");\n\nconst QUEUED_STATE = 0;\nconst PROCESSING_STATE = 1;\nconst DONE_STATE = 2;\n\nlet inHandleResult = 0;\n\n/**\n * @template T\n * @callback Callback\n * @param {(WebpackError | null)=} err\n * @param {(T | null)=} result\n */\n\n/**\n * @template T\n * @template K\n * @template R\n */\nclass AsyncQueueEntry {\n\t/**\n\t * @param {T} item the item\n\t * @param {Callback<R>} callback the callback\n\t */\n\tconstructor(item, callback) {\n\t\tthis.item = item;\n\t\t/** @type {typeof QUEUED_STATE | typeof PROCESSING_STATE | typeof DONE_STATE} */\n\t\tthis.state = QUEUED_STATE;\n\t\t/** @type {Callback<R> | undefined} */\n\t\tthis.callback = callback;\n\t\t/** @type {Callback<R>[] | undefined} */\n\t\tthis.callbacks = undefined;\n\t\t/** @type {R | null | undefined} */\n\t\tthis.result = undefined;\n\t\t/** @type {WebpackError | null | undefined} */\n\t\tthis.error = undefined;\n\t}\n}\n\n/**\n * @template T, K\n * @typedef {function(T): K} getKey\n */\n\n/**\n * @template T, R\n * @typedef {function(T, Callback<R>): void} Processor\n */\n\n/**\n * @template T\n * @template K\n * @template R\n */\nclass AsyncQueue {\n\t/**\n\t * @param {object} options options object\n\t * @param {string=} options.name name of the queue\n\t * @param {number=} options.parallelism how many items should be processed at once\n\t * @param {string=} options.context context of execution\n\t * @param {AsyncQueue<any, any, any>=} options.parent parent queue, which will have priority over this queue and with shared parallelism\n\t * @param {getKey<T, K>=} options.getKey extract key from item\n\t * @param {Processor<T, R>} options.processor async function to process items\n\t */\n\tconstructor({ name, context, parallelism, parent, processor, getKey }) {\n\t\tthis._name = name;\n\t\tthis._context = context || \"normal\";\n\t\tthis._parallelism = parallelism || 1;\n\t\tthis._processor = processor;\n\t\tthis._getKey =\n\t\t\tgetKey ||\n\t\t\t/** @type {getKey<T, K>} */ (item => /** @type {T & K} */ (item));\n\t\t/** @type {Map<K, AsyncQueueEntry<T, K, R>>} */\n\t\tthis._entries = new Map();\n\t\t/** @type {ArrayQueue<AsyncQueueEntry<T, K, R>>} */\n\t\tthis._queued = new ArrayQueue();\n\t\t/** @type {AsyncQueue<any, any, any>[] | undefined} */\n\t\tthis._children = undefined;\n\t\tthis._activeTasks = 0;\n\t\tthis._willEnsureProcessing = false;\n\t\tthis._needProcessing = false;\n\t\tthis._stopped = false;\n\t\t/** @type {AsyncQueue<any, any, any>} */\n\t\tthis._root = parent ? parent._root : this;\n\t\tif (parent) {\n\t\t\tif (this._root._children === undefined) {\n\t\t\t\tthis._root._children = [this];\n\t\t\t} else {\n\t\t\t\tthis._root._children.push(this);\n\t\t\t}\n\t\t}\n\n\t\tthis.hooks = {\n\t\t\t/** @type {AsyncSeriesHook<[T]>} */\n\t\t\tbeforeAdd: new AsyncSeriesHook([\"item\"]),\n\t\t\t/** @type {SyncHook<[T]>} */\n\t\t\tadded: new SyncHook([\"item\"]),\n\t\t\t/** @type {AsyncSeriesHook<[T]>} */\n\t\t\tbeforeStart: new AsyncSeriesHook([\"item\"]),\n\t\t\t/** @type {SyncHook<[T]>} */\n\t\t\tstarted: new SyncHook([\"item\"]),\n\t\t\t/** @type {SyncHook<[T, WebpackError | null | undefined, R | null | undefined]>} */\n\t\t\tresult: new SyncHook([\"item\", \"error\", \"result\"])\n\t\t};\n\n\t\tthis._ensureProcessing = this._ensureProcessing.bind(this);\n\t}\n\n\t/**\n\t * @returns {string} context of execution\n\t */\n\tgetContext() {\n\t\treturn this._context;\n\t}\n\n\t/**\n\t * @param {string} value context of execution\n\t */\n\tsetContext(value) {\n\t\tthis._context = value;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @param {Callback<R>} callback callback function\n\t * @returns {void}\n\t */\n\tadd(item, callback) {\n\t\tif (this._stopped) return callback(new WebpackError(\"Queue was stopped\"));\n\t\tthis.hooks.beforeAdd.callAsync(item, err => {\n\t\t\tif (err) {\n\t\t\t\tcallback(\n\t\t\t\t\tmakeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeAdd`)\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst key = this._getKey(item);\n\t\t\tconst entry = this._entries.get(key);\n\t\t\tif (entry !== undefined) {\n\t\t\t\tif (entry.state === DONE_STATE) {\n\t\t\t\t\tif (inHandleResult++ > 3) {\n\t\t\t\t\t\tprocess.nextTick(() => callback(entry.error, entry.result));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback(entry.error, entry.result);\n\t\t\t\t\t}\n\t\t\t\t\tinHandleResult--;\n\t\t\t\t} else if (entry.callbacks === undefined) {\n\t\t\t\t\tentry.callbacks = [callback];\n\t\t\t\t} else {\n\t\t\t\t\tentry.callbacks.push(callback);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst newEntry = new AsyncQueueEntry(item, callback);\n\t\t\tif (this._stopped) {\n\t\t\t\tthis.hooks.added.call(item);\n\t\t\t\tthis._root._activeTasks++;\n\t\t\t\tprocess.nextTick(() =>\n\t\t\t\t\tthis._handleResult(newEntry, new WebpackError(\"Queue was stopped\"))\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis._entries.set(key, newEntry);\n\t\t\t\tthis._queued.enqueue(newEntry);\n\t\t\t\tconst root = this._root;\n\t\t\t\troot._needProcessing = true;\n\t\t\t\tif (root._willEnsureProcessing === false) {\n\t\t\t\t\troot._willEnsureProcessing = true;\n\t\t\t\t\tsetImmediate(root._ensureProcessing);\n\t\t\t\t}\n\t\t\t\tthis.hooks.added.call(item);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {void}\n\t */\n\tinvalidate(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry =\n\t\t\t/** @type {AsyncQueueEntry<T, K, R>} */\n\t\t\t(this._entries.get(key));\n\t\tthis._entries.delete(key);\n\t\tif (entry.state === QUEUED_STATE) {\n\t\t\tthis._queued.delete(entry);\n\t\t}\n\t}\n\n\t/**\n\t * Waits for an already started item\n\t * @param {T} item an item\n\t * @param {Callback<R>} callback callback function\n\t * @returns {void}\n\t */\n\twaitFor(item, callback) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\tif (entry === undefined) {\n\t\t\treturn callback(\n\t\t\t\tnew WebpackError(\n\t\t\t\t\t\"waitFor can only be called for an already started item\"\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\tif (entry.state === DONE_STATE) {\n\t\t\tprocess.nextTick(() => callback(entry.error, entry.result));\n\t\t} else if (entry.callbacks === undefined) {\n\t\t\tentry.callbacks = [callback];\n\t\t} else {\n\t\t\tentry.callbacks.push(callback);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tstop() {\n\t\tthis._stopped = true;\n\t\tconst queue = this._queued;\n\t\tthis._queued = new ArrayQueue();\n\t\tconst root = this._root;\n\t\tfor (const entry of queue) {\n\t\t\tthis._entries.delete(\n\t\t\t\tthis._getKey(/** @type {AsyncQueueEntry<T, K, R>} */ (entry).item)\n\t\t\t);\n\t\t\troot._activeTasks++;\n\t\t\tthis._handleResult(\n\t\t\t\t/** @type {AsyncQueueEntry<T, K, R>} */ (entry),\n\t\t\t\tnew WebpackError(\"Queue was stopped\")\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tincreaseParallelism() {\n\t\tconst root = this._root;\n\t\troot._parallelism++;\n\t\t/* istanbul ignore next */\n\t\tif (root._willEnsureProcessing === false && root._needProcessing) {\n\t\t\troot._willEnsureProcessing = true;\n\t\t\tsetImmediate(root._ensureProcessing);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tdecreaseParallelism() {\n\t\tconst root = this._root;\n\t\troot._parallelism--;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {boolean} true, if the item is currently being processed\n\t */\n\tisProcessing(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\treturn entry !== undefined && entry.state === PROCESSING_STATE;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {boolean} true, if the item is currently queued\n\t */\n\tisQueued(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\treturn entry !== undefined && entry.state === QUEUED_STATE;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {boolean} true, if the item is currently queued\n\t */\n\tisDone(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\treturn entry !== undefined && entry.state === DONE_STATE;\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\t_ensureProcessing() {\n\t\twhile (this._activeTasks < this._parallelism) {\n\t\t\tconst entry = this._queued.dequeue();\n\t\t\tif (entry === undefined) break;\n\t\t\tthis._activeTasks++;\n\t\t\tentry.state = PROCESSING_STATE;\n\t\t\tthis._startProcessing(entry);\n\t\t}\n\t\tthis._willEnsureProcessing = false;\n\t\tif (this._queued.length > 0) return;\n\t\tif (this._children !== undefined) {\n\t\t\tfor (const child of this._children) {\n\t\t\t\twhile (this._activeTasks < this._parallelism) {\n\t\t\t\t\tconst entry = child._queued.dequeue();\n\t\t\t\t\tif (entry === undefined) break;\n\t\t\t\t\tthis._activeTasks++;\n\t\t\t\t\tentry.state = PROCESSING_STATE;\n\t\t\t\t\tchild._startProcessing(entry);\n\t\t\t\t}\n\t\t\t\tif (child._queued.length > 0) return;\n\t\t\t}\n\t\t}\n\t\tif (!this._willEnsureProcessing) this._needProcessing = false;\n\t}\n\n\t/**\n\t * @param {AsyncQueueEntry<T, K, R>} entry the entry\n\t * @returns {void}\n\t */\n\t_startProcessing(entry) {\n\t\tthis.hooks.beforeStart.callAsync(entry.item, err => {\n\t\t\tif (err) {\n\t\t\t\tthis._handleResult(\n\t\t\t\t\tentry,\n\t\t\t\t\tmakeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeStart`)\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet inCallback = false;\n\t\t\ttry {\n\t\t\t\tthis._processor(entry.item, (e, r) => {\n\t\t\t\t\tinCallback = true;\n\t\t\t\t\tthis._handleResult(entry, e, r);\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\tif (inCallback) throw err;\n\t\t\t\tthis._handleResult(entry, /** @type {WebpackError} */ (err), null);\n\t\t\t}\n\t\t\tthis.hooks.started.call(entry.item);\n\t\t});\n\t}\n\n\t/**\n\t * @param {AsyncQueueEntry<T, K, R>} entry the entry\n\t * @param {(WebpackError | null)=} err error, if any\n\t * @param {(R | null)=} result result, if any\n\t * @returns {void}\n\t */\n\t_handleResult(entry, err, result) {\n\t\tthis.hooks.result.callAsync(entry.item, err, result, hookError => {\n\t\t\tconst error = hookError\n\t\t\t\t? makeWebpackError(hookError, `AsyncQueue(${this._name}).hooks.result`)\n\t\t\t\t: err;\n\n\t\t\tconst callback = /** @type {Callback<R>} */ (entry.callback);\n\t\t\tconst callbacks = entry.callbacks;\n\t\t\tentry.state = DONE_STATE;\n\t\t\tentry.callback = undefined;\n\t\t\tentry.callbacks = undefined;\n\t\t\tentry.result = result;\n\t\t\tentry.error = error;\n\n\t\t\tconst root = this._root;\n\t\t\troot._activeTasks--;\n\t\t\tif (root._willEnsureProcessing === false && root._needProcessing) {\n\t\t\t\troot._willEnsureProcessing = true;\n\t\t\t\tsetImmediate(root._ensureProcessing);\n\t\t\t}\n\n\t\t\tif (inHandleResult++ > 3) {\n\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\tcallback(error, result);\n\t\t\t\t\tif (callbacks !== undefined) {\n\t\t\t\t\t\tfor (const callback of callbacks) {\n\t\t\t\t\t\t\tcallback(error, result);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcallback(error, result);\n\t\t\t\tif (callbacks !== undefined) {\n\t\t\t\t\tfor (const callback of callbacks) {\n\t\t\t\t\t\tcallback(error, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tinHandleResult--;\n\t\t});\n\t}\n\n\tclear() {\n\t\tthis._entries.clear();\n\t\tthis._queued.clear();\n\t\tthis._activeTasks = 0;\n\t\tthis._willEnsureProcessing = false;\n\t\tthis._needProcessing = false;\n\t\tthis._stopped = false;\n\t}\n}\n\nmodule.exports = AsyncQueue;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}