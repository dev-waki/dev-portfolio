{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/**\n * @typedef {object} CssTokenCallbacks\n * @property {(function(string, number, number, number, number): number)=} url\n * @property {(function(string, number, number): number)=} comment\n * @property {(function(string, number, number): number)=} string\n * @property {(function(string, number, number): number)=} leftParenthesis\n * @property {(function(string, number, number): number)=} rightParenthesis\n * @property {(function(string, number, number): number)=} function\n * @property {(function(string, number, number): number)=} colon\n * @property {(function(string, number, number): number)=} atKeyword\n * @property {(function(string, number, number): number)=} delim\n * @property {(function(string, number, number): number)=} identifier\n * @property {(function(string, number, number, boolean): number)=} hash\n * @property {(function(string, number, number): number)=} leftCurlyBracket\n * @property {(function(string, number, number): number)=} rightCurlyBracket\n * @property {(function(string, number, number): number)=} semicolon\n * @property {(function(string, number, number): number)=} comma\n */\n\n/** @typedef {function(string, number, CssTokenCallbacks): number} CharHandler */\n\n// spec: https://drafts.csswg.org/css-syntax/\nconst CC_LINE_FEED = \"\\n\".charCodeAt(0);\nconst CC_CARRIAGE_RETURN = \"\\r\".charCodeAt(0);\nconst CC_FORM_FEED = \"\\f\".charCodeAt(0);\nconst CC_TAB = \"\\t\".charCodeAt(0);\nconst CC_SPACE = \" \".charCodeAt(0);\nconst CC_SOLIDUS = \"/\".charCodeAt(0);\nconst CC_REVERSE_SOLIDUS = \"\\\\\".charCodeAt(0);\nconst CC_ASTERISK = \"*\".charCodeAt(0);\nconst CC_LEFT_PARENTHESIS = \"(\".charCodeAt(0);\nconst CC_RIGHT_PARENTHESIS = \")\".charCodeAt(0);\nconst CC_LEFT_CURLY = \"{\".charCodeAt(0);\nconst CC_RIGHT_CURLY = \"}\".charCodeAt(0);\nconst CC_LEFT_SQUARE = \"[\".charCodeAt(0);\nconst CC_RIGHT_SQUARE = \"]\".charCodeAt(0);\nconst CC_QUOTATION_MARK = '\"'.charCodeAt(0);\nconst CC_APOSTROPHE = \"'\".charCodeAt(0);\nconst CC_FULL_STOP = \".\".charCodeAt(0);\nconst CC_COLON = \":\".charCodeAt(0);\nconst CC_SEMICOLON = \";\".charCodeAt(0);\nconst CC_COMMA = \",\".charCodeAt(0);\nconst CC_PERCENTAGE = \"%\".charCodeAt(0);\nconst CC_AT_SIGN = \"@\".charCodeAt(0);\nconst CC_LOW_LINE = \"_\".charCodeAt(0);\nconst CC_LOWER_A = \"a\".charCodeAt(0);\nconst CC_LOWER_F = \"f\".charCodeAt(0);\nconst CC_LOWER_E = \"e\".charCodeAt(0);\nconst CC_LOWER_U = \"u\".charCodeAt(0);\nconst CC_LOWER_Z = \"z\".charCodeAt(0);\nconst CC_UPPER_A = \"A\".charCodeAt(0);\nconst CC_UPPER_F = \"F\".charCodeAt(0);\nconst CC_UPPER_E = \"E\".charCodeAt(0);\nconst CC_UPPER_U = \"E\".charCodeAt(0);\nconst CC_UPPER_Z = \"Z\".charCodeAt(0);\nconst CC_0 = \"0\".charCodeAt(0);\nconst CC_9 = \"9\".charCodeAt(0);\nconst CC_NUMBER_SIGN = \"#\".charCodeAt(0);\nconst CC_PLUS_SIGN = \"+\".charCodeAt(0);\nconst CC_HYPHEN_MINUS = \"-\".charCodeAt(0);\nconst CC_LESS_THAN_SIGN = \"<\".charCodeAt(0);\nconst CC_GREATER_THAN_SIGN = \">\".charCodeAt(0);\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a newline\n */\nconst _isNewLine = cc => cc === CC_LINE_FEED || cc === CC_CARRIAGE_RETURN || cc === CC_FORM_FEED;\n\n/** @type {CharHandler} */\nconst consumeSpace = (input, pos, _callbacks) => {\n  // Consume as much whitespace as possible.\n  while (_isWhiteSpace(input.charCodeAt(pos))) {\n    pos++;\n  }\n\n  // Return a <whitespace-token>.\n  return pos;\n};\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a newline\n */\nconst _isNewline = cc => cc === CC_LINE_FEED || cc === CC_CARRIAGE_RETURN || cc === CC_FORM_FEED;\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a space (U+0009 CHARACTER TABULATION or U+0020 SPACE)\n */\nconst _isSpace = cc => cc === CC_TAB || cc === CC_SPACE;\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a whitespace\n */\nconst _isWhiteSpace = cc => _isNewline(cc) || _isSpace(cc);\n\n/**\n * ident-start code point\n *\n * A letter, a non-ASCII code point, or U+005F LOW LINE (_).\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a start code point of an identifier\n */\nconst isIdentStartCodePoint = cc => cc >= CC_LOWER_A && cc <= CC_LOWER_Z || cc >= CC_UPPER_A && cc <= CC_UPPER_Z || cc === CC_LOW_LINE || cc >= 0x80;\n\n/** @type {CharHandler} */\nconst consumeDelimToken = (input, pos, _callbacks) =>\n// Return a <delim-token> with its value set to the current input code point.\npos;\n\n/** @type {CharHandler} */\nconst consumeComments = (input, pos, callbacks) => {\n  // This section describes how to consume comments from a stream of code points. It returns nothing.\n  // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),\n  // consume them and all following code points up to and including the first U+002A ASTERISK (*)\n  // followed by a U+002F SOLIDUS (/), or up to an EOF code point.\n  // Return to the start of this step.\n  while (input.charCodeAt(pos) === CC_SOLIDUS && input.charCodeAt(pos + 1) === CC_ASTERISK) {\n    const start = pos;\n    pos += 2;\n    for (;;) {\n      if (pos === input.length) {\n        // If the preceding paragraph ended by consuming an EOF code point, this is a parse error.\n        return pos;\n      }\n      if (input.charCodeAt(pos) === CC_ASTERISK && input.charCodeAt(pos + 1) === CC_SOLIDUS) {\n        pos += 2;\n        if (callbacks.comment) {\n          pos = callbacks.comment(input, start, pos);\n        }\n        break;\n      }\n      pos++;\n    }\n  }\n  return pos;\n};\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a hex digit\n */\nconst _isHexDigit = cc => _isDigit(cc) || cc >= CC_UPPER_A && cc <= CC_UPPER_F || cc >= CC_LOWER_A && cc <= CC_LOWER_F;\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position\n */\nconst _consumeAnEscapedCodePoint = (input, pos) => {\n  // This section describes how to consume an escaped code point.\n  // It assumes that the U+005C REVERSE SOLIDUS (\\) has already been consumed and that the next input code point has already been verified to be part of a valid escape.\n  // It will return a code point.\n\n  // Consume the next input code point.\n  const cc = input.charCodeAt(pos);\n  pos++;\n\n  // EOF\n  // This is a parse error. Return U+FFFD REPLACEMENT CHARACTER (�).\n  if (pos === input.length) {\n    return pos;\n  }\n\n  // hex digit\n  // Consume as many hex digits as possible, but no more than 5.\n  // Note that this means 1-6 hex digits have been consumed in total.\n  // If the next input code point is whitespace, consume it as well.\n  // Interpret the hex digits as a hexadecimal number.\n  // If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point, return U+FFFD REPLACEMENT CHARACTER (�).\n  // Otherwise, return the code point with that value.\n  if (_isHexDigit(cc)) {\n    for (let i = 0; i < 5; i++) {\n      if (_isHexDigit(input.charCodeAt(pos))) {\n        pos++;\n      }\n    }\n    if (_isWhiteSpace(input.charCodeAt(pos))) {\n      pos++;\n    }\n    return pos;\n  }\n\n  // anything else\n  // Return the current input code point.\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeAStringToken = (input, pos, callbacks) => {\n  // This section describes how to consume a string token from a stream of code points.\n  // It returns either a <string-token> or <bad-string-token>.\n  //\n  // This algorithm may be called with an ending code point, which denotes the code point that ends the string.\n  // If an ending code point is not specified, the current input code point is used.\n  const start = pos - 1;\n  const endingCodePoint = input.charCodeAt(pos - 1);\n\n  // Initially create a <string-token> with its value set to the empty string.\n\n  // Repeatedly consume the next input code point from the stream:\n  for (;;) {\n    // EOF\n    // This is a parse error. Return the <string-token>.\n    if (pos === input.length) {\n      if (callbacks.string !== undefined) {\n        return callbacks.string(input, start, pos);\n      }\n      return pos;\n    }\n    const cc = input.charCodeAt(pos);\n    pos++;\n\n    // ending code point\n    // Return the <string-token>.\n    if (cc === endingCodePoint) {\n      if (callbacks.string !== undefined) {\n        return callbacks.string(input, start, pos);\n      }\n      return pos;\n    }\n    // newline\n    // This is a parse error.\n    // Reconsume the current input code point, create a <bad-string-token>, and return it.\n    else if (_isNewLine(cc)) {\n      pos--;\n      // bad string\n      return pos;\n    }\n    // U+005C REVERSE SOLIDUS (\\)\n    else if (cc === CC_REVERSE_SOLIDUS) {\n      // If the next input code point is EOF, do nothing.\n      if (pos === input.length) {\n        return pos;\n      }\n      // Otherwise, if the next input code point is a newline, consume it.\n      else if (_isNewLine(input.charCodeAt(pos))) {\n        pos++;\n      }\n      // Otherwise, (the stream starts with a valid escape) consume an escaped code point and append the returned code point to the <string-token>’s value.\n      else if (_ifTwoCodePointsAreValidEscape(input, pos)) {\n        pos = _consumeAnEscapedCodePoint(input, pos);\n      }\n    }\n    // anything else\n    // Append the current input code point to the <string-token>’s value.\n    else {\n      // Append\n    }\n  }\n};\n\n/**\n * @param {number} cc char code\n * @param {number} q char code\n * @returns {boolean} is non-ASCII code point\n */\nconst isNonASCIICodePoint = (cc, q) =>\n// Simplify\ncc > 0x80;\n/**\n * @param {number} cc char code\n * @returns {boolean} is letter\n */\nconst isLetter = cc => cc >= CC_LOWER_A && cc <= CC_LOWER_Z || cc >= CC_UPPER_A && cc <= CC_UPPER_Z;\n\n/**\n * @param {number} cc char code\n * @param {number} q char code\n * @returns {boolean} is identifier start code\n */\nconst _isIdentStartCodePoint = (cc, q) => isLetter(cc) || isNonASCIICodePoint(cc, q) || cc === CC_LOW_LINE;\n\n/**\n * @param {number} cc char code\n * @param {number} q char code\n * @returns {boolean} is identifier code\n */\nconst _isIdentCodePoint = (cc, q) => _isIdentStartCodePoint(cc, q) || _isDigit(cc) || cc === CC_HYPHEN_MINUS;\n/**\n * @param {number} cc char code\n * @returns {boolean} is digit\n */\nconst _isDigit = cc => cc >= CC_0 && cc <= CC_9;\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @param {number=} f first code point\n * @param {number=} s second code point\n * @returns {boolean} true if two code points are a valid escape\n */\nconst _ifTwoCodePointsAreValidEscape = (input, pos, f, s) => {\n  // This section describes how to check if two code points are a valid escape.\n  // The algorithm described here can be called explicitly with two code points, or can be called with the input stream itself.\n  // In the latter case, the two code points in question are the current input code point and the next input code point, in that order.\n\n  // Note: This algorithm will not consume any additional code point.\n  const first = f || input.charCodeAt(pos - 1);\n  const second = s || input.charCodeAt(pos);\n\n  // If the first code point is not U+005C REVERSE SOLIDUS (\\), return false.\n  if (first !== CC_REVERSE_SOLIDUS) return false;\n  // Otherwise, if the second code point is a newline, return false.\n  if (_isNewLine(second)) return false;\n  // Otherwise, return true.\n  return true;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @param {number=} f first\n * @param {number=} s second\n * @param {number=} t third\n * @returns {boolean} true, if input at pos starts an identifier\n */\nconst _ifThreeCodePointsWouldStartAnIdentSequence = (input, pos, f, s, t) => {\n  // This section describes how to check if three code points would start an ident sequence.\n  // The algorithm described here can be called explicitly with three code points, or can be called with the input stream itself.\n  // In the latter case, the three code points in question are the current input code point and the next two input code points, in that order.\n\n  // Note: This algorithm will not consume any additional code points.\n\n  const first = f || input.charCodeAt(pos - 1);\n  const second = s || input.charCodeAt(pos);\n  const third = t || input.charCodeAt(pos + 1);\n\n  // Look at the first code point:\n\n  // U+002D HYPHEN-MINUS\n  if (first === CC_HYPHEN_MINUS) {\n    // If the second code point is an ident-start code point or a U+002D HYPHEN-MINUS\n    // or a U+002D HYPHEN-MINUS, or the second and third code points are a valid escape, return true.\n    if (_isIdentStartCodePoint(second, pos) || second === CC_HYPHEN_MINUS || _ifTwoCodePointsAreValidEscape(input, pos, second, third)) {\n      return true;\n    }\n    return false;\n  }\n  // ident-start code point\n  else if (_isIdentStartCodePoint(first, pos - 1)) {\n    return true;\n  }\n  // U+005C REVERSE SOLIDUS (\\)\n  // If the first and second code points are a valid escape, return true. Otherwise, return false.\n  else if (first === CC_REVERSE_SOLIDUS) {\n    if (_ifTwoCodePointsAreValidEscape(input, pos, first, second)) {\n      return true;\n    }\n    return false;\n  }\n  // anything else\n  // Return false.\n  return false;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @param {number=} f first\n * @param {number=} s second\n * @param {number=} t third\n * @returns {boolean} true, if input at pos starts an identifier\n */\nconst _ifThreeCodePointsWouldStartANumber = (input, pos, f, s, t) => {\n  // This section describes how to check if three code points would start a number.\n  // The algorithm described here can be called explicitly with three code points, or can be called with the input stream itself.\n  // In the latter case, the three code points in question are the current input code point and the next two input code points, in that order.\n\n  // Note: This algorithm will not consume any additional code points.\n\n  const first = f || input.charCodeAt(pos - 1);\n  const second = s || input.charCodeAt(pos);\n  const third = t || input.charCodeAt(pos);\n\n  // Look at the first code point:\n\n  // U+002B PLUS SIGN (+)\n  // U+002D HYPHEN-MINUS (-)\n  //\n  // If the second code point is a digit, return true.\n  // Otherwise, if the second code point is a U+002E FULL STOP (.) and the third code point is a digit, return true.\n  // Otherwise, return false.\n  if (first === CC_PLUS_SIGN || first === CC_HYPHEN_MINUS) {\n    if (_isDigit(second)) {\n      return true;\n    } else if (second === CC_FULL_STOP && _isDigit(third)) {\n      return true;\n    }\n    return false;\n  }\n  // U+002E FULL STOP (.)\n  // If the second code point is a digit, return true. Otherwise, return false.\n  else if (first === CC_FULL_STOP) {\n    if (_isDigit(second)) {\n      return true;\n    }\n    return false;\n  }\n  // digit\n  // Return true.\n  else if (_isDigit(first)) {\n    return true;\n  }\n\n  // anything else\n  // Return false.\n  return false;\n};\n\n/** @type {CharHandler} */\nconst consumeNumberSign = (input, pos, callbacks) => {\n  // If the next input code point is an ident code point or the next two input code points are a valid escape, then:\n  // - Create a <hash-token>.\n  // - If the next 3 input code points would start an ident sequence, set the <hash-token>’s type flag to \"id\".\n  // - Consume an ident sequence, and set the <hash-token>’s value to the returned string.\n  // - Return the <hash-token>.\n  const start = pos - 1;\n  const first = input.charCodeAt(pos);\n  const second = input.charCodeAt(pos + 1);\n  if (_isIdentCodePoint(first, pos - 1) || _ifTwoCodePointsAreValidEscape(input, pos, first, second)) {\n    const third = input.charCodeAt(pos + 2);\n    let isId = false;\n    if (_ifThreeCodePointsWouldStartAnIdentSequence(input, pos, first, second, third)) {\n      isId = true;\n    }\n    pos = _consumeAnIdentSequence(input, pos, callbacks);\n    if (callbacks.hash !== undefined) {\n      return callbacks.hash(input, start, pos, isId);\n    }\n    return pos;\n  }\n\n  // Otherwise, return a <delim-token> with its value set to the current input code point.\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeHyphenMinus = (input, pos, callbacks) => {\n  // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n  if (_ifThreeCodePointsWouldStartANumber(input, pos)) {\n    pos--;\n    return consumeANumericToken(input, pos, callbacks);\n  }\n  // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.\n  else if (input.charCodeAt(pos) === CC_HYPHEN_MINUS && input.charCodeAt(pos + 1) === CC_GREATER_THAN_SIGN) {\n    return pos + 2;\n  }\n  // Otherwise, if the input stream starts with an ident sequence, reconsume the current input code point, consume an ident-like token, and return it.\n  else if (_ifThreeCodePointsWouldStartAnIdentSequence(input, pos)) {\n    pos--;\n    return consumeAnIdentLikeToken(input, pos, callbacks);\n  }\n\n  // Otherwise, return a <delim-token> with its value set to the current input code point.\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeFullStop = (input, pos, callbacks) => {\n  const start = pos - 1;\n\n  // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n  if (_ifThreeCodePointsWouldStartANumber(input, pos)) {\n    pos--;\n    return consumeANumericToken(input, pos, callbacks);\n  }\n\n  // Otherwise, return a <delim-token> with its value set to the current input code point.\n  if (callbacks.delim !== undefined) {\n    return callbacks.delim(input, start, pos);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumePlusSign = (input, pos, callbacks) => {\n  // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n  if (_ifThreeCodePointsWouldStartANumber(input, pos)) {\n    pos--;\n    return consumeANumericToken(input, pos, callbacks);\n  }\n\n  // Otherwise, return a <delim-token> with its value set to the current input code point.\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst _consumeANumber = (input, pos) => {\n  // This section describes how to consume a number from a stream of code points.\n  // It returns a numeric value, and a type which is either \"integer\" or \"number\".\n\n  // Execute the following steps in order:\n  // Initially set type to \"integer\". Let repr be the empty string.\n\n  // If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-), consume it and append it to repr.\n  if (input.charCodeAt(pos) === CC_HYPHEN_MINUS || input.charCodeAt(pos) === CC_PLUS_SIGN) {\n    pos++;\n  }\n\n  // While the next input code point is a digit, consume it and append it to repr.\n  while (_isDigit(input.charCodeAt(pos))) {\n    pos++;\n  }\n\n  // If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n  // 1. Consume the next input code point and append it to number part.\n  // 2. While the next input code point is a digit, consume it and append it to number part.\n  // 3. Set type to \"number\".\n  if (input.charCodeAt(pos) === CC_FULL_STOP && _isDigit(input.charCodeAt(pos + 1))) {\n    pos++;\n    while (_isDigit(input.charCodeAt(pos))) {\n      pos++;\n    }\n  }\n\n  // If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E) or U+0065 LATIN SMALL LETTER E (e), optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+), followed by a digit, then:\n  // 1. Consume the next input code point.\n  // 2. If the next input code point is \"+\" or \"-\", consume it and append it to exponent part.\n  // 3. While the next input code point is a digit, consume it and append it to exponent part.\n  // 4. Set type to \"number\".\n  if ((input.charCodeAt(pos) === CC_LOWER_E || input.charCodeAt(pos) === CC_UPPER_E) && ((input.charCodeAt(pos + 1) === CC_HYPHEN_MINUS || input.charCodeAt(pos + 1) === CC_PLUS_SIGN) && _isDigit(input.charCodeAt(pos + 2)) || _isDigit(input.charCodeAt(pos + 1)))) {\n    pos++;\n    if (input.charCodeAt(pos) === CC_PLUS_SIGN || input.charCodeAt(pos) === CC_HYPHEN_MINUS) {\n      pos++;\n    }\n    while (_isDigit(input.charCodeAt(pos))) {\n      pos++;\n    }\n  }\n\n  // Let value be the result of interpreting number part as a base-10 number.\n\n  // If exponent part is non-empty, interpret it as a base-10 integer, then raise 10 to the power of the result, multiply it by value, and set value to that result.\n\n  // Return value and type.\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeANumericToken = (input, pos, callbacks) => {\n  // This section describes how to consume a numeric token from a stream of code points.\n  // It returns either a <number-token>, <percentage-token>, or <dimension-token>.\n\n  // Consume a number and let number be the result.\n  pos = _consumeANumber(input, pos, callbacks);\n\n  // If the next 3 input code points would start an ident sequence, then:\n  //\n  // - Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.\n  // - Consume an ident sequence. Set the <dimension-token>’s unit to the returned value.\n  // - Return the <dimension-token>.\n\n  const first = input.charCodeAt(pos);\n  const second = input.charCodeAt(pos + 1);\n  const third = input.charCodeAt(pos + 2);\n  if (_ifThreeCodePointsWouldStartAnIdentSequence(input, pos, first, second, third)) {\n    return _consumeAnIdentSequence(input, pos, callbacks);\n  }\n  // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.\n  // Create a <percentage-token> with the same value as number, and return it.\n  else if (first === CC_PERCENTAGE) {\n    return pos + 1;\n  }\n\n  // Otherwise, create a <number-token> with the same value and type flag as number, and return it.\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeColon = (input, pos, callbacks) => {\n  // Return a <colon-token>.\n  if (callbacks.colon !== undefined) {\n    return callbacks.colon(input, pos - 1, pos);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeLeftParenthesis = (input, pos, callbacks) => {\n  // Return a <(-token>.\n  if (callbacks.leftParenthesis !== undefined) {\n    return callbacks.leftParenthesis(input, pos - 1, pos);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeRightParenthesis = (input, pos, callbacks) => {\n  // Return a <)-token>.\n  if (callbacks.rightParenthesis !== undefined) {\n    return callbacks.rightParenthesis(input, pos - 1, pos);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeLeftSquareBracket = (input, pos, callbacks) =>\n// Return a <]-token>.\npos;\n\n/** @type {CharHandler} */\nconst consumeRightSquareBracket = (input, pos, callbacks) =>\n// Return a <]-token>.\npos;\n\n/** @type {CharHandler} */\nconst consumeLeftCurlyBracket = (input, pos, callbacks) => {\n  // Return a <{-token>.\n  if (callbacks.leftCurlyBracket !== undefined) {\n    return callbacks.leftCurlyBracket(input, pos - 1, pos);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeRightCurlyBracket = (input, pos, callbacks) => {\n  // Return a <}-token>.\n  if (callbacks.rightCurlyBracket !== undefined) {\n    return callbacks.rightCurlyBracket(input, pos - 1, pos);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeSemicolon = (input, pos, callbacks) => {\n  // Return a <semicolon-token>.\n  if (callbacks.semicolon !== undefined) {\n    return callbacks.semicolon(input, pos - 1, pos);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeComma = (input, pos, callbacks) => {\n  // Return a <comma-token>.\n  if (callbacks.comma !== undefined) {\n    return callbacks.comma(input, pos - 1, pos);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst _consumeAnIdentSequence = (input, pos) => {\n  // This section describes how to consume an ident sequence from a stream of code points.\n  // It returns a string containing the largest name that can be formed from adjacent code points in the stream, starting from the first.\n\n  // Note: This algorithm does not do the verification of the first few code points that are necessary to ensure the returned code points would constitute an <ident-token>.\n  // If that is the intended use, ensure that the stream starts with an ident sequence before calling this algorithm.\n\n  // Let result initially be an empty string.\n\n  // Repeatedly consume the next input code point from the stream:\n  for (;;) {\n    const cc = input.charCodeAt(pos);\n    pos++;\n\n    // ident code point\n    // Append the code point to result.\n    if (_isIdentCodePoint(cc, pos - 1)) {\n      // Nothing\n    }\n    // the stream starts with a valid escape\n    // Consume an escaped code point. Append the returned code point to result.\n    else if (_ifTwoCodePointsAreValidEscape(input, pos)) {\n      pos = _consumeAnEscapedCodePoint(input, pos);\n    }\n    // anything else\n    // Reconsume the current input code point. Return result.\n    else {\n      return pos - 1;\n    }\n  }\n};\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, when cc is the non-printable code point, otherwise false\n */\nconst _isNonPrintableCodePoint = cc => cc >= 0x00 && cc <= 0x08 || cc === 0x0b || cc >= 0x0e && cc <= 0x1f || cc === 0x7f;\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position\n */\nconst consumeTheRemnantsOfABadUrl = (input, pos) => {\n  // This section describes how to consume the remnants of a bad url from a stream of code points,\n  // \"cleaning up\" after the tokenizer realizes that it’s in the middle of a <bad-url-token> rather than a <url-token>.\n  // It returns nothing; its sole use is to consume enough of the input stream to reach a recovery point where normal tokenizing can resume.\n\n  // Repeatedly consume the next input code point from the stream:\n  for (;;) {\n    // EOF\n    // Return.\n    if (pos === input.length) {\n      return pos;\n    }\n    const cc = input.charCodeAt(pos);\n    pos++;\n\n    // U+0029 RIGHT PARENTHESIS ())\n    // Return.\n    if (cc === CC_RIGHT_PARENTHESIS) {\n      return pos;\n    }\n    // the input stream starts with a valid escape\n    // Consume an escaped code point.\n    // This allows an escaped right parenthesis (\"\\)\") to be encountered without ending the <bad-url-token>.\n    // This is otherwise identical to the \"anything else\" clause.\n    else if (_ifTwoCodePointsAreValidEscape(input, pos)) {\n      pos = _consumeAnEscapedCodePoint(input, pos);\n    }\n    // anything else\n    // Do nothing.\n    else {\n      // Do nothing.\n    }\n  }\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @param {number} fnStart start\n * @param {CssTokenCallbacks} callbacks callbacks\n * @returns {pos} pos\n */\nconst consumeAUrlToken = (input, pos, fnStart, callbacks) => {\n  // This section describes how to consume a url token from a stream of code points.\n  // It returns either a <url-token> or a <bad-url-token>.\n\n  // Note: This algorithm assumes that the initial \"url(\" has already been consumed.\n  // This algorithm also assumes that it’s being called to consume an \"unquoted\" value, like url(foo).\n  // A quoted value, like url(\"foo\"), is parsed as a <function-token>.\n  // Consume an ident-like token automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.\n\n  // Initially create a <url-token> with its value set to the empty string.\n\n  // Consume as much whitespace as possible.\n  while (_isWhiteSpace(input.charCodeAt(pos))) {\n    pos++;\n  }\n  const contentStart = pos;\n\n  // Repeatedly consume the next input code point from the stream:\n  for (;;) {\n    // EOF\n    // This is a parse error. Return the <url-token>.\n    if (pos === input.length) {\n      if (callbacks.url !== undefined) {\n        return callbacks.url(input, fnStart, pos, contentStart, pos - 1);\n      }\n      return pos;\n    }\n    const cc = input.charCodeAt(pos);\n    pos++;\n\n    // U+0029 RIGHT PARENTHESIS ())\n    // Return the <url-token>.\n    if (cc === CC_RIGHT_PARENTHESIS) {\n      if (callbacks.url !== undefined) {\n        return callbacks.url(input, fnStart, pos, contentStart, pos - 1);\n      }\n      return pos;\n    }\n    // whitespace\n    // Consume as much whitespace as possible.\n    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF, consume it and return the <url-token>\n    // (if EOF was encountered, this is a parse error); otherwise, consume the remnants of a bad url, create a <bad-url-token>, and return it.\n    else if (_isWhiteSpace(cc)) {\n      const end = pos - 1;\n      while (_isWhiteSpace(input.charCodeAt(pos))) {\n        pos++;\n      }\n      if (pos === input.length) {\n        if (callbacks.url !== undefined) {\n          return callbacks.url(input, fnStart, pos, contentStart, end);\n        }\n        return pos;\n      }\n      if (input.charCodeAt(pos) === CC_RIGHT_PARENTHESIS) {\n        pos++;\n        if (callbacks.url !== undefined) {\n          return callbacks.url(input, fnStart, pos, contentStart, end);\n        }\n        return pos;\n      }\n\n      // Don't handle bad urls\n      return consumeTheRemnantsOfABadUrl(input, pos);\n    }\n    // U+0022 QUOTATION MARK (\")\n    // U+0027 APOSTROPHE (')\n    // U+0028 LEFT PARENTHESIS (()\n    // non-printable code point\n    // This is a parse error. Consume the remnants of a bad url, create a <bad-url-token>, and return it.\n    else if (cc === CC_QUOTATION_MARK || cc === CC_APOSTROPHE || cc === CC_LEFT_PARENTHESIS || _isNonPrintableCodePoint(cc)) {\n      // Don't handle bad urls\n      return consumeTheRemnantsOfABadUrl(input, pos);\n    }\n    // // U+005C REVERSE SOLIDUS (\\)\n    // // If the stream starts with a valid escape, consume an escaped code point and append the returned code point to the <url-token>’s value.\n    // // Otherwise, this is a parse error. Consume the remnants of a bad url, create a <bad-url-token>, and return it.\n    else if (cc === CC_REVERSE_SOLIDUS) {\n      if (_ifTwoCodePointsAreValidEscape(input, pos)) {\n        pos = _consumeAnEscapedCodePoint(input, pos);\n      } else {\n        // Don't handle bad urls\n        return consumeTheRemnantsOfABadUrl(input, pos);\n      }\n    }\n    // anything else\n    // Append the current input code point to the <url-token>’s value.\n    else {\n      // Nothing\n    }\n  }\n};\n\n/** @type {CharHandler} */\nconst consumeAnIdentLikeToken = (input, pos, callbacks) => {\n  const start = pos;\n  // This section describes how to consume an ident-like token from a stream of code points.\n  // It returns an <ident-token>, <function-token>, <url-token>, or <bad-url-token>.\n  pos = _consumeAnIdentSequence(input, pos, callbacks);\n\n  // If string’s value is an ASCII case-insensitive match for \"url\", and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n  // While the next two input code points are whitespace, consume the next input code point.\n  // If the next one or two input code points are U+0022 QUOTATION MARK (\"), U+0027 APOSTROPHE ('), or whitespace followed by U+0022 QUOTATION MARK (\") or U+0027 APOSTROPHE ('), then create a <function-token> with its value set to string and return it.\n  // Otherwise, consume a url token, and return it.\n  if (input.slice(start, pos).toLowerCase() === \"url\" && input.charCodeAt(pos) === CC_LEFT_PARENTHESIS) {\n    pos++;\n    const end = pos;\n    while (_isWhiteSpace(input.charCodeAt(pos)) && _isWhiteSpace(input.charCodeAt(pos + 1))) {\n      pos++;\n    }\n    if (input.charCodeAt(pos) === CC_QUOTATION_MARK || input.charCodeAt(pos) === CC_APOSTROPHE || _isWhiteSpace(input.charCodeAt(pos)) && (input.charCodeAt(pos + 1) === CC_QUOTATION_MARK || input.charCodeAt(pos + 1) === CC_APOSTROPHE)) {\n      if (callbacks.function !== undefined) {\n        return callbacks.function(input, start, end);\n      }\n      return pos;\n    }\n    return consumeAUrlToken(input, pos, start, callbacks);\n  }\n\n  // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n  // Create a <function-token> with its value set to string and return it.\n  if (input.charCodeAt(pos) === CC_LEFT_PARENTHESIS) {\n    pos++;\n    if (callbacks.function !== undefined) {\n      return callbacks.function(input, start, pos);\n    }\n    return pos;\n  }\n\n  // Otherwise, create an <ident-token> with its value set to string and return it.\n  if (callbacks.identifier !== undefined) {\n    return callbacks.identifier(input, start, pos);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeLessThan = (input, pos, _callbacks) => {\n  // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), consume them and return a <CDO-token>.\n  if (input.slice(pos, pos + 3) === \"!--\") {\n    return pos + 3;\n  }\n\n  // Otherwise, return a <delim-token> with its value set to the current input code point.\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeCommercialAt = (input, pos, callbacks) => {\n  const start = pos - 1;\n\n  // If the next 3 input code points would start an ident sequence, consume an ident sequence, create an <at-keyword-token> with its value set to the returned value, and return it.\n  if (_ifThreeCodePointsWouldStartAnIdentSequence(input, pos, input.charCodeAt(pos), input.charCodeAt(pos + 1), input.charCodeAt(pos + 2))) {\n    pos = _consumeAnIdentSequence(input, pos, callbacks);\n    if (callbacks.atKeyword !== undefined) {\n      pos = callbacks.atKeyword(input, start, pos);\n    }\n    return pos;\n  }\n\n  // Otherwise, return a <delim-token> with its value set to the current input code point.\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeReverseSolidus = (input, pos, callbacks) => {\n  // If the input stream starts with a valid escape, reconsume the current input code point, consume an ident-like token, and return it.\n  if (_ifTwoCodePointsAreValidEscape(input, pos)) {\n    pos--;\n    return consumeAnIdentLikeToken(input, pos, callbacks);\n  }\n\n  // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeAToken = (input, pos, callbacks) => {\n  const cc = input.charCodeAt(pos - 1);\n\n  // https://drafts.csswg.org/css-syntax/#consume-token\n  switch (cc) {\n    // whitespace\n    case CC_LINE_FEED:\n    case CC_CARRIAGE_RETURN:\n    case CC_FORM_FEED:\n    case CC_TAB:\n    case CC_SPACE:\n      return consumeSpace(input, pos, callbacks);\n    // U+0022 QUOTATION MARK (\")\n    case CC_QUOTATION_MARK:\n      return consumeAStringToken(input, pos, callbacks);\n    // U+0023 NUMBER SIGN (#)\n    case CC_NUMBER_SIGN:\n      return consumeNumberSign(input, pos, callbacks);\n    // U+0027 APOSTROPHE (')\n    case CC_APOSTROPHE:\n      return consumeAStringToken(input, pos, callbacks);\n    // U+0028 LEFT PARENTHESIS (()\n    case CC_LEFT_PARENTHESIS:\n      return consumeLeftParenthesis(input, pos, callbacks);\n    // U+0029 RIGHT PARENTHESIS ())\n    case CC_RIGHT_PARENTHESIS:\n      return consumeRightParenthesis(input, pos, callbacks);\n    // U+002B PLUS SIGN (+)\n    case CC_PLUS_SIGN:\n      return consumePlusSign(input, pos, callbacks);\n    // U+002C COMMA (,)\n    case CC_COMMA:\n      return consumeComma(input, pos, callbacks);\n    // U+002D HYPHEN-MINUS (-)\n    case CC_HYPHEN_MINUS:\n      return consumeHyphenMinus(input, pos, callbacks);\n    // U+002E FULL STOP (.)\n    case CC_FULL_STOP:\n      return consumeFullStop(input, pos, callbacks);\n    // U+003A COLON (:)\n    case CC_COLON:\n      return consumeColon(input, pos, callbacks);\n    // U+003B SEMICOLON (;)\n    case CC_SEMICOLON:\n      return consumeSemicolon(input, pos, callbacks);\n    // U+003C LESS-THAN SIGN (<)\n    case CC_LESS_THAN_SIGN:\n      return consumeLessThan(input, pos, callbacks);\n    // U+0040 COMMERCIAL AT (@)\n    case CC_AT_SIGN:\n      return consumeCommercialAt(input, pos, callbacks);\n    // U+005B LEFT SQUARE BRACKET ([)\n    case CC_LEFT_SQUARE:\n      return consumeLeftSquareBracket(input, pos, callbacks);\n    // U+005C REVERSE SOLIDUS (\\)\n    case CC_REVERSE_SOLIDUS:\n      return consumeReverseSolidus(input, pos, callbacks);\n    // U+005D RIGHT SQUARE BRACKET (])\n    case CC_RIGHT_SQUARE:\n      return consumeRightSquareBracket(input, pos, callbacks);\n    // U+007B LEFT CURLY BRACKET ({)\n    case CC_LEFT_CURLY:\n      return consumeLeftCurlyBracket(input, pos, callbacks);\n    // U+007D RIGHT CURLY BRACKET (})\n    case CC_RIGHT_CURLY:\n      return consumeRightCurlyBracket(input, pos, callbacks);\n    default:\n      // digit\n      // Reconsume the current input code point, consume a numeric token, and return it.\n      if (_isDigit(cc)) {\n        pos--;\n        return consumeANumericToken(input, pos, callbacks);\n      } else if (cc === CC_LOWER_U || cc === CC_UPPER_U) {\n        // If unicode ranges allowed is true and the input stream would start a unicode-range,\n        // reconsume the current input code point, consume a unicode-range token, and return it.\n        // Skip now\n        // if (_ifThreeCodePointsWouldStartAUnicodeRange(input, pos)) {\n        // \tpos--;\n        // \treturn consumeAUnicodeRangeToken(input, pos, callbacks);\n        // }\n\n        // Otherwise, reconsume the current input code point, consume an ident-like token, and return it.\n        pos--;\n        return consumeAnIdentLikeToken(input, pos, callbacks);\n      }\n      // ident-start code point\n      // Reconsume the current input code point, consume an ident-like token, and return it.\n      else if (isIdentStartCodePoint(cc)) {\n        pos--;\n        return consumeAnIdentLikeToken(input, pos, callbacks);\n      }\n\n      // EOF, but we don't have it\n\n      // anything else\n      // Return a <delim-token> with its value set to the current input code point.\n      return consumeDelimToken(input, pos, callbacks);\n  }\n};\n\n/**\n * @param {string} input input css\n * @param {CssTokenCallbacks} callbacks callbacks\n * @returns {void}\n */\nmodule.exports = (input, callbacks) => {\n  // This section describes how to consume a token from a stream of code points. It will return a single token of any type.\n  let pos = 0;\n  while (pos < input.length) {\n    // Consume comments.\n    pos = consumeComments(input, pos, callbacks);\n\n    // Consume the next input code point.\n    pos++;\n    pos = consumeAToken(input, pos, callbacks);\n  }\n};\nmodule.exports.isIdentStartCodePoint = isIdentStartCodePoint;\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after comments\n */\nmodule.exports.eatComments = (input, pos) => {\n  for (;;) {\n    const originalPos = pos;\n    pos = consumeComments(input, pos, {});\n    if (originalPos === pos) {\n      break;\n    }\n  }\n  return pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace\n */\nmodule.exports.eatWhitespace = (input, pos) => {\n  while (_isWhiteSpace(input.charCodeAt(pos))) {\n    pos++;\n  }\n  return pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace and comments\n */\nmodule.exports.eatWhitespaceAndComments = (input, pos) => {\n  for (;;) {\n    const originalPos = pos;\n    pos = consumeComments(input, pos, {});\n    while (_isWhiteSpace(input.charCodeAt(pos))) {\n      pos++;\n    }\n    if (originalPos === pos) {\n      break;\n    }\n  }\n  return pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace and comments\n */\nmodule.exports.eatComments = (input, pos) => {\n  for (;;) {\n    const originalPos = pos;\n    pos = consumeComments(input, pos, {});\n    if (originalPos === pos) {\n      break;\n    }\n  }\n  return pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace\n */\nmodule.exports.eatWhiteLine = (input, pos) => {\n  for (;;) {\n    const cc = input.charCodeAt(pos);\n    if (_isSpace(cc)) {\n      pos++;\n      continue;\n    }\n    if (_isNewLine(cc)) pos++;\n    // For `\\r\\n`\n    if (cc === CC_CARRIAGE_RETURN && input.charCodeAt(pos + 1) === CC_LINE_FEED) pos++;\n    break;\n  }\n  return pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {[number, number] | undefined} positions of ident sequence\n */\nmodule.exports.skipCommentsAndEatIdentSequence = (input, pos) => {\n  pos = module.exports.eatComments(input, pos);\n  const start = pos;\n  if (_ifThreeCodePointsWouldStartAnIdentSequence(input, pos, input.charCodeAt(pos), input.charCodeAt(pos + 1), input.charCodeAt(pos + 2))) {\n    return [start, _consumeAnIdentSequence(input, pos, {})];\n  }\n  return undefined;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {[number, number] | undefined} positions of ident sequence\n */\nmodule.exports.eatString = (input, pos) => {\n  pos = module.exports.eatWhitespaceAndComments(input, pos);\n  const start = pos;\n  if (input.charCodeAt(pos) === CC_QUOTATION_MARK || input.charCodeAt(pos) === CC_APOSTROPHE) {\n    return [start, consumeAStringToken(input, pos + 1, {})];\n  }\n  return undefined;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @param {CssTokenCallbacks} cbs callbacks\n * @returns {[number, number][]} positions of ident sequence\n */\nmodule.exports.eatImageSetStrings = (input, pos, cbs) => {\n  /** @type {[number, number][]} */\n  const result = [];\n  let isFirst = true;\n  let needStop = false;\n  // We already in `func(` token\n  let balanced = 1;\n\n  /** @type {CssTokenCallbacks} */\n  const callbacks = {\n    ...cbs,\n    string: (_input, start, end) => {\n      if (isFirst && balanced === 1) {\n        result.push([start, end]);\n        isFirst = false;\n      }\n      return end;\n    },\n    comma: (_input, _start, end) => {\n      if (balanced === 1) {\n        isFirst = true;\n      }\n      return end;\n    },\n    leftParenthesis: (input, start, end) => {\n      balanced++;\n      return end;\n    },\n    function: (_input, start, end) => {\n      balanced++;\n      return end;\n    },\n    rightParenthesis: (_input, _start, end) => {\n      balanced--;\n      if (balanced === 0) {\n        needStop = true;\n      }\n      return end;\n    }\n  };\n  while (pos < input.length) {\n    // Consume comments.\n    pos = consumeComments(input, pos, callbacks);\n\n    // Consume the next input code point.\n    pos++;\n    pos = consumeAToken(input, pos, callbacks);\n    if (needStop) {\n      break;\n    }\n  }\n  return result;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @param {CssTokenCallbacks} cbs callbacks\n * @returns {[[number, number, number, number] | undefined, [number, number] | undefined, [number, number] | undefined, [number, number] | undefined]} positions of top level tokens\n */\nmodule.exports.eatImportTokens = (input, pos, cbs) => {\n  const result = /** @type {[[number, number, number, number] | undefined, [number, number] | undefined, [number, number] | undefined, [number, number] | undefined]} */\n  new Array(4);\n\n  /** @type {0 | 1 | 2 | undefined} */\n  let scope;\n  let needStop = false;\n  let balanced = 0;\n\n  /** @type {CssTokenCallbacks} */\n  const callbacks = {\n    ...cbs,\n    url: (_input, start, end, contentStart, contentEnd) => {\n      if (result[0] === undefined && balanced === 0 && result[1] === undefined && result[2] === undefined && result[3] === undefined) {\n        result[0] = [start, end, contentStart, contentEnd];\n        scope = undefined;\n      }\n      return end;\n    },\n    string: (_input, start, end) => {\n      if (balanced === 0 && result[0] === undefined && result[1] === undefined && result[2] === undefined && result[3] === undefined) {\n        result[0] = [start, end, start + 1, end - 1];\n        scope = undefined;\n      } else if (result[0] !== undefined && scope === 0) {\n        result[0][2] = start + 1;\n        result[0][3] = end - 1;\n      }\n      return end;\n    },\n    leftParenthesis: (_input, _start, end) => {\n      balanced++;\n      return end;\n    },\n    rightParenthesis: (_input, _start, end) => {\n      balanced--;\n      if (balanced === 0 && scope !== undefined) {\n        /** @type {[number, number]} */\n        result[scope][1] = end;\n        scope = undefined;\n      }\n      return end;\n    },\n    function: (input, start, end) => {\n      if (balanced === 0) {\n        const name = input.slice(start, end - 1).replace(/\\\\/g, \"\").toLowerCase();\n        if (name === \"url\" && result[0] === undefined && result[1] === undefined && result[2] === undefined && result[3] === undefined) {\n          scope = 0;\n          result[scope] = [start, end + 1, end + 1, end + 1];\n        } else if (name === \"layer\" && result[1] === undefined && result[2] === undefined) {\n          scope = 1;\n          result[scope] = [start, end];\n        } else if (name === \"supports\" && result[2] === undefined) {\n          scope = 2;\n          result[scope] = [start, end];\n        } else {\n          scope = undefined;\n        }\n      }\n      balanced++;\n      return end;\n    },\n    identifier: (input, start, end) => {\n      if (balanced === 0 && result[1] === undefined && result[2] === undefined) {\n        const name = input.slice(start, end).replace(/\\\\/g, \"\").toLowerCase();\n        if (name === \"layer\") {\n          result[1] = [start, end];\n          scope = undefined;\n        }\n      }\n      return end;\n    },\n    semicolon: (_input, start, end) => {\n      if (balanced === 0) {\n        needStop = true;\n        result[3] = [start, end];\n      }\n      return end;\n    }\n  };\n  while (pos < input.length) {\n    // Consume comments.\n    pos = consumeComments(input, pos, callbacks);\n\n    // Consume the next input code point.\n    pos++;\n    pos = consumeAToken(input, pos, callbacks);\n    if (needStop) {\n      break;\n    }\n  }\n  return result;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {[number, number] | undefined} positions of ident sequence\n */\nmodule.exports.eatIdentSequence = (input, pos) => {\n  pos = module.exports.eatWhitespaceAndComments(input, pos);\n  const start = pos;\n  if (_ifThreeCodePointsWouldStartAnIdentSequence(input, pos, input.charCodeAt(pos), input.charCodeAt(pos + 1), input.charCodeAt(pos + 2))) {\n    return [start, _consumeAnIdentSequence(input, pos, {})];\n  }\n  return undefined;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {[number, number, boolean] | undefined} positions of ident sequence or string\n */\nmodule.exports.eatIdentSequenceOrString = (input, pos) => {\n  pos = module.exports.eatWhitespaceAndComments(input, pos);\n  const start = pos;\n  if (input.charCodeAt(pos) === CC_QUOTATION_MARK || input.charCodeAt(pos) === CC_APOSTROPHE) {\n    return [start, consumeAStringToken(input, pos + 1, {}), false];\n  } else if (_ifThreeCodePointsWouldStartAnIdentSequence(input, pos, input.charCodeAt(pos), input.charCodeAt(pos + 1), input.charCodeAt(pos + 2))) {\n    return [start, _consumeAnIdentSequence(input, pos, {}), true];\n  }\n  return undefined;\n};\n\n/**\n * @param {string} chars characters\n * @returns {(input: string, pos: number) => number} function to eat characters\n */\nmodule.exports.eatUntil = chars => {\n  const charCodes = Array.from({\n    length: chars.length\n  }, (_, i) => chars.charCodeAt(i));\n  const arr = Array.from({\n    length: charCodes.reduce((a, b) => Math.max(a, b), 0) + 1\n  }, () => false);\n  for (const cc of charCodes) {\n    arr[cc] = true;\n  }\n  return (input, pos) => {\n    for (;;) {\n      const cc = input.charCodeAt(pos);\n      if (cc < arr.length && arr[cc]) {\n        return pos;\n      }\n      pos++;\n      if (pos === input.length) return pos;\n    }\n  };\n};","map":{"version":3,"names":["CC_LINE_FEED","charCodeAt","CC_CARRIAGE_RETURN","CC_FORM_FEED","CC_TAB","CC_SPACE","CC_SOLIDUS","CC_REVERSE_SOLIDUS","CC_ASTERISK","CC_LEFT_PARENTHESIS","CC_RIGHT_PARENTHESIS","CC_LEFT_CURLY","CC_RIGHT_CURLY","CC_LEFT_SQUARE","CC_RIGHT_SQUARE","CC_QUOTATION_MARK","CC_APOSTROPHE","CC_FULL_STOP","CC_COLON","CC_SEMICOLON","CC_COMMA","CC_PERCENTAGE","CC_AT_SIGN","CC_LOW_LINE","CC_LOWER_A","CC_LOWER_F","CC_LOWER_E","CC_LOWER_U","CC_LOWER_Z","CC_UPPER_A","CC_UPPER_F","CC_UPPER_E","CC_UPPER_U","CC_UPPER_Z","CC_0","CC_9","CC_NUMBER_SIGN","CC_PLUS_SIGN","CC_HYPHEN_MINUS","CC_LESS_THAN_SIGN","CC_GREATER_THAN_SIGN","_isNewLine","cc","consumeSpace","input","pos","_callbacks","_isWhiteSpace","_isNewline","_isSpace","isIdentStartCodePoint","consumeDelimToken","consumeComments","callbacks","start","length","comment","_isHexDigit","_isDigit","_consumeAnEscapedCodePoint","i","consumeAStringToken","endingCodePoint","string","undefined","_ifTwoCodePointsAreValidEscape","isNonASCIICodePoint","q","isLetter","_isIdentStartCodePoint","_isIdentCodePoint","f","s","first","second","_ifThreeCodePointsWouldStartAnIdentSequence","t","third","_ifThreeCodePointsWouldStartANumber","consumeNumberSign","isId","_consumeAnIdentSequence","hash","consumeHyphenMinus","consumeANumericToken","consumeAnIdentLikeToken","consumeFullStop","delim","consumePlusSign","_consumeANumber","consumeColon","colon","consumeLeftParenthesis","leftParenthesis","consumeRightParenthesis","rightParenthesis","consumeLeftSquareBracket","consumeRightSquareBracket","consumeLeftCurlyBracket","leftCurlyBracket","consumeRightCurlyBracket","rightCurlyBracket","consumeSemicolon","semicolon","consumeComma","comma","_isNonPrintableCodePoint","consumeTheRemnantsOfABadUrl","consumeAUrlToken","fnStart","contentStart","url","end","slice","toLowerCase","function","identifier","consumeLessThan","consumeCommercialAt","atKeyword","consumeReverseSolidus","consumeAToken","module","exports","eatComments","originalPos","eatWhitespace","eatWhitespaceAndComments","eatWhiteLine","skipCommentsAndEatIdentSequence","eatString","eatImageSetStrings","cbs","result","isFirst","needStop","balanced","_input","push","_start","eatImportTokens","Array","scope","contentEnd","name","replace","eatIdentSequence","eatIdentSequenceOrString","eatUntil","chars","charCodes","from","_","arr","reduce","a","b","Math","max"],"sources":["/home/wickliff/Desktop/dev-waki/portfolio2/node_modules/webpack/lib/css/walkCssTokens.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/**\n * @typedef {object} CssTokenCallbacks\n * @property {(function(string, number, number, number, number): number)=} url\n * @property {(function(string, number, number): number)=} comment\n * @property {(function(string, number, number): number)=} string\n * @property {(function(string, number, number): number)=} leftParenthesis\n * @property {(function(string, number, number): number)=} rightParenthesis\n * @property {(function(string, number, number): number)=} function\n * @property {(function(string, number, number): number)=} colon\n * @property {(function(string, number, number): number)=} atKeyword\n * @property {(function(string, number, number): number)=} delim\n * @property {(function(string, number, number): number)=} identifier\n * @property {(function(string, number, number, boolean): number)=} hash\n * @property {(function(string, number, number): number)=} leftCurlyBracket\n * @property {(function(string, number, number): number)=} rightCurlyBracket\n * @property {(function(string, number, number): number)=} semicolon\n * @property {(function(string, number, number): number)=} comma\n */\n\n/** @typedef {function(string, number, CssTokenCallbacks): number} CharHandler */\n\n// spec: https://drafts.csswg.org/css-syntax/\n\nconst CC_LINE_FEED = \"\\n\".charCodeAt(0);\nconst CC_CARRIAGE_RETURN = \"\\r\".charCodeAt(0);\nconst CC_FORM_FEED = \"\\f\".charCodeAt(0);\n\nconst CC_TAB = \"\\t\".charCodeAt(0);\nconst CC_SPACE = \" \".charCodeAt(0);\n\nconst CC_SOLIDUS = \"/\".charCodeAt(0);\nconst CC_REVERSE_SOLIDUS = \"\\\\\".charCodeAt(0);\nconst CC_ASTERISK = \"*\".charCodeAt(0);\n\nconst CC_LEFT_PARENTHESIS = \"(\".charCodeAt(0);\nconst CC_RIGHT_PARENTHESIS = \")\".charCodeAt(0);\nconst CC_LEFT_CURLY = \"{\".charCodeAt(0);\nconst CC_RIGHT_CURLY = \"}\".charCodeAt(0);\nconst CC_LEFT_SQUARE = \"[\".charCodeAt(0);\nconst CC_RIGHT_SQUARE = \"]\".charCodeAt(0);\n\nconst CC_QUOTATION_MARK = '\"'.charCodeAt(0);\nconst CC_APOSTROPHE = \"'\".charCodeAt(0);\n\nconst CC_FULL_STOP = \".\".charCodeAt(0);\nconst CC_COLON = \":\".charCodeAt(0);\nconst CC_SEMICOLON = \";\".charCodeAt(0);\nconst CC_COMMA = \",\".charCodeAt(0);\nconst CC_PERCENTAGE = \"%\".charCodeAt(0);\nconst CC_AT_SIGN = \"@\".charCodeAt(0);\n\nconst CC_LOW_LINE = \"_\".charCodeAt(0);\nconst CC_LOWER_A = \"a\".charCodeAt(0);\nconst CC_LOWER_F = \"f\".charCodeAt(0);\nconst CC_LOWER_E = \"e\".charCodeAt(0);\nconst CC_LOWER_U = \"u\".charCodeAt(0);\nconst CC_LOWER_Z = \"z\".charCodeAt(0);\nconst CC_UPPER_A = \"A\".charCodeAt(0);\nconst CC_UPPER_F = \"F\".charCodeAt(0);\nconst CC_UPPER_E = \"E\".charCodeAt(0);\nconst CC_UPPER_U = \"E\".charCodeAt(0);\nconst CC_UPPER_Z = \"Z\".charCodeAt(0);\nconst CC_0 = \"0\".charCodeAt(0);\nconst CC_9 = \"9\".charCodeAt(0);\n\nconst CC_NUMBER_SIGN = \"#\".charCodeAt(0);\nconst CC_PLUS_SIGN = \"+\".charCodeAt(0);\nconst CC_HYPHEN_MINUS = \"-\".charCodeAt(0);\n\nconst CC_LESS_THAN_SIGN = \"<\".charCodeAt(0);\nconst CC_GREATER_THAN_SIGN = \">\".charCodeAt(0);\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a newline\n */\nconst _isNewLine = cc =>\n\tcc === CC_LINE_FEED || cc === CC_CARRIAGE_RETURN || cc === CC_FORM_FEED;\n\n/** @type {CharHandler} */\nconst consumeSpace = (input, pos, _callbacks) => {\n\t// Consume as much whitespace as possible.\n\twhile (_isWhiteSpace(input.charCodeAt(pos))) {\n\t\tpos++;\n\t}\n\n\t// Return a <whitespace-token>.\n\treturn pos;\n};\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a newline\n */\nconst _isNewline = cc =>\n\tcc === CC_LINE_FEED || cc === CC_CARRIAGE_RETURN || cc === CC_FORM_FEED;\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a space (U+0009 CHARACTER TABULATION or U+0020 SPACE)\n */\nconst _isSpace = cc => cc === CC_TAB || cc === CC_SPACE;\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a whitespace\n */\nconst _isWhiteSpace = cc => _isNewline(cc) || _isSpace(cc);\n\n/**\n * ident-start code point\n *\n * A letter, a non-ASCII code point, or U+005F LOW LINE (_).\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a start code point of an identifier\n */\nconst isIdentStartCodePoint = cc =>\n\t(cc >= CC_LOWER_A && cc <= CC_LOWER_Z) ||\n\t(cc >= CC_UPPER_A && cc <= CC_UPPER_Z) ||\n\tcc === CC_LOW_LINE ||\n\tcc >= 0x80;\n\n/** @type {CharHandler} */\nconst consumeDelimToken = (input, pos, _callbacks) =>\n\t// Return a <delim-token> with its value set to the current input code point.\n\tpos;\n\n/** @type {CharHandler} */\nconst consumeComments = (input, pos, callbacks) => {\n\t// This section describes how to consume comments from a stream of code points. It returns nothing.\n\t// If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),\n\t// consume them and all following code points up to and including the first U+002A ASTERISK (*)\n\t// followed by a U+002F SOLIDUS (/), or up to an EOF code point.\n\t// Return to the start of this step.\n\twhile (\n\t\tinput.charCodeAt(pos) === CC_SOLIDUS &&\n\t\tinput.charCodeAt(pos + 1) === CC_ASTERISK\n\t) {\n\t\tconst start = pos;\n\t\tpos += 2;\n\n\t\tfor (;;) {\n\t\t\tif (pos === input.length) {\n\t\t\t\t// If the preceding paragraph ended by consuming an EOF code point, this is a parse error.\n\t\t\t\treturn pos;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tinput.charCodeAt(pos) === CC_ASTERISK &&\n\t\t\t\tinput.charCodeAt(pos + 1) === CC_SOLIDUS\n\t\t\t) {\n\t\t\t\tpos += 2;\n\n\t\t\t\tif (callbacks.comment) {\n\t\t\t\t\tpos = callbacks.comment(input, start, pos);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpos++;\n\t\t}\n\t}\n\n\treturn pos;\n};\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a hex digit\n */\nconst _isHexDigit = cc =>\n\t_isDigit(cc) ||\n\t(cc >= CC_UPPER_A && cc <= CC_UPPER_F) ||\n\t(cc >= CC_LOWER_A && cc <= CC_LOWER_F);\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position\n */\nconst _consumeAnEscapedCodePoint = (input, pos) => {\n\t// This section describes how to consume an escaped code point.\n\t// It assumes that the U+005C REVERSE SOLIDUS (\\) has already been consumed and that the next input code point has already been verified to be part of a valid escape.\n\t// It will return a code point.\n\n\t// Consume the next input code point.\n\tconst cc = input.charCodeAt(pos);\n\tpos++;\n\n\t// EOF\n\t// This is a parse error. Return U+FFFD REPLACEMENT CHARACTER (�).\n\tif (pos === input.length) {\n\t\treturn pos;\n\t}\n\n\t// hex digit\n\t// Consume as many hex digits as possible, but no more than 5.\n\t// Note that this means 1-6 hex digits have been consumed in total.\n\t// If the next input code point is whitespace, consume it as well.\n\t// Interpret the hex digits as a hexadecimal number.\n\t// If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point, return U+FFFD REPLACEMENT CHARACTER (�).\n\t// Otherwise, return the code point with that value.\n\tif (_isHexDigit(cc)) {\n\t\tfor (let i = 0; i < 5; i++) {\n\t\t\tif (_isHexDigit(input.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\n\t\tif (_isWhiteSpace(input.charCodeAt(pos))) {\n\t\t\tpos++;\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t// anything else\n\t// Return the current input code point.\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeAStringToken = (input, pos, callbacks) => {\n\t// This section describes how to consume a string token from a stream of code points.\n\t// It returns either a <string-token> or <bad-string-token>.\n\t//\n\t// This algorithm may be called with an ending code point, which denotes the code point that ends the string.\n\t// If an ending code point is not specified, the current input code point is used.\n\tconst start = pos - 1;\n\tconst endingCodePoint = input.charCodeAt(pos - 1);\n\n\t// Initially create a <string-token> with its value set to the empty string.\n\n\t// Repeatedly consume the next input code point from the stream:\n\tfor (;;) {\n\t\t// EOF\n\t\t// This is a parse error. Return the <string-token>.\n\t\tif (pos === input.length) {\n\t\t\tif (callbacks.string !== undefined) {\n\t\t\t\treturn callbacks.string(input, start, pos);\n\t\t\t}\n\n\t\t\treturn pos;\n\t\t}\n\n\t\tconst cc = input.charCodeAt(pos);\n\t\tpos++;\n\n\t\t// ending code point\n\t\t// Return the <string-token>.\n\t\tif (cc === endingCodePoint) {\n\t\t\tif (callbacks.string !== undefined) {\n\t\t\t\treturn callbacks.string(input, start, pos);\n\t\t\t}\n\n\t\t\treturn pos;\n\t\t}\n\t\t// newline\n\t\t// This is a parse error.\n\t\t// Reconsume the current input code point, create a <bad-string-token>, and return it.\n\t\telse if (_isNewLine(cc)) {\n\t\t\tpos--;\n\t\t\t// bad string\n\t\t\treturn pos;\n\t\t}\n\t\t// U+005C REVERSE SOLIDUS (\\)\n\t\telse if (cc === CC_REVERSE_SOLIDUS) {\n\t\t\t// If the next input code point is EOF, do nothing.\n\t\t\tif (pos === input.length) {\n\t\t\t\treturn pos;\n\t\t\t}\n\t\t\t// Otherwise, if the next input code point is a newline, consume it.\n\t\t\telse if (_isNewLine(input.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\t// Otherwise, (the stream starts with a valid escape) consume an escaped code point and append the returned code point to the <string-token>’s value.\n\t\t\telse if (_ifTwoCodePointsAreValidEscape(input, pos)) {\n\t\t\t\tpos = _consumeAnEscapedCodePoint(input, pos);\n\t\t\t}\n\t\t}\n\t\t// anything else\n\t\t// Append the current input code point to the <string-token>’s value.\n\t\telse {\n\t\t\t// Append\n\t\t}\n\t}\n};\n\n/**\n * @param {number} cc char code\n * @param {number} q char code\n * @returns {boolean} is non-ASCII code point\n */\nconst isNonASCIICodePoint = (cc, q) =>\n\t// Simplify\n\tcc > 0x80;\n/**\n * @param {number} cc char code\n * @returns {boolean} is letter\n */\nconst isLetter = cc =>\n\t(cc >= CC_LOWER_A && cc <= CC_LOWER_Z) ||\n\t(cc >= CC_UPPER_A && cc <= CC_UPPER_Z);\n\n/**\n * @param {number} cc char code\n * @param {number} q char code\n * @returns {boolean} is identifier start code\n */\nconst _isIdentStartCodePoint = (cc, q) =>\n\tisLetter(cc) || isNonASCIICodePoint(cc, q) || cc === CC_LOW_LINE;\n\n/**\n * @param {number} cc char code\n * @param {number} q char code\n * @returns {boolean} is identifier code\n */\nconst _isIdentCodePoint = (cc, q) =>\n\t_isIdentStartCodePoint(cc, q) || _isDigit(cc) || cc === CC_HYPHEN_MINUS;\n/**\n * @param {number} cc char code\n * @returns {boolean} is digit\n */\nconst _isDigit = cc => cc >= CC_0 && cc <= CC_9;\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @param {number=} f first code point\n * @param {number=} s second code point\n * @returns {boolean} true if two code points are a valid escape\n */\nconst _ifTwoCodePointsAreValidEscape = (input, pos, f, s) => {\n\t// This section describes how to check if two code points are a valid escape.\n\t// The algorithm described here can be called explicitly with two code points, or can be called with the input stream itself.\n\t// In the latter case, the two code points in question are the current input code point and the next input code point, in that order.\n\n\t// Note: This algorithm will not consume any additional code point.\n\tconst first = f || input.charCodeAt(pos - 1);\n\tconst second = s || input.charCodeAt(pos);\n\n\t// If the first code point is not U+005C REVERSE SOLIDUS (\\), return false.\n\tif (first !== CC_REVERSE_SOLIDUS) return false;\n\t// Otherwise, if the second code point is a newline, return false.\n\tif (_isNewLine(second)) return false;\n\t// Otherwise, return true.\n\treturn true;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @param {number=} f first\n * @param {number=} s second\n * @param {number=} t third\n * @returns {boolean} true, if input at pos starts an identifier\n */\nconst _ifThreeCodePointsWouldStartAnIdentSequence = (input, pos, f, s, t) => {\n\t// This section describes how to check if three code points would start an ident sequence.\n\t// The algorithm described here can be called explicitly with three code points, or can be called with the input stream itself.\n\t// In the latter case, the three code points in question are the current input code point and the next two input code points, in that order.\n\n\t// Note: This algorithm will not consume any additional code points.\n\n\tconst first = f || input.charCodeAt(pos - 1);\n\tconst second = s || input.charCodeAt(pos);\n\tconst third = t || input.charCodeAt(pos + 1);\n\n\t// Look at the first code point:\n\n\t// U+002D HYPHEN-MINUS\n\tif (first === CC_HYPHEN_MINUS) {\n\t\t// If the second code point is an ident-start code point or a U+002D HYPHEN-MINUS\n\t\t// or a U+002D HYPHEN-MINUS, or the second and third code points are a valid escape, return true.\n\t\tif (\n\t\t\t_isIdentStartCodePoint(second, pos) ||\n\t\t\tsecond === CC_HYPHEN_MINUS ||\n\t\t\t_ifTwoCodePointsAreValidEscape(input, pos, second, third)\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t// ident-start code point\n\telse if (_isIdentStartCodePoint(first, pos - 1)) {\n\t\treturn true;\n\t}\n\t// U+005C REVERSE SOLIDUS (\\)\n\t// If the first and second code points are a valid escape, return true. Otherwise, return false.\n\telse if (first === CC_REVERSE_SOLIDUS) {\n\t\tif (_ifTwoCodePointsAreValidEscape(input, pos, first, second)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\t// anything else\n\t// Return false.\n\treturn false;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @param {number=} f first\n * @param {number=} s second\n * @param {number=} t third\n * @returns {boolean} true, if input at pos starts an identifier\n */\nconst _ifThreeCodePointsWouldStartANumber = (input, pos, f, s, t) => {\n\t// This section describes how to check if three code points would start a number.\n\t// The algorithm described here can be called explicitly with three code points, or can be called with the input stream itself.\n\t// In the latter case, the three code points in question are the current input code point and the next two input code points, in that order.\n\n\t// Note: This algorithm will not consume any additional code points.\n\n\tconst first = f || input.charCodeAt(pos - 1);\n\tconst second = s || input.charCodeAt(pos);\n\tconst third = t || input.charCodeAt(pos);\n\n\t// Look at the first code point:\n\n\t// U+002B PLUS SIGN (+)\n\t// U+002D HYPHEN-MINUS (-)\n\t//\n\t// If the second code point is a digit, return true.\n\t// Otherwise, if the second code point is a U+002E FULL STOP (.) and the third code point is a digit, return true.\n\t// Otherwise, return false.\n\tif (first === CC_PLUS_SIGN || first === CC_HYPHEN_MINUS) {\n\t\tif (_isDigit(second)) {\n\t\t\treturn true;\n\t\t} else if (second === CC_FULL_STOP && _isDigit(third)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\t// U+002E FULL STOP (.)\n\t// If the second code point is a digit, return true. Otherwise, return false.\n\telse if (first === CC_FULL_STOP) {\n\t\tif (_isDigit(second)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\t// digit\n\t// Return true.\n\telse if (_isDigit(first)) {\n\t\treturn true;\n\t}\n\n\t// anything else\n\t// Return false.\n\treturn false;\n};\n\n/** @type {CharHandler} */\nconst consumeNumberSign = (input, pos, callbacks) => {\n\t// If the next input code point is an ident code point or the next two input code points are a valid escape, then:\n\t// - Create a <hash-token>.\n\t// - If the next 3 input code points would start an ident sequence, set the <hash-token>’s type flag to \"id\".\n\t// - Consume an ident sequence, and set the <hash-token>’s value to the returned string.\n\t// - Return the <hash-token>.\n\tconst start = pos - 1;\n\tconst first = input.charCodeAt(pos);\n\tconst second = input.charCodeAt(pos + 1);\n\n\tif (\n\t\t_isIdentCodePoint(first, pos - 1) ||\n\t\t_ifTwoCodePointsAreValidEscape(input, pos, first, second)\n\t) {\n\t\tconst third = input.charCodeAt(pos + 2);\n\t\tlet isId = false;\n\n\t\tif (\n\t\t\t_ifThreeCodePointsWouldStartAnIdentSequence(\n\t\t\t\tinput,\n\t\t\t\tpos,\n\t\t\t\tfirst,\n\t\t\t\tsecond,\n\t\t\t\tthird\n\t\t\t)\n\t\t) {\n\t\t\tisId = true;\n\t\t}\n\n\t\tpos = _consumeAnIdentSequence(input, pos, callbacks);\n\n\t\tif (callbacks.hash !== undefined) {\n\t\t\treturn callbacks.hash(input, start, pos, isId);\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t// Otherwise, return a <delim-token> with its value set to the current input code point.\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeHyphenMinus = (input, pos, callbacks) => {\n\t// If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n\tif (_ifThreeCodePointsWouldStartANumber(input, pos)) {\n\t\tpos--;\n\t\treturn consumeANumericToken(input, pos, callbacks);\n\t}\n\t// Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.\n\telse if (\n\t\tinput.charCodeAt(pos) === CC_HYPHEN_MINUS &&\n\t\tinput.charCodeAt(pos + 1) === CC_GREATER_THAN_SIGN\n\t) {\n\t\treturn pos + 2;\n\t}\n\t// Otherwise, if the input stream starts with an ident sequence, reconsume the current input code point, consume an ident-like token, and return it.\n\telse if (_ifThreeCodePointsWouldStartAnIdentSequence(input, pos)) {\n\t\tpos--;\n\t\treturn consumeAnIdentLikeToken(input, pos, callbacks);\n\t}\n\n\t// Otherwise, return a <delim-token> with its value set to the current input code point.\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeFullStop = (input, pos, callbacks) => {\n\tconst start = pos - 1;\n\n\t// If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n\tif (_ifThreeCodePointsWouldStartANumber(input, pos)) {\n\t\tpos--;\n\t\treturn consumeANumericToken(input, pos, callbacks);\n\t}\n\n\t// Otherwise, return a <delim-token> with its value set to the current input code point.\n\tif (callbacks.delim !== undefined) {\n\t\treturn callbacks.delim(input, start, pos);\n\t}\n\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumePlusSign = (input, pos, callbacks) => {\n\t// If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n\tif (_ifThreeCodePointsWouldStartANumber(input, pos)) {\n\t\tpos--;\n\t\treturn consumeANumericToken(input, pos, callbacks);\n\t}\n\n\t// Otherwise, return a <delim-token> with its value set to the current input code point.\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst _consumeANumber = (input, pos) => {\n\t// This section describes how to consume a number from a stream of code points.\n\t// It returns a numeric value, and a type which is either \"integer\" or \"number\".\n\n\t// Execute the following steps in order:\n\t// Initially set type to \"integer\". Let repr be the empty string.\n\n\t// If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-), consume it and append it to repr.\n\tif (\n\t\tinput.charCodeAt(pos) === CC_HYPHEN_MINUS ||\n\t\tinput.charCodeAt(pos) === CC_PLUS_SIGN\n\t) {\n\t\tpos++;\n\t}\n\n\t// While the next input code point is a digit, consume it and append it to repr.\n\twhile (_isDigit(input.charCodeAt(pos))) {\n\t\tpos++;\n\t}\n\n\t// If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n\t// 1. Consume the next input code point and append it to number part.\n\t// 2. While the next input code point is a digit, consume it and append it to number part.\n\t// 3. Set type to \"number\".\n\tif (\n\t\tinput.charCodeAt(pos) === CC_FULL_STOP &&\n\t\t_isDigit(input.charCodeAt(pos + 1))\n\t) {\n\t\tpos++;\n\n\t\twhile (_isDigit(input.charCodeAt(pos))) {\n\t\t\tpos++;\n\t\t}\n\t}\n\n\t// If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E) or U+0065 LATIN SMALL LETTER E (e), optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+), followed by a digit, then:\n\t// 1. Consume the next input code point.\n\t// 2. If the next input code point is \"+\" or \"-\", consume it and append it to exponent part.\n\t// 3. While the next input code point is a digit, consume it and append it to exponent part.\n\t// 4. Set type to \"number\".\n\tif (\n\t\t(input.charCodeAt(pos) === CC_LOWER_E ||\n\t\t\tinput.charCodeAt(pos) === CC_UPPER_E) &&\n\t\t(((input.charCodeAt(pos + 1) === CC_HYPHEN_MINUS ||\n\t\t\tinput.charCodeAt(pos + 1) === CC_PLUS_SIGN) &&\n\t\t\t_isDigit(input.charCodeAt(pos + 2))) ||\n\t\t\t_isDigit(input.charCodeAt(pos + 1)))\n\t) {\n\t\tpos++;\n\n\t\tif (\n\t\t\tinput.charCodeAt(pos) === CC_PLUS_SIGN ||\n\t\t\tinput.charCodeAt(pos) === CC_HYPHEN_MINUS\n\t\t) {\n\t\t\tpos++;\n\t\t}\n\n\t\twhile (_isDigit(input.charCodeAt(pos))) {\n\t\t\tpos++;\n\t\t}\n\t}\n\n\t// Let value be the result of interpreting number part as a base-10 number.\n\n\t// If exponent part is non-empty, interpret it as a base-10 integer, then raise 10 to the power of the result, multiply it by value, and set value to that result.\n\n\t// Return value and type.\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeANumericToken = (input, pos, callbacks) => {\n\t// This section describes how to consume a numeric token from a stream of code points.\n\t// It returns either a <number-token>, <percentage-token>, or <dimension-token>.\n\n\t// Consume a number and let number be the result.\n\tpos = _consumeANumber(input, pos, callbacks);\n\n\t// If the next 3 input code points would start an ident sequence, then:\n\t//\n\t// - Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.\n\t// - Consume an ident sequence. Set the <dimension-token>’s unit to the returned value.\n\t// - Return the <dimension-token>.\n\n\tconst first = input.charCodeAt(pos);\n\tconst second = input.charCodeAt(pos + 1);\n\tconst third = input.charCodeAt(pos + 2);\n\n\tif (\n\t\t_ifThreeCodePointsWouldStartAnIdentSequence(\n\t\t\tinput,\n\t\t\tpos,\n\t\t\tfirst,\n\t\t\tsecond,\n\t\t\tthird\n\t\t)\n\t) {\n\t\treturn _consumeAnIdentSequence(input, pos, callbacks);\n\t}\n\t// Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.\n\t// Create a <percentage-token> with the same value as number, and return it.\n\telse if (first === CC_PERCENTAGE) {\n\t\treturn pos + 1;\n\t}\n\n\t// Otherwise, create a <number-token> with the same value and type flag as number, and return it.\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeColon = (input, pos, callbacks) => {\n\t// Return a <colon-token>.\n\tif (callbacks.colon !== undefined) {\n\t\treturn callbacks.colon(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeLeftParenthesis = (input, pos, callbacks) => {\n\t// Return a <(-token>.\n\tif (callbacks.leftParenthesis !== undefined) {\n\t\treturn callbacks.leftParenthesis(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeRightParenthesis = (input, pos, callbacks) => {\n\t// Return a <)-token>.\n\tif (callbacks.rightParenthesis !== undefined) {\n\t\treturn callbacks.rightParenthesis(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeLeftSquareBracket = (input, pos, callbacks) =>\n\t// Return a <]-token>.\n\tpos;\n\n/** @type {CharHandler} */\nconst consumeRightSquareBracket = (input, pos, callbacks) =>\n\t// Return a <]-token>.\n\tpos;\n\n/** @type {CharHandler} */\nconst consumeLeftCurlyBracket = (input, pos, callbacks) => {\n\t// Return a <{-token>.\n\tif (callbacks.leftCurlyBracket !== undefined) {\n\t\treturn callbacks.leftCurlyBracket(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeRightCurlyBracket = (input, pos, callbacks) => {\n\t// Return a <}-token>.\n\tif (callbacks.rightCurlyBracket !== undefined) {\n\t\treturn callbacks.rightCurlyBracket(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeSemicolon = (input, pos, callbacks) => {\n\t// Return a <semicolon-token>.\n\tif (callbacks.semicolon !== undefined) {\n\t\treturn callbacks.semicolon(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeComma = (input, pos, callbacks) => {\n\t// Return a <comma-token>.\n\tif (callbacks.comma !== undefined) {\n\t\treturn callbacks.comma(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst _consumeAnIdentSequence = (input, pos) => {\n\t// This section describes how to consume an ident sequence from a stream of code points.\n\t// It returns a string containing the largest name that can be formed from adjacent code points in the stream, starting from the first.\n\n\t// Note: This algorithm does not do the verification of the first few code points that are necessary to ensure the returned code points would constitute an <ident-token>.\n\t// If that is the intended use, ensure that the stream starts with an ident sequence before calling this algorithm.\n\n\t// Let result initially be an empty string.\n\n\t// Repeatedly consume the next input code point from the stream:\n\tfor (;;) {\n\t\tconst cc = input.charCodeAt(pos);\n\t\tpos++;\n\n\t\t// ident code point\n\t\t// Append the code point to result.\n\t\tif (_isIdentCodePoint(cc, pos - 1)) {\n\t\t\t// Nothing\n\t\t}\n\t\t// the stream starts with a valid escape\n\t\t// Consume an escaped code point. Append the returned code point to result.\n\t\telse if (_ifTwoCodePointsAreValidEscape(input, pos)) {\n\t\t\tpos = _consumeAnEscapedCodePoint(input, pos);\n\t\t}\n\t\t// anything else\n\t\t// Reconsume the current input code point. Return result.\n\t\telse {\n\t\t\treturn pos - 1;\n\t\t}\n\t}\n};\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, when cc is the non-printable code point, otherwise false\n */\nconst _isNonPrintableCodePoint = cc =>\n\t(cc >= 0x00 && cc <= 0x08) ||\n\tcc === 0x0b ||\n\t(cc >= 0x0e && cc <= 0x1f) ||\n\tcc === 0x7f;\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position\n */\nconst consumeTheRemnantsOfABadUrl = (input, pos) => {\n\t// This section describes how to consume the remnants of a bad url from a stream of code points,\n\t// \"cleaning up\" after the tokenizer realizes that it’s in the middle of a <bad-url-token> rather than a <url-token>.\n\t// It returns nothing; its sole use is to consume enough of the input stream to reach a recovery point where normal tokenizing can resume.\n\n\t// Repeatedly consume the next input code point from the stream:\n\tfor (;;) {\n\t\t// EOF\n\t\t// Return.\n\t\tif (pos === input.length) {\n\t\t\treturn pos;\n\t\t}\n\n\t\tconst cc = input.charCodeAt(pos);\n\t\tpos++;\n\n\t\t// U+0029 RIGHT PARENTHESIS ())\n\t\t// Return.\n\t\tif (cc === CC_RIGHT_PARENTHESIS) {\n\t\t\treturn pos;\n\t\t}\n\t\t// the input stream starts with a valid escape\n\t\t// Consume an escaped code point.\n\t\t// This allows an escaped right parenthesis (\"\\)\") to be encountered without ending the <bad-url-token>.\n\t\t// This is otherwise identical to the \"anything else\" clause.\n\t\telse if (_ifTwoCodePointsAreValidEscape(input, pos)) {\n\t\t\tpos = _consumeAnEscapedCodePoint(input, pos);\n\t\t}\n\t\t// anything else\n\t\t// Do nothing.\n\t\telse {\n\t\t\t// Do nothing.\n\t\t}\n\t}\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @param {number} fnStart start\n * @param {CssTokenCallbacks} callbacks callbacks\n * @returns {pos} pos\n */\nconst consumeAUrlToken = (input, pos, fnStart, callbacks) => {\n\t// This section describes how to consume a url token from a stream of code points.\n\t// It returns either a <url-token> or a <bad-url-token>.\n\n\t// Note: This algorithm assumes that the initial \"url(\" has already been consumed.\n\t// This algorithm also assumes that it’s being called to consume an \"unquoted\" value, like url(foo).\n\t// A quoted value, like url(\"foo\"), is parsed as a <function-token>.\n\t// Consume an ident-like token automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.\n\n\t// Initially create a <url-token> with its value set to the empty string.\n\n\t// Consume as much whitespace as possible.\n\twhile (_isWhiteSpace(input.charCodeAt(pos))) {\n\t\tpos++;\n\t}\n\n\tconst contentStart = pos;\n\n\t// Repeatedly consume the next input code point from the stream:\n\tfor (;;) {\n\t\t// EOF\n\t\t// This is a parse error. Return the <url-token>.\n\t\tif (pos === input.length) {\n\t\t\tif (callbacks.url !== undefined) {\n\t\t\t\treturn callbacks.url(input, fnStart, pos, contentStart, pos - 1);\n\t\t\t}\n\n\t\t\treturn pos;\n\t\t}\n\n\t\tconst cc = input.charCodeAt(pos);\n\t\tpos++;\n\n\t\t// U+0029 RIGHT PARENTHESIS ())\n\t\t// Return the <url-token>.\n\t\tif (cc === CC_RIGHT_PARENTHESIS) {\n\t\t\tif (callbacks.url !== undefined) {\n\t\t\t\treturn callbacks.url(input, fnStart, pos, contentStart, pos - 1);\n\t\t\t}\n\n\t\t\treturn pos;\n\t\t}\n\t\t// whitespace\n\t\t// Consume as much whitespace as possible.\n\t\t// If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF, consume it and return the <url-token>\n\t\t// (if EOF was encountered, this is a parse error); otherwise, consume the remnants of a bad url, create a <bad-url-token>, and return it.\n\t\telse if (_isWhiteSpace(cc)) {\n\t\t\tconst end = pos - 1;\n\n\t\t\twhile (_isWhiteSpace(input.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t}\n\n\t\t\tif (pos === input.length) {\n\t\t\t\tif (callbacks.url !== undefined) {\n\t\t\t\t\treturn callbacks.url(input, fnStart, pos, contentStart, end);\n\t\t\t\t}\n\n\t\t\t\treturn pos;\n\t\t\t}\n\n\t\t\tif (input.charCodeAt(pos) === CC_RIGHT_PARENTHESIS) {\n\t\t\t\tpos++;\n\n\t\t\t\tif (callbacks.url !== undefined) {\n\t\t\t\t\treturn callbacks.url(input, fnStart, pos, contentStart, end);\n\t\t\t\t}\n\n\t\t\t\treturn pos;\n\t\t\t}\n\n\t\t\t// Don't handle bad urls\n\t\t\treturn consumeTheRemnantsOfABadUrl(input, pos);\n\t\t}\n\t\t// U+0022 QUOTATION MARK (\")\n\t\t// U+0027 APOSTROPHE (')\n\t\t// U+0028 LEFT PARENTHESIS (()\n\t\t// non-printable code point\n\t\t// This is a parse error. Consume the remnants of a bad url, create a <bad-url-token>, and return it.\n\t\telse if (\n\t\t\tcc === CC_QUOTATION_MARK ||\n\t\t\tcc === CC_APOSTROPHE ||\n\t\t\tcc === CC_LEFT_PARENTHESIS ||\n\t\t\t_isNonPrintableCodePoint(cc)\n\t\t) {\n\t\t\t// Don't handle bad urls\n\t\t\treturn consumeTheRemnantsOfABadUrl(input, pos);\n\t\t}\n\t\t// // U+005C REVERSE SOLIDUS (\\)\n\t\t// // If the stream starts with a valid escape, consume an escaped code point and append the returned code point to the <url-token>’s value.\n\t\t// // Otherwise, this is a parse error. Consume the remnants of a bad url, create a <bad-url-token>, and return it.\n\t\telse if (cc === CC_REVERSE_SOLIDUS) {\n\t\t\tif (_ifTwoCodePointsAreValidEscape(input, pos)) {\n\t\t\t\tpos = _consumeAnEscapedCodePoint(input, pos);\n\t\t\t} else {\n\t\t\t\t// Don't handle bad urls\n\t\t\t\treturn consumeTheRemnantsOfABadUrl(input, pos);\n\t\t\t}\n\t\t}\n\t\t// anything else\n\t\t// Append the current input code point to the <url-token>’s value.\n\t\telse {\n\t\t\t// Nothing\n\t\t}\n\t}\n};\n\n/** @type {CharHandler} */\nconst consumeAnIdentLikeToken = (input, pos, callbacks) => {\n\tconst start = pos;\n\t// This section describes how to consume an ident-like token from a stream of code points.\n\t// It returns an <ident-token>, <function-token>, <url-token>, or <bad-url-token>.\n\tpos = _consumeAnIdentSequence(input, pos, callbacks);\n\n\t// If string’s value is an ASCII case-insensitive match for \"url\", and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n\t// While the next two input code points are whitespace, consume the next input code point.\n\t// If the next one or two input code points are U+0022 QUOTATION MARK (\"), U+0027 APOSTROPHE ('), or whitespace followed by U+0022 QUOTATION MARK (\") or U+0027 APOSTROPHE ('), then create a <function-token> with its value set to string and return it.\n\t// Otherwise, consume a url token, and return it.\n\tif (\n\t\tinput.slice(start, pos).toLowerCase() === \"url\" &&\n\t\tinput.charCodeAt(pos) === CC_LEFT_PARENTHESIS\n\t) {\n\t\tpos++;\n\t\tconst end = pos;\n\n\t\twhile (\n\t\t\t_isWhiteSpace(input.charCodeAt(pos)) &&\n\t\t\t_isWhiteSpace(input.charCodeAt(pos + 1))\n\t\t) {\n\t\t\tpos++;\n\t\t}\n\n\t\tif (\n\t\t\tinput.charCodeAt(pos) === CC_QUOTATION_MARK ||\n\t\t\tinput.charCodeAt(pos) === CC_APOSTROPHE ||\n\t\t\t(_isWhiteSpace(input.charCodeAt(pos)) &&\n\t\t\t\t(input.charCodeAt(pos + 1) === CC_QUOTATION_MARK ||\n\t\t\t\t\tinput.charCodeAt(pos + 1) === CC_APOSTROPHE))\n\t\t) {\n\t\t\tif (callbacks.function !== undefined) {\n\t\t\t\treturn callbacks.function(input, start, end);\n\t\t\t}\n\n\t\t\treturn pos;\n\t\t}\n\n\t\treturn consumeAUrlToken(input, pos, start, callbacks);\n\t}\n\n\t// Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n\t// Create a <function-token> with its value set to string and return it.\n\tif (input.charCodeAt(pos) === CC_LEFT_PARENTHESIS) {\n\t\tpos++;\n\n\t\tif (callbacks.function !== undefined) {\n\t\t\treturn callbacks.function(input, start, pos);\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t// Otherwise, create an <ident-token> with its value set to string and return it.\n\tif (callbacks.identifier !== undefined) {\n\t\treturn callbacks.identifier(input, start, pos);\n\t}\n\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeLessThan = (input, pos, _callbacks) => {\n\t// If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), consume them and return a <CDO-token>.\n\tif (input.slice(pos, pos + 3) === \"!--\") {\n\t\treturn pos + 3;\n\t}\n\n\t// Otherwise, return a <delim-token> with its value set to the current input code point.\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeCommercialAt = (input, pos, callbacks) => {\n\tconst start = pos - 1;\n\n\t// If the next 3 input code points would start an ident sequence, consume an ident sequence, create an <at-keyword-token> with its value set to the returned value, and return it.\n\tif (\n\t\t_ifThreeCodePointsWouldStartAnIdentSequence(\n\t\t\tinput,\n\t\t\tpos,\n\t\t\tinput.charCodeAt(pos),\n\t\t\tinput.charCodeAt(pos + 1),\n\t\t\tinput.charCodeAt(pos + 2)\n\t\t)\n\t) {\n\t\tpos = _consumeAnIdentSequence(input, pos, callbacks);\n\n\t\tif (callbacks.atKeyword !== undefined) {\n\t\t\tpos = callbacks.atKeyword(input, start, pos);\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t// Otherwise, return a <delim-token> with its value set to the current input code point.\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeReverseSolidus = (input, pos, callbacks) => {\n\t// If the input stream starts with a valid escape, reconsume the current input code point, consume an ident-like token, and return it.\n\tif (_ifTwoCodePointsAreValidEscape(input, pos)) {\n\t\tpos--;\n\t\treturn consumeAnIdentLikeToken(input, pos, callbacks);\n\t}\n\n\t// Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeAToken = (input, pos, callbacks) => {\n\tconst cc = input.charCodeAt(pos - 1);\n\n\t// https://drafts.csswg.org/css-syntax/#consume-token\n\tswitch (cc) {\n\t\t// whitespace\n\t\tcase CC_LINE_FEED:\n\t\tcase CC_CARRIAGE_RETURN:\n\t\tcase CC_FORM_FEED:\n\t\tcase CC_TAB:\n\t\tcase CC_SPACE:\n\t\t\treturn consumeSpace(input, pos, callbacks);\n\t\t// U+0022 QUOTATION MARK (\")\n\t\tcase CC_QUOTATION_MARK:\n\t\t\treturn consumeAStringToken(input, pos, callbacks);\n\t\t// U+0023 NUMBER SIGN (#)\n\t\tcase CC_NUMBER_SIGN:\n\t\t\treturn consumeNumberSign(input, pos, callbacks);\n\t\t// U+0027 APOSTROPHE (')\n\t\tcase CC_APOSTROPHE:\n\t\t\treturn consumeAStringToken(input, pos, callbacks);\n\t\t// U+0028 LEFT PARENTHESIS (()\n\t\tcase CC_LEFT_PARENTHESIS:\n\t\t\treturn consumeLeftParenthesis(input, pos, callbacks);\n\t\t// U+0029 RIGHT PARENTHESIS ())\n\t\tcase CC_RIGHT_PARENTHESIS:\n\t\t\treturn consumeRightParenthesis(input, pos, callbacks);\n\t\t// U+002B PLUS SIGN (+)\n\t\tcase CC_PLUS_SIGN:\n\t\t\treturn consumePlusSign(input, pos, callbacks);\n\t\t// U+002C COMMA (,)\n\t\tcase CC_COMMA:\n\t\t\treturn consumeComma(input, pos, callbacks);\n\t\t// U+002D HYPHEN-MINUS (-)\n\t\tcase CC_HYPHEN_MINUS:\n\t\t\treturn consumeHyphenMinus(input, pos, callbacks);\n\t\t// U+002E FULL STOP (.)\n\t\tcase CC_FULL_STOP:\n\t\t\treturn consumeFullStop(input, pos, callbacks);\n\t\t// U+003A COLON (:)\n\t\tcase CC_COLON:\n\t\t\treturn consumeColon(input, pos, callbacks);\n\t\t// U+003B SEMICOLON (;)\n\t\tcase CC_SEMICOLON:\n\t\t\treturn consumeSemicolon(input, pos, callbacks);\n\t\t// U+003C LESS-THAN SIGN (<)\n\t\tcase CC_LESS_THAN_SIGN:\n\t\t\treturn consumeLessThan(input, pos, callbacks);\n\t\t// U+0040 COMMERCIAL AT (@)\n\t\tcase CC_AT_SIGN:\n\t\t\treturn consumeCommercialAt(input, pos, callbacks);\n\t\t// U+005B LEFT SQUARE BRACKET ([)\n\t\tcase CC_LEFT_SQUARE:\n\t\t\treturn consumeLeftSquareBracket(input, pos, callbacks);\n\t\t// U+005C REVERSE SOLIDUS (\\)\n\t\tcase CC_REVERSE_SOLIDUS:\n\t\t\treturn consumeReverseSolidus(input, pos, callbacks);\n\t\t// U+005D RIGHT SQUARE BRACKET (])\n\t\tcase CC_RIGHT_SQUARE:\n\t\t\treturn consumeRightSquareBracket(input, pos, callbacks);\n\t\t// U+007B LEFT CURLY BRACKET ({)\n\t\tcase CC_LEFT_CURLY:\n\t\t\treturn consumeLeftCurlyBracket(input, pos, callbacks);\n\t\t// U+007D RIGHT CURLY BRACKET (})\n\t\tcase CC_RIGHT_CURLY:\n\t\t\treturn consumeRightCurlyBracket(input, pos, callbacks);\n\t\tdefault:\n\t\t\t// digit\n\t\t\t// Reconsume the current input code point, consume a numeric token, and return it.\n\t\t\tif (_isDigit(cc)) {\n\t\t\t\tpos--;\n\t\t\t\treturn consumeANumericToken(input, pos, callbacks);\n\t\t\t} else if (cc === CC_LOWER_U || cc === CC_UPPER_U) {\n\t\t\t\t// If unicode ranges allowed is true and the input stream would start a unicode-range,\n\t\t\t\t// reconsume the current input code point, consume a unicode-range token, and return it.\n\t\t\t\t// Skip now\n\t\t\t\t// if (_ifThreeCodePointsWouldStartAUnicodeRange(input, pos)) {\n\t\t\t\t// \tpos--;\n\t\t\t\t// \treturn consumeAUnicodeRangeToken(input, pos, callbacks);\n\t\t\t\t// }\n\n\t\t\t\t// Otherwise, reconsume the current input code point, consume an ident-like token, and return it.\n\t\t\t\tpos--;\n\t\t\t\treturn consumeAnIdentLikeToken(input, pos, callbacks);\n\t\t\t}\n\t\t\t// ident-start code point\n\t\t\t// Reconsume the current input code point, consume an ident-like token, and return it.\n\t\t\telse if (isIdentStartCodePoint(cc)) {\n\t\t\t\tpos--;\n\t\t\t\treturn consumeAnIdentLikeToken(input, pos, callbacks);\n\t\t\t}\n\n\t\t\t// EOF, but we don't have it\n\n\t\t\t// anything else\n\t\t\t// Return a <delim-token> with its value set to the current input code point.\n\t\t\treturn consumeDelimToken(input, pos, callbacks);\n\t}\n};\n\n/**\n * @param {string} input input css\n * @param {CssTokenCallbacks} callbacks callbacks\n * @returns {void}\n */\nmodule.exports = (input, callbacks) => {\n\t// This section describes how to consume a token from a stream of code points. It will return a single token of any type.\n\tlet pos = 0;\n\twhile (pos < input.length) {\n\t\t// Consume comments.\n\t\tpos = consumeComments(input, pos, callbacks);\n\n\t\t// Consume the next input code point.\n\t\tpos++;\n\t\tpos = consumeAToken(input, pos, callbacks);\n\t}\n};\n\nmodule.exports.isIdentStartCodePoint = isIdentStartCodePoint;\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after comments\n */\nmodule.exports.eatComments = (input, pos) => {\n\tfor (;;) {\n\t\tconst originalPos = pos;\n\t\tpos = consumeComments(input, pos, {});\n\t\tif (originalPos === pos) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace\n */\nmodule.exports.eatWhitespace = (input, pos) => {\n\twhile (_isWhiteSpace(input.charCodeAt(pos))) {\n\t\tpos++;\n\t}\n\n\treturn pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace and comments\n */\nmodule.exports.eatWhitespaceAndComments = (input, pos) => {\n\tfor (;;) {\n\t\tconst originalPos = pos;\n\t\tpos = consumeComments(input, pos, {});\n\t\twhile (_isWhiteSpace(input.charCodeAt(pos))) {\n\t\t\tpos++;\n\t\t}\n\t\tif (originalPos === pos) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace and comments\n */\nmodule.exports.eatComments = (input, pos) => {\n\tfor (;;) {\n\t\tconst originalPos = pos;\n\t\tpos = consumeComments(input, pos, {});\n\t\tif (originalPos === pos) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace\n */\nmodule.exports.eatWhiteLine = (input, pos) => {\n\tfor (;;) {\n\t\tconst cc = input.charCodeAt(pos);\n\t\tif (_isSpace(cc)) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (_isNewLine(cc)) pos++;\n\t\t// For `\\r\\n`\n\t\tif (cc === CC_CARRIAGE_RETURN && input.charCodeAt(pos + 1) === CC_LINE_FEED)\n\t\t\tpos++;\n\t\tbreak;\n\t}\n\n\treturn pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {[number, number] | undefined} positions of ident sequence\n */\nmodule.exports.skipCommentsAndEatIdentSequence = (input, pos) => {\n\tpos = module.exports.eatComments(input, pos);\n\n\tconst start = pos;\n\n\tif (\n\t\t_ifThreeCodePointsWouldStartAnIdentSequence(\n\t\t\tinput,\n\t\t\tpos,\n\t\t\tinput.charCodeAt(pos),\n\t\t\tinput.charCodeAt(pos + 1),\n\t\t\tinput.charCodeAt(pos + 2)\n\t\t)\n\t) {\n\t\treturn [start, _consumeAnIdentSequence(input, pos, {})];\n\t}\n\n\treturn undefined;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {[number, number] | undefined} positions of ident sequence\n */\nmodule.exports.eatString = (input, pos) => {\n\tpos = module.exports.eatWhitespaceAndComments(input, pos);\n\n\tconst start = pos;\n\n\tif (\n\t\tinput.charCodeAt(pos) === CC_QUOTATION_MARK ||\n\t\tinput.charCodeAt(pos) === CC_APOSTROPHE\n\t) {\n\t\treturn [start, consumeAStringToken(input, pos + 1, {})];\n\t}\n\n\treturn undefined;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @param {CssTokenCallbacks} cbs callbacks\n * @returns {[number, number][]} positions of ident sequence\n */\nmodule.exports.eatImageSetStrings = (input, pos, cbs) => {\n\t/** @type {[number, number][]} */\n\tconst result = [];\n\n\tlet isFirst = true;\n\tlet needStop = false;\n\t// We already in `func(` token\n\tlet balanced = 1;\n\n\t/** @type {CssTokenCallbacks} */\n\tconst callbacks = {\n\t\t...cbs,\n\t\tstring: (_input, start, end) => {\n\t\t\tif (isFirst && balanced === 1) {\n\t\t\t\tresult.push([start, end]);\n\t\t\t\tisFirst = false;\n\t\t\t}\n\n\t\t\treturn end;\n\t\t},\n\t\tcomma: (_input, _start, end) => {\n\t\t\tif (balanced === 1) {\n\t\t\t\tisFirst = true;\n\t\t\t}\n\n\t\t\treturn end;\n\t\t},\n\t\tleftParenthesis: (input, start, end) => {\n\t\t\tbalanced++;\n\n\t\t\treturn end;\n\t\t},\n\t\tfunction: (_input, start, end) => {\n\t\t\tbalanced++;\n\n\t\t\treturn end;\n\t\t},\n\t\trightParenthesis: (_input, _start, end) => {\n\t\t\tbalanced--;\n\n\t\t\tif (balanced === 0) {\n\t\t\t\tneedStop = true;\n\t\t\t}\n\n\t\t\treturn end;\n\t\t}\n\t};\n\n\twhile (pos < input.length) {\n\t\t// Consume comments.\n\t\tpos = consumeComments(input, pos, callbacks);\n\n\t\t// Consume the next input code point.\n\t\tpos++;\n\t\tpos = consumeAToken(input, pos, callbacks);\n\n\t\tif (needStop) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @param {CssTokenCallbacks} cbs callbacks\n * @returns {[[number, number, number, number] | undefined, [number, number] | undefined, [number, number] | undefined, [number, number] | undefined]} positions of top level tokens\n */\nmodule.exports.eatImportTokens = (input, pos, cbs) => {\n\tconst result =\n\t\t/** @type {[[number, number, number, number] | undefined, [number, number] | undefined, [number, number] | undefined, [number, number] | undefined]} */\n\t\t(new Array(4));\n\n\t/** @type {0 | 1 | 2 | undefined} */\n\tlet scope;\n\tlet needStop = false;\n\tlet balanced = 0;\n\n\t/** @type {CssTokenCallbacks} */\n\tconst callbacks = {\n\t\t...cbs,\n\t\turl: (_input, start, end, contentStart, contentEnd) => {\n\t\t\tif (\n\t\t\t\tresult[0] === undefined &&\n\t\t\t\tbalanced === 0 &&\n\t\t\t\tresult[1] === undefined &&\n\t\t\t\tresult[2] === undefined &&\n\t\t\t\tresult[3] === undefined\n\t\t\t) {\n\t\t\t\tresult[0] = [start, end, contentStart, contentEnd];\n\t\t\t\tscope = undefined;\n\t\t\t}\n\n\t\t\treturn end;\n\t\t},\n\t\tstring: (_input, start, end) => {\n\t\t\tif (\n\t\t\t\tbalanced === 0 &&\n\t\t\t\tresult[0] === undefined &&\n\t\t\t\tresult[1] === undefined &&\n\t\t\t\tresult[2] === undefined &&\n\t\t\t\tresult[3] === undefined\n\t\t\t) {\n\t\t\t\tresult[0] = [start, end, start + 1, end - 1];\n\t\t\t\tscope = undefined;\n\t\t\t} else if (result[0] !== undefined && scope === 0) {\n\t\t\t\tresult[0][2] = start + 1;\n\t\t\t\tresult[0][3] = end - 1;\n\t\t\t}\n\n\t\t\treturn end;\n\t\t},\n\t\tleftParenthesis: (_input, _start, end) => {\n\t\t\tbalanced++;\n\n\t\t\treturn end;\n\t\t},\n\t\trightParenthesis: (_input, _start, end) => {\n\t\t\tbalanced--;\n\n\t\t\tif (balanced === 0 && scope !== undefined) {\n\t\t\t\t/** @type {[number, number]} */\n\t\t\t\t(result[scope])[1] = end;\n\t\t\t\tscope = undefined;\n\t\t\t}\n\n\t\t\treturn end;\n\t\t},\n\t\tfunction: (input, start, end) => {\n\t\t\tif (balanced === 0) {\n\t\t\t\tconst name = input\n\t\t\t\t\t.slice(start, end - 1)\n\t\t\t\t\t.replace(/\\\\/g, \"\")\n\t\t\t\t\t.toLowerCase();\n\n\t\t\t\tif (\n\t\t\t\t\tname === \"url\" &&\n\t\t\t\t\tresult[0] === undefined &&\n\t\t\t\t\tresult[1] === undefined &&\n\t\t\t\t\tresult[2] === undefined &&\n\t\t\t\t\tresult[3] === undefined\n\t\t\t\t) {\n\t\t\t\t\tscope = 0;\n\t\t\t\t\tresult[scope] = [start, end + 1, end + 1, end + 1];\n\t\t\t\t} else if (\n\t\t\t\t\tname === \"layer\" &&\n\t\t\t\t\tresult[1] === undefined &&\n\t\t\t\t\tresult[2] === undefined\n\t\t\t\t) {\n\t\t\t\t\tscope = 1;\n\t\t\t\t\tresult[scope] = [start, end];\n\t\t\t\t} else if (name === \"supports\" && result[2] === undefined) {\n\t\t\t\t\tscope = 2;\n\t\t\t\t\tresult[scope] = [start, end];\n\t\t\t\t} else {\n\t\t\t\t\tscope = undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbalanced++;\n\n\t\t\treturn end;\n\t\t},\n\t\tidentifier: (input, start, end) => {\n\t\t\tif (\n\t\t\t\tbalanced === 0 &&\n\t\t\t\tresult[1] === undefined &&\n\t\t\t\tresult[2] === undefined\n\t\t\t) {\n\t\t\t\tconst name = input.slice(start, end).replace(/\\\\/g, \"\").toLowerCase();\n\n\t\t\t\tif (name === \"layer\") {\n\t\t\t\t\tresult[1] = [start, end];\n\t\t\t\t\tscope = undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn end;\n\t\t},\n\t\tsemicolon: (_input, start, end) => {\n\t\t\tif (balanced === 0) {\n\t\t\t\tneedStop = true;\n\t\t\t\tresult[3] = [start, end];\n\t\t\t}\n\n\t\t\treturn end;\n\t\t}\n\t};\n\n\twhile (pos < input.length) {\n\t\t// Consume comments.\n\t\tpos = consumeComments(input, pos, callbacks);\n\n\t\t// Consume the next input code point.\n\t\tpos++;\n\t\tpos = consumeAToken(input, pos, callbacks);\n\n\t\tif (needStop) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {[number, number] | undefined} positions of ident sequence\n */\nmodule.exports.eatIdentSequence = (input, pos) => {\n\tpos = module.exports.eatWhitespaceAndComments(input, pos);\n\n\tconst start = pos;\n\n\tif (\n\t\t_ifThreeCodePointsWouldStartAnIdentSequence(\n\t\t\tinput,\n\t\t\tpos,\n\t\t\tinput.charCodeAt(pos),\n\t\t\tinput.charCodeAt(pos + 1),\n\t\t\tinput.charCodeAt(pos + 2)\n\t\t)\n\t) {\n\t\treturn [start, _consumeAnIdentSequence(input, pos, {})];\n\t}\n\n\treturn undefined;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {[number, number, boolean] | undefined} positions of ident sequence or string\n */\nmodule.exports.eatIdentSequenceOrString = (input, pos) => {\n\tpos = module.exports.eatWhitespaceAndComments(input, pos);\n\n\tconst start = pos;\n\n\tif (\n\t\tinput.charCodeAt(pos) === CC_QUOTATION_MARK ||\n\t\tinput.charCodeAt(pos) === CC_APOSTROPHE\n\t) {\n\t\treturn [start, consumeAStringToken(input, pos + 1, {}), false];\n\t} else if (\n\t\t_ifThreeCodePointsWouldStartAnIdentSequence(\n\t\t\tinput,\n\t\t\tpos,\n\t\t\tinput.charCodeAt(pos),\n\t\t\tinput.charCodeAt(pos + 1),\n\t\t\tinput.charCodeAt(pos + 2)\n\t\t)\n\t) {\n\t\treturn [start, _consumeAnIdentSequence(input, pos, {}), true];\n\t}\n\n\treturn undefined;\n};\n\n/**\n * @param {string} chars characters\n * @returns {(input: string, pos: number) => number} function to eat characters\n */\nmodule.exports.eatUntil = chars => {\n\tconst charCodes = Array.from({ length: chars.length }, (_, i) =>\n\t\tchars.charCodeAt(i)\n\t);\n\tconst arr = Array.from(\n\t\t{ length: charCodes.reduce((a, b) => Math.max(a, b), 0) + 1 },\n\t\t() => false\n\t);\n\tfor (const cc of charCodes) {\n\t\tarr[cc] = true;\n\t}\n\n\treturn (input, pos) => {\n\t\tfor (;;) {\n\t\t\tconst cc = input.charCodeAt(pos);\n\t\t\tif (cc < arr.length && arr[cc]) {\n\t\t\t\treturn pos;\n\t\t\t}\n\t\t\tpos++;\n\t\t\tif (pos === input.length) return pos;\n\t\t}\n\t};\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}