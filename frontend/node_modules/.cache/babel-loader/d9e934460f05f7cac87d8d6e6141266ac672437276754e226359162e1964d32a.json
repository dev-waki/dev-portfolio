{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\nconst {\n  connectChunkGroupParentAndChild\n} = require(\"./GraphHelpers\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst {\n  getEntryRuntime,\n  mergeRuntime\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n * @property {ChunkGroupInfo} chunkGroupInfo\n */\n\n/**\n * @typedef {object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {RuntimeSpec} runtime the runtimes\n * @property {boolean} initialized is this chunk group initialized\n * @property {bigint | undefined} minAvailableModules current minimal set of modules available at this point\n * @property {bigint[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {Set<Module>=} skippedItems modules that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<[Module, ModuleGraphConnection[]]>=} skippedModuleConnections referenced modules that where skipped because they were not active in this runtime\n * @property {bigint | undefined} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroupInfo> | undefined} children set of children chunk groups, that will be revisited when availableModules shrink\n * @property {Set<ChunkGroupInfo> | undefined} availableSources set of chunk groups that are the source for minAvailableModules\n * @property {Set<ChunkGroupInfo> | undefined} availableChildren set of chunk groups which depend on the this chunk group as availableSource\n * @property {number} preOrderIndex next pre order index\n * @property {number} postOrderIndex next post order index\n * @property {boolean} chunkLoading has a chunk loading mechanism\n * @property {boolean} asyncChunks create async chunks\n */\n\n/**\n * @typedef {object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n/** @typedef {(Module | ConnectionState | ModuleGraphConnection)[]} BlockModulesInTuples */\n/** @typedef {(Module | ConnectionState | ModuleGraphConnection[])[]} BlockModulesInFlattenTuples */\n/** @typedef {Map<DependenciesBlock, BlockModulesInFlattenTuples>} BlockModulesMap */\n/** @typedef {Map<Chunk, bigint>} MaskByChunk */\n/** @typedef {Set<DependenciesBlock>} BlocksWithNestedBlocks */\n/** @typedef {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} BlockConnections */\n/** @typedef {Map<ChunkGroup, ChunkGroupInfo>} ChunkGroupInfoMap */\n/** @typedef {Set<ChunkGroup>} AllCreatedChunkGroups */\n/** @typedef {Map<Entrypoint, Module[]>} InputEntrypointsAndModules */\n\nconst ZERO_BIGINT = BigInt(0);\nconst ONE_BIGINT = BigInt(1);\n\n/**\n * @param {bigint} mask The mask to test\n * @param {number} ordinal The ordinal of the bit to test\n * @returns {boolean} If the ordinal-th bit is set in the mask\n */\nconst isOrdinalSetInMask = (mask, ordinal) => BigInt.asUintN(1, mask >> BigInt(ordinal)) !== ZERO_BIGINT;\n\n/**\n * @param {ModuleGraphConnection[]} connections list of connections\n * @param {RuntimeSpec} runtime for which runtime\n * @returns {ConnectionState} connection state\n */\nconst getActiveStateOfConnections = (connections, runtime) => {\n  let merged = connections[0].getActiveState(runtime);\n  if (merged === true) return true;\n  for (let i = 1; i < connections.length; i++) {\n    const c = connections[i];\n    merged = ModuleGraphConnection.addConnectionStates(merged, c.getActiveState(runtime));\n    if (merged === true) return true;\n  }\n  return merged;\n};\n\n/**\n * @param {Module} module module\n * @param {ModuleGraph} moduleGraph module graph\n * @param {RuntimeSpec} runtime runtime\n * @param {BlockModulesMap} blockModulesMap block modules map\n */\nconst extractBlockModules = (module, moduleGraph, runtime, blockModulesMap) => {\n  /** @type {DependenciesBlock | undefined} */\n  let blockCache;\n  /** @type {BlockModulesInTuples | undefined} */\n  let modules;\n\n  /** @type {BlockModulesInTuples[]} */\n  const arrays = [];\n\n  /** @type {DependenciesBlock[]} */\n  const queue = [module];\n  while (queue.length > 0) {\n    const block = /** @type {DependenciesBlock} */queue.pop();\n    /** @type {Module[]} */\n    const arr = [];\n    arrays.push(arr);\n    blockModulesMap.set(block, arr);\n    for (const b of block.blocks) {\n      queue.push(b);\n    }\n  }\n  for (const connection of moduleGraph.getOutgoingConnections(module)) {\n    const d = connection.dependency;\n    // We skip connections without dependency\n    if (!d) continue;\n    const m = connection.module;\n    // We skip connections without Module pointer\n    if (!m) continue;\n    // We skip weak connections\n    if (connection.weak) continue;\n    const block = moduleGraph.getParentBlock(d);\n    let index = moduleGraph.getParentBlockIndex(d);\n\n    // deprecated fallback\n    if (index < 0) {\n      index = /** @type {DependenciesBlock} */block.dependencies.indexOf(d);\n    }\n    if (blockCache !== block) {\n      modules = /** @type {BlockModulesInTuples} */\n\n      blockModulesMap.get(blockCache = /** @type {DependenciesBlock} */block);\n    }\n    const i = index * 3;\n    /** @type {BlockModulesInTuples} */\n    modules[i] = m;\n    /** @type {BlockModulesInTuples} */\n    modules[i + 1] = connection.getActiveState(runtime);\n    /** @type {BlockModulesInTuples} */\n    modules[i + 2] = connection;\n  }\n  for (const modules of arrays) {\n    if (modules.length === 0) continue;\n    let indexMap;\n    let length = 0;\n    outer: for (let j = 0; j < modules.length; j += 3) {\n      const m = modules[j];\n      if (m === undefined) continue;\n      const state = /** @type {ConnectionState} */modules[j + 1];\n      const connection = /** @type {ModuleGraphConnection} */modules[j + 2];\n      if (indexMap === undefined) {\n        let i = 0;\n        for (; i < length; i += 3) {\n          if (modules[i] === m) {\n            const merged = /** @type {ConnectionState} */modules[i + 1];\n            /** @type {ModuleGraphConnection[]} */\n            (/** @type {unknown} */modules[i + 2]).push(connection);\n            if (merged === true) continue outer;\n            modules[i + 1] = ModuleGraphConnection.addConnectionStates(merged, state);\n            continue outer;\n          }\n        }\n        modules[length] = m;\n        length++;\n        modules[length] = state;\n        length++;\n        /** @type {ModuleGraphConnection[]} */\n        /** @type {unknown} */modules[length] = [connection];\n        length++;\n        if (length > 30) {\n          // To avoid worse case performance, we will use an index map for\n          // linear cost access, which allows to maintain O(n) complexity\n          // while keeping allocations down to a minimum\n          indexMap = new Map();\n          for (let i = 0; i < length; i += 3) {\n            indexMap.set(modules[i], i + 1);\n          }\n        }\n      } else {\n        const idx = indexMap.get(m);\n        if (idx !== undefined) {\n          const merged = /** @type {ConnectionState} */modules[idx];\n          /** @type {ModuleGraphConnection[]} */\n          (/** @type {unknown} */modules[idx + 1]).push(connection);\n          if (merged === true) continue;\n          modules[idx] = ModuleGraphConnection.addConnectionStates(merged, state);\n        } else {\n          modules[length] = m;\n          length++;\n          modules[length] = state;\n          indexMap.set(m, length);\n          length++;\n          /** @type {ModuleGraphConnection[]} */\n          /** @type {unknown} */\n          modules[length] = [connection];\n          length++;\n        }\n      }\n    }\n    modules.length = length;\n  }\n};\n\n/**\n * @param {Logger} logger a logger\n * @param {Compilation} compilation the compilation\n * @param {InputEntrypointsAndModules} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @param {ChunkGroupInfoMap} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {BlockConnections} blockConnections connection for blocks\n * @param {BlocksWithNestedBlocks} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {AllCreatedChunkGroups} allCreatedChunkGroups filled with all chunk groups that are created here\n * @param {MaskByChunk} maskByChunk module content mask by chunk\n */\nconst visitModules = (logger, compilation, inputEntrypointsAndModules, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups, maskByChunk) => {\n  const {\n    moduleGraph,\n    chunkGraph,\n    moduleMemCaches\n  } = compilation;\n  const blockModulesRuntimeMap = new Map();\n\n  /** @type {BlockModulesMap | undefined} */\n  let blockModulesMap;\n\n  /** @type {Map<Module, number>} */\n  const ordinalByModule = new Map();\n\n  /**\n   * @param {Module} module The module to look up\n   * @returns {number} The ordinal of the module in masks\n   */\n  const getModuleOrdinal = module => {\n    let ordinal = ordinalByModule.get(module);\n    if (ordinal === undefined) {\n      ordinal = ordinalByModule.size;\n      ordinalByModule.set(module, ordinal);\n    }\n    return ordinal;\n  };\n  for (const chunk of compilation.chunks) {\n    let mask = ZERO_BIGINT;\n    for (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n      mask |= ONE_BIGINT << BigInt(getModuleOrdinal(m));\n    }\n    maskByChunk.set(chunk, mask);\n  }\n\n  /**\n   * @param {DependenciesBlock} block block\n   * @param {RuntimeSpec} runtime runtime\n   * @returns {BlockModulesInFlattenTuples} block modules in flatten tuples\n   */\n  const getBlockModules = (block, runtime) => {\n    blockModulesMap = blockModulesRuntimeMap.get(runtime);\n    if (blockModulesMap === undefined) {\n      blockModulesMap = new Map();\n      blockModulesRuntimeMap.set(runtime, blockModulesMap);\n    }\n    let blockModules = blockModulesMap.get(block);\n    if (blockModules !== undefined) return blockModules;\n    const module = /** @type {Module} */block.getRootBlock();\n    const memCache = moduleMemCaches && moduleMemCaches.get(module);\n    if (memCache !== undefined) {\n      const map = memCache.provide(\"bundleChunkGraph.blockModules\", runtime, () => {\n        logger.time(\"visitModules: prepare\");\n        const map = new Map();\n        extractBlockModules(module, moduleGraph, runtime, map);\n        logger.timeAggregate(\"visitModules: prepare\");\n        return map;\n      });\n      for (const [block, blockModules] of map) blockModulesMap.set(block, blockModules);\n      return map.get(block);\n    }\n    logger.time(\"visitModules: prepare\");\n    extractBlockModules(module, moduleGraph, runtime, blockModulesMap);\n    blockModules = /** @type {BlockModulesInFlattenTuples} */\n    blockModulesMap.get(block);\n    logger.timeAggregate(\"visitModules: prepare\");\n    return blockModules;\n  };\n  let statProcessedQueueItems = 0;\n  let statProcessedBlocks = 0;\n  let statConnectedChunkGroups = 0;\n  let statProcessedChunkGroupsForMerging = 0;\n  let statMergedAvailableModuleSets = 0;\n  const statForkedAvailableModules = 0;\n  const statForkedAvailableModulesCount = 0;\n  const statForkedAvailableModulesCountPlus = 0;\n  const statForkedMergedModulesCount = 0;\n  const statForkedMergedModulesCountPlus = 0;\n  const statForkedResultModulesCount = 0;\n  let statChunkGroupInfoUpdated = 0;\n  let statChildChunkGroupsReconnected = 0;\n  let nextChunkGroupIndex = 0;\n  let nextFreeModulePreOrderIndex = 0;\n  let nextFreeModulePostOrderIndex = 0;\n\n  /** @type {Map<DependenciesBlock, ChunkGroupInfo>} */\n  const blockChunkGroups = new Map();\n\n  /** @type {Map<ChunkGroupInfo, Set<DependenciesBlock>>} */\n  const blocksByChunkGroups = new Map();\n\n  /** @type {Map<string, ChunkGroupInfo>} */\n  const namedChunkGroups = new Map();\n\n  /** @type {Map<string, ChunkGroupInfo>} */\n  const namedAsyncEntrypoints = new Map();\n\n  /** @type {Set<ChunkGroupInfo>} */\n  const outdatedOrderIndexChunkGroups = new Set();\n  const ADD_AND_ENTER_ENTRY_MODULE = 0;\n  const ADD_AND_ENTER_MODULE = 1;\n  const ENTER_MODULE = 2;\n  const PROCESS_BLOCK = 3;\n  const PROCESS_ENTRY_BLOCK = 4;\n  const LEAVE_MODULE = 5;\n\n  /** @type {QueueItem[]} */\n  let queue = [];\n\n  /** @type {Map<ChunkGroupInfo, Set<[ChunkGroupInfo, QueueItem | null]>>} */\n  const queueConnect = new Map();\n  /** @type {Set<ChunkGroupInfo>} */\n  const chunkGroupsForCombining = new Set();\n\n  // Fill queue with entrypoint modules\n  // Create ChunkGroupInfo for entrypoints\n  for (const [chunkGroup, modules] of inputEntrypointsAndModules) {\n    const runtime = getEntryRuntime(compilation, /** @type {string} */chunkGroup.name, chunkGroup.options);\n    /** @type {ChunkGroupInfo} */\n    const chunkGroupInfo = {\n      initialized: false,\n      chunkGroup,\n      runtime,\n      minAvailableModules: undefined,\n      availableModulesToBeMerged: [],\n      skippedItems: undefined,\n      resultingAvailableModules: undefined,\n      children: undefined,\n      availableSources: undefined,\n      availableChildren: undefined,\n      preOrderIndex: 0,\n      postOrderIndex: 0,\n      chunkLoading: chunkGroup.options.chunkLoading !== undefined ? chunkGroup.options.chunkLoading !== false : compilation.outputOptions.chunkLoading !== false,\n      asyncChunks: chunkGroup.options.asyncChunks !== undefined ? chunkGroup.options.asyncChunks : compilation.outputOptions.asyncChunks !== false\n    };\n    chunkGroup.index = nextChunkGroupIndex++;\n    if (chunkGroup.getNumberOfParents() > 0) {\n      // minAvailableModules for child entrypoints are unknown yet, set to undefined.\n      // This means no module is added until other sets are merged into\n      // this minAvailableModules (by the parent entrypoints)\n      const skippedItems = new Set(modules);\n      chunkGroupInfo.skippedItems = skippedItems;\n      chunkGroupsForCombining.add(chunkGroupInfo);\n    } else {\n      // The application may start here: We start with an empty list of available modules\n      chunkGroupInfo.minAvailableModules = ZERO_BIGINT;\n      const chunk = chunkGroup.getEntrypointChunk();\n      for (const module of modules) {\n        queue.push({\n          action: ADD_AND_ENTER_MODULE,\n          block: module,\n          module,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      }\n    }\n    chunkGroupInfoMap.set(chunkGroup, chunkGroupInfo);\n    if (chunkGroup.name) {\n      namedChunkGroups.set(chunkGroup.name, chunkGroupInfo);\n    }\n  }\n  // Fill availableSources with parent-child dependencies between entrypoints\n  for (const chunkGroupInfo of chunkGroupsForCombining) {\n    const {\n      chunkGroup\n    } = chunkGroupInfo;\n    chunkGroupInfo.availableSources = new Set();\n    for (const parent of chunkGroup.parentsIterable) {\n      const parentChunkGroupInfo = /** @type {ChunkGroupInfo} */\n      chunkGroupInfoMap.get(parent);\n      chunkGroupInfo.availableSources.add(parentChunkGroupInfo);\n      if (parentChunkGroupInfo.availableChildren === undefined) {\n        parentChunkGroupInfo.availableChildren = new Set();\n      }\n      parentChunkGroupInfo.availableChildren.add(chunkGroupInfo);\n    }\n  }\n  // pop() is used to read from the queue\n  // so it need to be reversed to be iterated in\n  // correct order\n  queue.reverse();\n\n  /** @type {Set<ChunkGroupInfo>} */\n  const outdatedChunkGroupInfo = new Set();\n  /** @type {Set<[ChunkGroupInfo, QueueItem | null]>} */\n  const chunkGroupsForMerging = new Set();\n  /** @type {QueueItem[]} */\n  let queueDelayed = [];\n\n  /** @type {[Module, ModuleGraphConnection[]][]} */\n  const skipConnectionBuffer = [];\n  /** @type {Module[]} */\n  const skipBuffer = [];\n  /** @type {QueueItem[]} */\n  const queueBuffer = [];\n\n  /** @type {Module} */\n  let module;\n  /** @type {Chunk} */\n  let chunk;\n  /** @type {ChunkGroup} */\n  let chunkGroup;\n  /** @type {DependenciesBlock} */\n  let block;\n  /** @type {ChunkGroupInfo} */\n  let chunkGroupInfo;\n\n  // For each async Block in graph\n  /**\n   * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n   * @returns {void}\n   */\n  const iteratorBlock = b => {\n    // 1. We create a chunk group with single chunk in it for this Block\n    // but only once (blockChunkGroups map)\n    /** @type {ChunkGroupInfo | undefined} */\n    let cgi = blockChunkGroups.get(b);\n    /** @type {ChunkGroup | undefined} */\n    let c;\n    /** @type {Entrypoint | undefined} */\n    let entrypoint;\n    const entryOptions = b.groupOptions && b.groupOptions.entryOptions;\n    if (cgi === undefined) {\n      const chunkName = b.groupOptions && b.groupOptions.name || b.chunkName;\n      if (entryOptions) {\n        cgi = namedAsyncEntrypoints.get(/** @type {string} */chunkName);\n        if (!cgi) {\n          entrypoint = compilation.addAsyncEntrypoint(entryOptions, module, /** @type {DependencyLocation} */b.loc, /** @type {string} */b.request);\n          maskByChunk.set(entrypoint.chunks[0], ZERO_BIGINT);\n          entrypoint.index = nextChunkGroupIndex++;\n          cgi = {\n            chunkGroup: entrypoint,\n            initialized: false,\n            runtime: entrypoint.options.runtime || entrypoint.name,\n            minAvailableModules: ZERO_BIGINT,\n            availableModulesToBeMerged: [],\n            skippedItems: undefined,\n            resultingAvailableModules: undefined,\n            children: undefined,\n            availableSources: undefined,\n            availableChildren: undefined,\n            preOrderIndex: 0,\n            postOrderIndex: 0,\n            chunkLoading: entryOptions.chunkLoading !== undefined ? entryOptions.chunkLoading !== false : chunkGroupInfo.chunkLoading,\n            asyncChunks: entryOptions.asyncChunks !== undefined ? entryOptions.asyncChunks : chunkGroupInfo.asyncChunks\n          };\n          chunkGroupInfoMap.set(entrypoint, cgi);\n          chunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n          if (chunkName) {\n            namedAsyncEntrypoints.set(chunkName, cgi);\n          }\n        } else {\n          entrypoint = /** @type {Entrypoint} */cgi.chunkGroup;\n          // TODO merge entryOptions\n          entrypoint.addOrigin(module, /** @type {DependencyLocation} */b.loc, /** @type {string} */b.request);\n          chunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n        }\n\n        // 2. We enqueue the DependenciesBlock for traversal\n        queueDelayed.push({\n          action: PROCESS_ENTRY_BLOCK,\n          block: b,\n          module,\n          chunk: entrypoint.chunks[0],\n          chunkGroup: entrypoint,\n          chunkGroupInfo: cgi\n        });\n      } else if (!chunkGroupInfo.asyncChunks || !chunkGroupInfo.chunkLoading) {\n        // Just queue the block into the current chunk group\n        queue.push({\n          action: PROCESS_BLOCK,\n          block: b,\n          module,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      } else {\n        cgi = chunkName ? namedChunkGroups.get(chunkName) : undefined;\n        if (!cgi) {\n          c = compilation.addChunkInGroup(b.groupOptions || b.chunkName, module, /** @type {DependencyLocation} */b.loc, /** @type {string} */b.request);\n          maskByChunk.set(c.chunks[0], ZERO_BIGINT);\n          c.index = nextChunkGroupIndex++;\n          cgi = {\n            initialized: false,\n            chunkGroup: c,\n            runtime: chunkGroupInfo.runtime,\n            minAvailableModules: undefined,\n            availableModulesToBeMerged: [],\n            skippedItems: undefined,\n            resultingAvailableModules: undefined,\n            children: undefined,\n            availableSources: undefined,\n            availableChildren: undefined,\n            preOrderIndex: 0,\n            postOrderIndex: 0,\n            chunkLoading: chunkGroupInfo.chunkLoading,\n            asyncChunks: chunkGroupInfo.asyncChunks\n          };\n          allCreatedChunkGroups.add(c);\n          chunkGroupInfoMap.set(c, cgi);\n          if (chunkName) {\n            namedChunkGroups.set(chunkName, cgi);\n          }\n        } else {\n          c = cgi.chunkGroup;\n          if (c.isInitial()) {\n            compilation.errors.push(new AsyncDependencyToInitialChunkError(/** @type {string} */chunkName, module, /** @type {DependencyLocation} */b.loc));\n            c = chunkGroup;\n          } else {\n            c.addOptions(b.groupOptions);\n          }\n          c.addOrigin(module, /** @type {DependencyLocation} */b.loc, /** @type {string} */b.request);\n        }\n        blockConnections.set(b, []);\n      }\n      blockChunkGroups.set(b, /** @type {ChunkGroupInfo} */cgi);\n    } else if (entryOptions) {\n      entrypoint = /** @type {Entrypoint} */cgi.chunkGroup;\n    } else {\n      c = cgi.chunkGroup;\n    }\n    if (c !== undefined) {\n      // 2. We store the connection for the block\n      // to connect it later if needed\n      /** @type {BlockChunkGroupConnection[]} */\n      blockConnections.get(b).push({\n        originChunkGroupInfo: chunkGroupInfo,\n        chunkGroup: c\n      });\n\n      // 3. We enqueue the chunk group info creation/updating\n      let connectList = queueConnect.get(chunkGroupInfo);\n      if (connectList === undefined) {\n        connectList = new Set();\n        queueConnect.set(chunkGroupInfo, connectList);\n      }\n      connectList.add([(/** @type {ChunkGroupInfo} */cgi), {\n        action: PROCESS_BLOCK,\n        block: b,\n        module,\n        chunk: c.chunks[0],\n        chunkGroup: c,\n        chunkGroupInfo: (/** @type {ChunkGroupInfo} */cgi)\n      }]);\n    } else if (entrypoint !== undefined) {\n      chunkGroupInfo.chunkGroup.addAsyncEntrypoint(entrypoint);\n    }\n  };\n\n  /**\n   * @param {DependenciesBlock} block the block\n   * @returns {void}\n   */\n  const processBlock = block => {\n    statProcessedBlocks++;\n    // get prepared block info\n    const blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n    if (blockModules !== undefined) {\n      const minAvailableModules = /** @type {bigint} */\n      chunkGroupInfo.minAvailableModules;\n      // Buffer items because order need to be reversed to get indices correct\n      // Traverse all referenced modules\n      for (let i = 0, len = blockModules.length; i < len; i += 3) {\n        const refModule = /** @type {Module} */blockModules[i];\n        // For single comparisons this might be cheaper\n        const isModuleInChunk = chunkGraph.isModuleInChunk(refModule, chunk);\n        if (isModuleInChunk) {\n          // skip early if already connected\n          continue;\n        }\n        const refOrdinal = /** @type {number} */getModuleOrdinal(refModule);\n        const activeState = /** @type {ConnectionState} */\n        blockModules[i + 1];\n        if (activeState !== true) {\n          const connections = /** @type {ModuleGraphConnection[]} */\n          blockModules[i + 2];\n          skipConnectionBuffer.push([refModule, connections]);\n          // We skip inactive connections\n          if (activeState === false) continue;\n        } else if (isOrdinalSetInMask(minAvailableModules, refOrdinal)) {\n          // already in parent chunks, skip it for now\n          skipBuffer.push(refModule);\n          continue;\n        }\n        // enqueue, then add and enter to be in the correct order\n        // this is relevant with circular dependencies\n        queueBuffer.push({\n          action: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n          block: refModule,\n          module: refModule,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      }\n      // Add buffered items in reverse order\n      if (skipConnectionBuffer.length > 0) {\n        let {\n          skippedModuleConnections\n        } = chunkGroupInfo;\n        if (skippedModuleConnections === undefined) {\n          chunkGroupInfo.skippedModuleConnections = skippedModuleConnections = new Set();\n        }\n        for (let i = skipConnectionBuffer.length - 1; i >= 0; i--) {\n          skippedModuleConnections.add(skipConnectionBuffer[i]);\n        }\n        skipConnectionBuffer.length = 0;\n      }\n      if (skipBuffer.length > 0) {\n        let {\n          skippedItems\n        } = chunkGroupInfo;\n        if (skippedItems === undefined) {\n          chunkGroupInfo.skippedItems = skippedItems = new Set();\n        }\n        for (let i = skipBuffer.length - 1; i >= 0; i--) {\n          skippedItems.add(skipBuffer[i]);\n        }\n        skipBuffer.length = 0;\n      }\n      if (queueBuffer.length > 0) {\n        for (let i = queueBuffer.length - 1; i >= 0; i--) {\n          queue.push(queueBuffer[i]);\n        }\n        queueBuffer.length = 0;\n      }\n    }\n\n    // Traverse all Blocks\n    for (const b of block.blocks) {\n      iteratorBlock(b);\n    }\n    if (block.blocks.length > 0 && module !== block) {\n      blocksWithNestedBlocks.add(block);\n    }\n  };\n\n  /**\n   * @param {DependenciesBlock} block the block\n   * @returns {void}\n   */\n  const processEntryBlock = block => {\n    statProcessedBlocks++;\n    // get prepared block info\n    const blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n    if (blockModules !== undefined) {\n      // Traverse all referenced modules in reverse order\n      for (let i = blockModules.length - 3; i >= 0; i -= 3) {\n        const refModule = /** @type {Module} */blockModules[i];\n        const activeState = /** @type {ConnectionState} */\n        blockModules[i + 1];\n        // enqueue, then add and enter to be in the correct order\n        // this is relevant with circular dependencies\n        queue.push({\n          action: activeState === true ? ADD_AND_ENTER_ENTRY_MODULE : PROCESS_BLOCK,\n          block: refModule,\n          module: refModule,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      }\n    }\n\n    // Traverse all Blocks\n    for (const b of block.blocks) {\n      iteratorBlock(b);\n    }\n    if (block.blocks.length > 0 && module !== block) {\n      blocksWithNestedBlocks.add(block);\n    }\n  };\n  const processQueue = () => {\n    while (queue.length) {\n      statProcessedQueueItems++;\n      const queueItem = /** @type {QueueItem} */queue.pop();\n      module = queueItem.module;\n      block = queueItem.block;\n      chunk = queueItem.chunk;\n      chunkGroup = queueItem.chunkGroup;\n      chunkGroupInfo = queueItem.chunkGroupInfo;\n      switch (queueItem.action) {\n        case ADD_AND_ENTER_ENTRY_MODULE:\n          chunkGraph.connectChunkAndEntryModule(chunk, module, /** @type {Entrypoint} */chunkGroup);\n        // fallthrough\n        case ADD_AND_ENTER_MODULE:\n          {\n            const isModuleInChunk = chunkGraph.isModuleInChunk(module, chunk);\n            if (isModuleInChunk) {\n              // already connected, skip it\n              break;\n            }\n            // We connect Module and Chunk\n            chunkGraph.connectChunkAndModule(chunk, module);\n            const moduleOrdinal = getModuleOrdinal(module);\n            let chunkMask = /** @type {bigint} */maskByChunk.get(chunk);\n            chunkMask |= ONE_BIGINT << BigInt(moduleOrdinal);\n            maskByChunk.set(chunk, chunkMask);\n          }\n        // fallthrough\n        case ENTER_MODULE:\n          {\n            const index = chunkGroup.getModulePreOrderIndex(module);\n            if (index === undefined) {\n              chunkGroup.setModulePreOrderIndex(module, chunkGroupInfo.preOrderIndex++);\n            }\n            if (moduleGraph.setPreOrderIndexIfUnset(module, nextFreeModulePreOrderIndex)) {\n              nextFreeModulePreOrderIndex++;\n            }\n\n            // reuse queueItem\n            queueItem.action = LEAVE_MODULE;\n            queue.push(queueItem);\n          }\n        // fallthrough\n        case PROCESS_BLOCK:\n          {\n            processBlock(block);\n            break;\n          }\n        case PROCESS_ENTRY_BLOCK:\n          {\n            processEntryBlock(block);\n            break;\n          }\n        case LEAVE_MODULE:\n          {\n            const index = chunkGroup.getModulePostOrderIndex(module);\n            if (index === undefined) {\n              chunkGroup.setModulePostOrderIndex(module, chunkGroupInfo.postOrderIndex++);\n            }\n            if (moduleGraph.setPostOrderIndexIfUnset(module, nextFreeModulePostOrderIndex)) {\n              nextFreeModulePostOrderIndex++;\n            }\n            break;\n          }\n      }\n    }\n  };\n\n  /**\n   * @param {ChunkGroupInfo} chunkGroupInfo The info object for the chunk group\n   * @returns {bigint} The mask of available modules after the chunk group\n   */\n  const calculateResultingAvailableModules = chunkGroupInfo => {\n    if (chunkGroupInfo.resultingAvailableModules !== undefined) return chunkGroupInfo.resultingAvailableModules;\n    let resultingAvailableModules = /** @type {bigint} */\n    chunkGroupInfo.minAvailableModules;\n\n    // add the modules from the chunk group to the set\n    for (const chunk of chunkGroupInfo.chunkGroup.chunks) {\n      const mask = /** @type {bigint} */maskByChunk.get(chunk);\n      resultingAvailableModules |= mask;\n    }\n    return chunkGroupInfo.resultingAvailableModules = resultingAvailableModules;\n  };\n  const processConnectQueue = () => {\n    // Figure out new parents for chunk groups\n    // to get new available modules for these children\n    for (const [chunkGroupInfo, targets] of queueConnect) {\n      // 1. Add new targets to the list of children\n      if (chunkGroupInfo.children === undefined) {\n        chunkGroupInfo.children = new Set();\n      }\n      for (const [target] of targets) {\n        chunkGroupInfo.children.add(target);\n      }\n\n      // 2. Calculate resulting available modules\n      const resultingAvailableModules = calculateResultingAvailableModules(chunkGroupInfo);\n      const runtime = chunkGroupInfo.runtime;\n\n      // 3. Update chunk group info\n      for (const [target, processBlock] of targets) {\n        target.availableModulesToBeMerged.push(resultingAvailableModules);\n        chunkGroupsForMerging.add([target, processBlock]);\n        const oldRuntime = target.runtime;\n        const newRuntime = mergeRuntime(oldRuntime, runtime);\n        if (oldRuntime !== newRuntime) {\n          target.runtime = newRuntime;\n          outdatedChunkGroupInfo.add(target);\n        }\n      }\n      statConnectedChunkGroups += targets.size;\n    }\n    queueConnect.clear();\n  };\n  const processChunkGroupsForMerging = () => {\n    statProcessedChunkGroupsForMerging += chunkGroupsForMerging.size;\n\n    // Execute the merge\n    for (const [info, processBlock] of chunkGroupsForMerging) {\n      const availableModulesToBeMerged = info.availableModulesToBeMerged;\n      const cachedMinAvailableModules = info.minAvailableModules;\n      let minAvailableModules = cachedMinAvailableModules;\n      statMergedAvailableModuleSets += availableModulesToBeMerged.length;\n      for (const availableModules of availableModulesToBeMerged) {\n        if (minAvailableModules === undefined) {\n          minAvailableModules = availableModules;\n        } else {\n          minAvailableModules &= availableModules;\n        }\n      }\n      const changed = minAvailableModules !== cachedMinAvailableModules;\n      availableModulesToBeMerged.length = 0;\n      if (changed) {\n        info.minAvailableModules = minAvailableModules;\n        info.resultingAvailableModules = undefined;\n        outdatedChunkGroupInfo.add(info);\n      }\n      if (processBlock) {\n        let blocks = blocksByChunkGroups.get(info);\n        if (!blocks) {\n          blocksByChunkGroups.set(info, blocks = new Set());\n        }\n\n        // Whether to walk block depends on minAvailableModules and input block.\n        // We can treat creating chunk group as a function with 2 input, entry block and minAvailableModules\n        // If input is the same, we can skip re-walk\n        let needWalkBlock = !info.initialized || changed;\n        if (!blocks.has(processBlock.block)) {\n          needWalkBlock = true;\n          blocks.add(processBlock.block);\n        }\n        if (needWalkBlock) {\n          info.initialized = true;\n          queueDelayed.push(processBlock);\n        }\n      }\n    }\n    chunkGroupsForMerging.clear();\n  };\n  const processChunkGroupsForCombining = () => {\n    for (const info of chunkGroupsForCombining) {\n      for (const source of (/** @type {Set<ChunkGroupInfo>} */\n      info.availableSources)) {\n        if (source.minAvailableModules === undefined) {\n          chunkGroupsForCombining.delete(info);\n          break;\n        }\n      }\n    }\n    for (const info of chunkGroupsForCombining) {\n      let availableModules = ZERO_BIGINT;\n      // combine minAvailableModules from all resultingAvailableModules\n      for (const source of (/** @type {Set<ChunkGroupInfo>} */\n      info.availableSources)) {\n        const resultingAvailableModules = calculateResultingAvailableModules(source);\n        availableModules |= resultingAvailableModules;\n      }\n      info.minAvailableModules = availableModules;\n      info.resultingAvailableModules = undefined;\n      outdatedChunkGroupInfo.add(info);\n    }\n    chunkGroupsForCombining.clear();\n  };\n  const processOutdatedChunkGroupInfo = () => {\n    statChunkGroupInfoUpdated += outdatedChunkGroupInfo.size;\n    // Revisit skipped elements\n    for (const info of outdatedChunkGroupInfo) {\n      // 1. Reconsider skipped items\n      if (info.skippedItems !== undefined) {\n        const minAvailableModules = /** @type {bigint} */\n        info.minAvailableModules;\n        for (const module of info.skippedItems) {\n          const ordinal = getModuleOrdinal(module);\n          if (!isOrdinalSetInMask(minAvailableModules, ordinal)) {\n            queue.push({\n              action: ADD_AND_ENTER_MODULE,\n              block: module,\n              module,\n              chunk: info.chunkGroup.chunks[0],\n              chunkGroup: info.chunkGroup,\n              chunkGroupInfo: info\n            });\n            info.skippedItems.delete(module);\n          }\n        }\n      }\n\n      // 2. Reconsider skipped connections\n      if (info.skippedModuleConnections !== undefined) {\n        const minAvailableModules = /** @type {bigint} */\n        info.minAvailableModules;\n        for (const entry of info.skippedModuleConnections) {\n          const [module, connections] = entry;\n          const activeState = getActiveStateOfConnections(connections, info.runtime);\n          if (activeState === false) continue;\n          if (activeState === true) {\n            const ordinal = getModuleOrdinal(module);\n            info.skippedModuleConnections.delete(entry);\n            if (isOrdinalSetInMask(minAvailableModules, ordinal)) {\n              /** @type {NonNullable<ChunkGroupInfo[\"skippedItems\"]>} */\n              info.skippedItems.add(module);\n              continue;\n            }\n          }\n          queue.push({\n            action: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n            block: module,\n            module,\n            chunk: info.chunkGroup.chunks[0],\n            chunkGroup: info.chunkGroup,\n            chunkGroupInfo: info\n          });\n        }\n      }\n\n      // 2. Reconsider children chunk groups\n      if (info.children !== undefined) {\n        statChildChunkGroupsReconnected += info.children.size;\n        for (const cgi of info.children) {\n          let connectList = queueConnect.get(info);\n          if (connectList === undefined) {\n            connectList = new Set();\n            queueConnect.set(info, connectList);\n          }\n          connectList.add([cgi, null]);\n        }\n      }\n\n      // 3. Reconsider chunk groups for combining\n      if (info.availableChildren !== undefined) {\n        for (const cgi of info.availableChildren) {\n          chunkGroupsForCombining.add(cgi);\n        }\n      }\n      outdatedOrderIndexChunkGroups.add(info);\n    }\n    outdatedChunkGroupInfo.clear();\n  };\n\n  // Iterative traversal of the Module graph\n  // Recursive would be simpler to write but could result in Stack Overflows\n  while (queue.length || queueConnect.size) {\n    logger.time(\"visitModules: visiting\");\n    processQueue();\n    logger.timeAggregateEnd(\"visitModules: prepare\");\n    logger.timeEnd(\"visitModules: visiting\");\n    if (chunkGroupsForCombining.size > 0) {\n      logger.time(\"visitModules: combine available modules\");\n      processChunkGroupsForCombining();\n      logger.timeEnd(\"visitModules: combine available modules\");\n    }\n    if (queueConnect.size > 0) {\n      logger.time(\"visitModules: calculating available modules\");\n      processConnectQueue();\n      logger.timeEnd(\"visitModules: calculating available modules\");\n      if (chunkGroupsForMerging.size > 0) {\n        logger.time(\"visitModules: merging available modules\");\n        processChunkGroupsForMerging();\n        logger.timeEnd(\"visitModules: merging available modules\");\n      }\n    }\n    if (outdatedChunkGroupInfo.size > 0) {\n      logger.time(\"visitModules: check modules for revisit\");\n      processOutdatedChunkGroupInfo();\n      logger.timeEnd(\"visitModules: check modules for revisit\");\n    }\n\n    // Run queueDelayed when all items of the queue are processed\n    // This is important to get the global indexing correct\n    // Async blocks should be processed after all sync blocks are processed\n    if (queue.length === 0) {\n      const tempQueue = queue;\n      queue = queueDelayed.reverse();\n      queueDelayed = tempQueue;\n    }\n  }\n  for (const info of outdatedOrderIndexChunkGroups) {\n    const {\n      chunkGroup,\n      runtime\n    } = info;\n    const blocks = blocksByChunkGroups.get(info);\n    if (!blocks) {\n      continue;\n    }\n    for (const block of blocks) {\n      let preOrderIndex = 0;\n      let postOrderIndex = 0;\n      /**\n       * @param {DependenciesBlock} current current\n       * @param {BlocksWithNestedBlocks} visited visited dependencies blocks\n       */\n      const process = (current, visited) => {\n        const blockModules = getBlockModules(current, runtime);\n        for (let i = 0, len = blockModules.length; i < len; i += 3) {\n          const activeState = /** @type {ConnectionState} */\n          blockModules[i + 1];\n          if (activeState === false) {\n            continue;\n          }\n          const refModule = /** @type {Module} */blockModules[i];\n          if (visited.has(refModule)) {\n            continue;\n          }\n          visited.add(refModule);\n          if (refModule) {\n            chunkGroup.setModulePreOrderIndex(refModule, preOrderIndex++);\n            process(refModule, visited);\n            chunkGroup.setModulePostOrderIndex(refModule, postOrderIndex++);\n          }\n        }\n      };\n      process(block, new Set());\n    }\n  }\n  outdatedOrderIndexChunkGroups.clear();\n  ordinalByModule.clear();\n  logger.log(`${statProcessedQueueItems} queue items processed (${statProcessedBlocks} blocks)`);\n  logger.log(`${statConnectedChunkGroups} chunk groups connected`);\n  logger.log(`${statProcessedChunkGroupsForMerging} chunk groups processed for merging (${statMergedAvailableModuleSets} module sets, ${statForkedAvailableModules} forked, ${statForkedAvailableModulesCount} + ${statForkedAvailableModulesCountPlus} modules forked, ${statForkedMergedModulesCount} + ${statForkedMergedModulesCountPlus} modules merged into fork, ${statForkedResultModulesCount} resulting modules)`);\n  logger.log(`${statChunkGroupInfoUpdated} chunk group info updated (${statChildChunkGroupsReconnected} already connected chunk groups reconnected)`);\n};\n\n/**\n * @param {Compilation} compilation the compilation\n * @param {BlocksWithNestedBlocks} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {BlockConnections} blockConnections connection for blocks\n * @param {MaskByChunk} maskByChunk mapping from chunk to module mask\n */\nconst connectChunkGroups = (compilation, blocksWithNestedBlocks, blockConnections, maskByChunk) => {\n  const {\n    chunkGraph\n  } = compilation;\n\n  /**\n   * Helper function to check if all modules of a chunk are available\n   * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n   * @param {bigint} availableModules the comparator set\n   * @returns {boolean} return true if all modules of a chunk are available\n   */\n  const areModulesAvailable = (chunkGroup, availableModules) => {\n    for (const chunk of chunkGroup.chunks) {\n      const chunkMask = /** @type {bigint} */maskByChunk.get(chunk);\n      if ((chunkMask & availableModules) !== chunkMask) return false;\n    }\n    return true;\n  };\n\n  // For each edge in the basic chunk graph\n  for (const [block, connections] of blockConnections) {\n    // 1. Check if connection is needed\n    // When none of the dependencies need to be connected\n    // we can skip all of them\n    // It's not possible to filter each item so it doesn't create inconsistent\n    // connections and modules can only create one version\n    // TODO maybe decide this per runtime\n    if (\n    // TODO is this needed?\n    !blocksWithNestedBlocks.has(block) && connections.every(({\n      chunkGroup,\n      originChunkGroupInfo\n    }) => areModulesAvailable(chunkGroup, /** @type {bigint} */originChunkGroupInfo.resultingAvailableModules))) {\n      continue;\n    }\n\n    // 2. Foreach edge\n    for (let i = 0; i < connections.length; i++) {\n      const {\n        chunkGroup,\n        originChunkGroupInfo\n      } = connections[i];\n\n      // 3. Connect block with chunk\n      chunkGraph.connectBlockAndChunkGroup(block, chunkGroup);\n\n      // 4. Connect chunk with parent\n      connectChunkGroupParentAndChild(originChunkGroupInfo.chunkGroup, chunkGroup);\n    }\n  }\n};\n\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n  const {\n    chunkGraph\n  } = compilation;\n  for (const chunkGroup of allCreatedChunkGroups) {\n    if (chunkGroup.getNumberOfParents() === 0) {\n      for (const chunk of chunkGroup.chunks) {\n        compilation.chunks.delete(chunk);\n        chunkGraph.disconnectChunk(chunk);\n      }\n      chunkGraph.disconnectChunkGroup(chunkGroup);\n      chunkGroup.remove();\n    }\n  }\n};\n\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {InputEntrypointsAndModules} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @returns {void}\n */\nconst buildChunkGraph = (compilation, inputEntrypointsAndModules) => {\n  const logger = compilation.getLogger(\"webpack.buildChunkGraph\");\n\n  // SHARED STATE\n\n  /** @type {BlockConnections} */\n  const blockConnections = new Map();\n\n  /** @type {AllCreatedChunkGroups} */\n  const allCreatedChunkGroups = new Set();\n\n  /** @type {ChunkGroupInfoMap} */\n  const chunkGroupInfoMap = new Map();\n\n  /** @type {BlocksWithNestedBlocks} */\n  const blocksWithNestedBlocks = new Set();\n\n  /** @type {MaskByChunk} */\n  const maskByChunk = new Map();\n\n  // PART ONE\n\n  logger.time(\"visitModules\");\n  visitModules(logger, compilation, inputEntrypointsAndModules, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups, maskByChunk);\n  logger.timeEnd(\"visitModules\");\n\n  // PART TWO\n\n  logger.time(\"connectChunkGroups\");\n  connectChunkGroups(compilation, blocksWithNestedBlocks, blockConnections, maskByChunk);\n  logger.timeEnd(\"connectChunkGroups\");\n  for (const [chunkGroup, chunkGroupInfo] of chunkGroupInfoMap) {\n    for (const chunk of chunkGroup.chunks) chunk.runtime = mergeRuntime(chunk.runtime, chunkGroupInfo.runtime);\n  }\n\n  // Cleanup work\n\n  logger.time(\"cleanup\");\n  cleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n  logger.timeEnd(\"cleanup\");\n};\nmodule.exports = buildChunkGraph;","map":{"version":3,"names":["AsyncDependencyToInitialChunkError","require","connectChunkGroupParentAndChild","ModuleGraphConnection","getEntryRuntime","mergeRuntime","ZERO_BIGINT","BigInt","ONE_BIGINT","isOrdinalSetInMask","mask","ordinal","asUintN","getActiveStateOfConnections","connections","runtime","merged","getActiveState","i","length","c","addConnectionStates","extractBlockModules","module","moduleGraph","blockModulesMap","blockCache","modules","arrays","queue","block","pop","arr","push","set","b","blocks","connection","getOutgoingConnections","d","dependency","m","weak","getParentBlock","index","getParentBlockIndex","dependencies","indexOf","get","indexMap","outer","j","undefined","state","Map","idx","visitModules","logger","compilation","inputEntrypointsAndModules","chunkGroupInfoMap","blockConnections","blocksWithNestedBlocks","allCreatedChunkGroups","maskByChunk","chunkGraph","moduleMemCaches","blockModulesRuntimeMap","ordinalByModule","getModuleOrdinal","size","chunk","chunks","getChunkModulesIterable","getBlockModules","blockModules","getRootBlock","memCache","map","provide","time","timeAggregate","statProcessedQueueItems","statProcessedBlocks","statConnectedChunkGroups","statProcessedChunkGroupsForMerging","statMergedAvailableModuleSets","statForkedAvailableModules","statForkedAvailableModulesCount","statForkedAvailableModulesCountPlus","statForkedMergedModulesCount","statForkedMergedModulesCountPlus","statForkedResultModulesCount","statChunkGroupInfoUpdated","statChildChunkGroupsReconnected","nextChunkGroupIndex","nextFreeModulePreOrderIndex","nextFreeModulePostOrderIndex","blockChunkGroups","blocksByChunkGroups","namedChunkGroups","namedAsyncEntrypoints","outdatedOrderIndexChunkGroups","Set","ADD_AND_ENTER_ENTRY_MODULE","ADD_AND_ENTER_MODULE","ENTER_MODULE","PROCESS_BLOCK","PROCESS_ENTRY_BLOCK","LEAVE_MODULE","queueConnect","chunkGroupsForCombining","chunkGroup","name","options","chunkGroupInfo","initialized","minAvailableModules","availableModulesToBeMerged","skippedItems","resultingAvailableModules","children","availableSources","availableChildren","preOrderIndex","postOrderIndex","chunkLoading","outputOptions","asyncChunks","getNumberOfParents","add","getEntrypointChunk","action","parent","parentsIterable","parentChunkGroupInfo","reverse","outdatedChunkGroupInfo","chunkGroupsForMerging","queueDelayed","skipConnectionBuffer","skipBuffer","queueBuffer","iteratorBlock","cgi","entrypoint","entryOptions","groupOptions","chunkName","addAsyncEntrypoint","loc","request","connectBlockAndChunkGroup","addOrigin","addChunkInGroup","isInitial","errors","addOptions","originChunkGroupInfo","connectList","processBlock","len","refModule","isModuleInChunk","refOrdinal","activeState","skippedModuleConnections","processEntryBlock","processQueue","queueItem","connectChunkAndEntryModule","connectChunkAndModule","moduleOrdinal","chunkMask","getModulePreOrderIndex","setModulePreOrderIndex","setPreOrderIndexIfUnset","getModulePostOrderIndex","setModulePostOrderIndex","setPostOrderIndexIfUnset","calculateResultingAvailableModules","processConnectQueue","targets","target","oldRuntime","newRuntime","clear","processChunkGroupsForMerging","info","cachedMinAvailableModules","availableModules","changed","needWalkBlock","has","processChunkGroupsForCombining","source","delete","processOutdatedChunkGroupInfo","entry","timeAggregateEnd","timeEnd","tempQueue","process","current","visited","log","connectChunkGroups","areModulesAvailable","every","cleanupUnconnectedGroups","disconnectChunk","disconnectChunkGroup","remove","buildChunkGraph","getLogger","exports"],"sources":["/home/wickliff/Desktop/dev-waki/portfolio2/node_modules/webpack/lib/buildChunkGraph.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\nconst { connectChunkGroupParentAndChild } = require(\"./GraphHelpers\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst { getEntryRuntime, mergeRuntime } = require(\"./util/runtime\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n * @property {ChunkGroupInfo} chunkGroupInfo\n */\n\n/**\n * @typedef {object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {RuntimeSpec} runtime the runtimes\n * @property {boolean} initialized is this chunk group initialized\n * @property {bigint | undefined} minAvailableModules current minimal set of modules available at this point\n * @property {bigint[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {Set<Module>=} skippedItems modules that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<[Module, ModuleGraphConnection[]]>=} skippedModuleConnections referenced modules that where skipped because they were not active in this runtime\n * @property {bigint | undefined} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroupInfo> | undefined} children set of children chunk groups, that will be revisited when availableModules shrink\n * @property {Set<ChunkGroupInfo> | undefined} availableSources set of chunk groups that are the source for minAvailableModules\n * @property {Set<ChunkGroupInfo> | undefined} availableChildren set of chunk groups which depend on the this chunk group as availableSource\n * @property {number} preOrderIndex next pre order index\n * @property {number} postOrderIndex next post order index\n * @property {boolean} chunkLoading has a chunk loading mechanism\n * @property {boolean} asyncChunks create async chunks\n */\n\n/**\n * @typedef {object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n/** @typedef {(Module | ConnectionState | ModuleGraphConnection)[]} BlockModulesInTuples */\n/** @typedef {(Module | ConnectionState | ModuleGraphConnection[])[]} BlockModulesInFlattenTuples */\n/** @typedef {Map<DependenciesBlock, BlockModulesInFlattenTuples>} BlockModulesMap */\n/** @typedef {Map<Chunk, bigint>} MaskByChunk */\n/** @typedef {Set<DependenciesBlock>} BlocksWithNestedBlocks */\n/** @typedef {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} BlockConnections */\n/** @typedef {Map<ChunkGroup, ChunkGroupInfo>} ChunkGroupInfoMap */\n/** @typedef {Set<ChunkGroup>} AllCreatedChunkGroups */\n/** @typedef {Map<Entrypoint, Module[]>} InputEntrypointsAndModules */\n\nconst ZERO_BIGINT = BigInt(0);\nconst ONE_BIGINT = BigInt(1);\n\n/**\n * @param {bigint} mask The mask to test\n * @param {number} ordinal The ordinal of the bit to test\n * @returns {boolean} If the ordinal-th bit is set in the mask\n */\nconst isOrdinalSetInMask = (mask, ordinal) =>\n\tBigInt.asUintN(1, mask >> BigInt(ordinal)) !== ZERO_BIGINT;\n\n/**\n * @param {ModuleGraphConnection[]} connections list of connections\n * @param {RuntimeSpec} runtime for which runtime\n * @returns {ConnectionState} connection state\n */\nconst getActiveStateOfConnections = (connections, runtime) => {\n\tlet merged = connections[0].getActiveState(runtime);\n\tif (merged === true) return true;\n\tfor (let i = 1; i < connections.length; i++) {\n\t\tconst c = connections[i];\n\t\tmerged = ModuleGraphConnection.addConnectionStates(\n\t\t\tmerged,\n\t\t\tc.getActiveState(runtime)\n\t\t);\n\t\tif (merged === true) return true;\n\t}\n\treturn merged;\n};\n\n/**\n * @param {Module} module module\n * @param {ModuleGraph} moduleGraph module graph\n * @param {RuntimeSpec} runtime runtime\n * @param {BlockModulesMap} blockModulesMap block modules map\n */\nconst extractBlockModules = (module, moduleGraph, runtime, blockModulesMap) => {\n\t/** @type {DependenciesBlock | undefined} */\n\tlet blockCache;\n\t/** @type {BlockModulesInTuples | undefined} */\n\tlet modules;\n\n\t/** @type {BlockModulesInTuples[]} */\n\tconst arrays = [];\n\n\t/** @type {DependenciesBlock[]} */\n\tconst queue = [module];\n\twhile (queue.length > 0) {\n\t\tconst block = /** @type {DependenciesBlock} */ (queue.pop());\n\t\t/** @type {Module[]} */\n\t\tconst arr = [];\n\t\tarrays.push(arr);\n\t\tblockModulesMap.set(block, arr);\n\t\tfor (const b of block.blocks) {\n\t\t\tqueue.push(b);\n\t\t}\n\t}\n\n\tfor (const connection of moduleGraph.getOutgoingConnections(module)) {\n\t\tconst d = connection.dependency;\n\t\t// We skip connections without dependency\n\t\tif (!d) continue;\n\t\tconst m = connection.module;\n\t\t// We skip connections without Module pointer\n\t\tif (!m) continue;\n\t\t// We skip weak connections\n\t\tif (connection.weak) continue;\n\n\t\tconst block = moduleGraph.getParentBlock(d);\n\t\tlet index = moduleGraph.getParentBlockIndex(d);\n\n\t\t// deprecated fallback\n\t\tif (index < 0) {\n\t\t\tindex = /** @type {DependenciesBlock} */ (block).dependencies.indexOf(d);\n\t\t}\n\n\t\tif (blockCache !== block) {\n\t\t\tmodules =\n\t\t\t\t/** @type {BlockModulesInTuples} */\n\t\t\t\t(\n\t\t\t\t\tblockModulesMap.get(\n\t\t\t\t\t\t(blockCache = /** @type {DependenciesBlock} */ (block))\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t}\n\n\t\tconst i = index * 3;\n\t\t/** @type {BlockModulesInTuples} */\n\t\t(modules)[i] = m;\n\t\t/** @type {BlockModulesInTuples} */\n\t\t(modules)[i + 1] = connection.getActiveState(runtime);\n\t\t/** @type {BlockModulesInTuples} */\n\t\t(modules)[i + 2] = connection;\n\t}\n\n\tfor (const modules of arrays) {\n\t\tif (modules.length === 0) continue;\n\t\tlet indexMap;\n\t\tlet length = 0;\n\t\touter: for (let j = 0; j < modules.length; j += 3) {\n\t\t\tconst m = modules[j];\n\t\t\tif (m === undefined) continue;\n\t\t\tconst state = /** @type {ConnectionState} */ (modules[j + 1]);\n\t\t\tconst connection = /** @type {ModuleGraphConnection} */ (modules[j + 2]);\n\t\t\tif (indexMap === undefined) {\n\t\t\t\tlet i = 0;\n\t\t\t\tfor (; i < length; i += 3) {\n\t\t\t\t\tif (modules[i] === m) {\n\t\t\t\t\t\tconst merged = /** @type {ConnectionState} */ (modules[i + 1]);\n\t\t\t\t\t\t/** @type {ModuleGraphConnection[]} */\n\t\t\t\t\t\t(/** @type {unknown} */ (modules[i + 2])).push(connection);\n\t\t\t\t\t\tif (merged === true) continue outer;\n\t\t\t\t\t\tmodules[i + 1] = ModuleGraphConnection.addConnectionStates(\n\t\t\t\t\t\t\tmerged,\n\t\t\t\t\t\t\tstate\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmodules[length] = m;\n\t\t\t\tlength++;\n\t\t\t\tmodules[length] = state;\n\t\t\t\tlength++;\n\t\t\t\t/** @type {ModuleGraphConnection[]} */\n\t\t\t\t(/** @type {unknown} */ (modules[length])) = [connection];\n\t\t\t\tlength++;\n\t\t\t\tif (length > 30) {\n\t\t\t\t\t// To avoid worse case performance, we will use an index map for\n\t\t\t\t\t// linear cost access, which allows to maintain O(n) complexity\n\t\t\t\t\t// while keeping allocations down to a minimum\n\t\t\t\t\tindexMap = new Map();\n\t\t\t\t\tfor (let i = 0; i < length; i += 3) {\n\t\t\t\t\t\tindexMap.set(modules[i], i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst idx = indexMap.get(m);\n\t\t\t\tif (idx !== undefined) {\n\t\t\t\t\tconst merged = /** @type {ConnectionState} */ (modules[idx]);\n\t\t\t\t\t/** @type {ModuleGraphConnection[]} */\n\t\t\t\t\t(/** @type {unknown} */ (modules[idx + 1])).push(connection);\n\t\t\t\t\tif (merged === true) continue;\n\t\t\t\t\tmodules[idx] = ModuleGraphConnection.addConnectionStates(\n\t\t\t\t\t\tmerged,\n\t\t\t\t\t\tstate\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tmodules[length] = m;\n\t\t\t\t\tlength++;\n\t\t\t\t\tmodules[length] = state;\n\t\t\t\t\tindexMap.set(m, length);\n\t\t\t\t\tlength++;\n\t\t\t\t\t/** @type {ModuleGraphConnection[]} */\n\t\t\t\t\t(\n\t\t\t\t\t\t/** @type {unknown} */\n\t\t\t\t\t\t(modules[length])\n\t\t\t\t\t) = [connection];\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmodules.length = length;\n\t}\n};\n\n/**\n * @param {Logger} logger a logger\n * @param {Compilation} compilation the compilation\n * @param {InputEntrypointsAndModules} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @param {ChunkGroupInfoMap} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {BlockConnections} blockConnections connection for blocks\n * @param {BlocksWithNestedBlocks} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {AllCreatedChunkGroups} allCreatedChunkGroups filled with all chunk groups that are created here\n * @param {MaskByChunk} maskByChunk module content mask by chunk\n */\nconst visitModules = (\n\tlogger,\n\tcompilation,\n\tinputEntrypointsAndModules,\n\tchunkGroupInfoMap,\n\tblockConnections,\n\tblocksWithNestedBlocks,\n\tallCreatedChunkGroups,\n\tmaskByChunk\n) => {\n\tconst { moduleGraph, chunkGraph, moduleMemCaches } = compilation;\n\n\tconst blockModulesRuntimeMap = new Map();\n\n\t/** @type {BlockModulesMap | undefined} */\n\tlet blockModulesMap;\n\n\t/** @type {Map<Module, number>} */\n\tconst ordinalByModule = new Map();\n\n\t/**\n\t * @param {Module} module The module to look up\n\t * @returns {number} The ordinal of the module in masks\n\t */\n\tconst getModuleOrdinal = module => {\n\t\tlet ordinal = ordinalByModule.get(module);\n\t\tif (ordinal === undefined) {\n\t\t\tordinal = ordinalByModule.size;\n\t\t\tordinalByModule.set(module, ordinal);\n\t\t}\n\t\treturn ordinal;\n\t};\n\n\tfor (const chunk of compilation.chunks) {\n\t\tlet mask = ZERO_BIGINT;\n\t\tfor (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\tmask |= ONE_BIGINT << BigInt(getModuleOrdinal(m));\n\t\t}\n\t\tmaskByChunk.set(chunk, mask);\n\t}\n\n\t/**\n\t * @param {DependenciesBlock} block block\n\t * @param {RuntimeSpec} runtime runtime\n\t * @returns {BlockModulesInFlattenTuples} block modules in flatten tuples\n\t */\n\tconst getBlockModules = (block, runtime) => {\n\t\tblockModulesMap = blockModulesRuntimeMap.get(runtime);\n\t\tif (blockModulesMap === undefined) {\n\t\t\tblockModulesMap = new Map();\n\t\t\tblockModulesRuntimeMap.set(runtime, blockModulesMap);\n\t\t}\n\t\tlet blockModules = blockModulesMap.get(block);\n\t\tif (blockModules !== undefined) return blockModules;\n\t\tconst module = /** @type {Module} */ (block.getRootBlock());\n\t\tconst memCache = moduleMemCaches && moduleMemCaches.get(module);\n\t\tif (memCache !== undefined) {\n\t\t\tconst map = memCache.provide(\n\t\t\t\t\"bundleChunkGraph.blockModules\",\n\t\t\t\truntime,\n\t\t\t\t() => {\n\t\t\t\t\tlogger.time(\"visitModules: prepare\");\n\t\t\t\t\tconst map = new Map();\n\t\t\t\t\textractBlockModules(module, moduleGraph, runtime, map);\n\t\t\t\t\tlogger.timeAggregate(\"visitModules: prepare\");\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\t\t\t);\n\t\t\tfor (const [block, blockModules] of map)\n\t\t\t\tblockModulesMap.set(block, blockModules);\n\t\t\treturn map.get(block);\n\t\t}\n\t\tlogger.time(\"visitModules: prepare\");\n\t\textractBlockModules(module, moduleGraph, runtime, blockModulesMap);\n\t\tblockModules =\n\t\t\t/** @type {BlockModulesInFlattenTuples} */\n\t\t\t(blockModulesMap.get(block));\n\t\tlogger.timeAggregate(\"visitModules: prepare\");\n\t\treturn blockModules;\n\t};\n\n\tlet statProcessedQueueItems = 0;\n\tlet statProcessedBlocks = 0;\n\tlet statConnectedChunkGroups = 0;\n\tlet statProcessedChunkGroupsForMerging = 0;\n\tlet statMergedAvailableModuleSets = 0;\n\tconst statForkedAvailableModules = 0;\n\tconst statForkedAvailableModulesCount = 0;\n\tconst statForkedAvailableModulesCountPlus = 0;\n\tconst statForkedMergedModulesCount = 0;\n\tconst statForkedMergedModulesCountPlus = 0;\n\tconst statForkedResultModulesCount = 0;\n\tlet statChunkGroupInfoUpdated = 0;\n\tlet statChildChunkGroupsReconnected = 0;\n\n\tlet nextChunkGroupIndex = 0;\n\tlet nextFreeModulePreOrderIndex = 0;\n\tlet nextFreeModulePostOrderIndex = 0;\n\n\t/** @type {Map<DependenciesBlock, ChunkGroupInfo>} */\n\tconst blockChunkGroups = new Map();\n\n\t/** @type {Map<ChunkGroupInfo, Set<DependenciesBlock>>} */\n\tconst blocksByChunkGroups = new Map();\n\n\t/** @type {Map<string, ChunkGroupInfo>} */\n\tconst namedChunkGroups = new Map();\n\n\t/** @type {Map<string, ChunkGroupInfo>} */\n\tconst namedAsyncEntrypoints = new Map();\n\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst outdatedOrderIndexChunkGroups = new Set();\n\n\tconst ADD_AND_ENTER_ENTRY_MODULE = 0;\n\tconst ADD_AND_ENTER_MODULE = 1;\n\tconst ENTER_MODULE = 2;\n\tconst PROCESS_BLOCK = 3;\n\tconst PROCESS_ENTRY_BLOCK = 4;\n\tconst LEAVE_MODULE = 5;\n\n\t/** @type {QueueItem[]} */\n\tlet queue = [];\n\n\t/** @type {Map<ChunkGroupInfo, Set<[ChunkGroupInfo, QueueItem | null]>>} */\n\tconst queueConnect = new Map();\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst chunkGroupsForCombining = new Set();\n\n\t// Fill queue with entrypoint modules\n\t// Create ChunkGroupInfo for entrypoints\n\tfor (const [chunkGroup, modules] of inputEntrypointsAndModules) {\n\t\tconst runtime = getEntryRuntime(\n\t\t\tcompilation,\n\t\t\t/** @type {string} */ (chunkGroup.name),\n\t\t\tchunkGroup.options\n\t\t);\n\t\t/** @type {ChunkGroupInfo} */\n\t\tconst chunkGroupInfo = {\n\t\t\tinitialized: false,\n\t\t\tchunkGroup,\n\t\t\truntime,\n\t\t\tminAvailableModules: undefined,\n\t\t\tavailableModulesToBeMerged: [],\n\t\t\tskippedItems: undefined,\n\t\t\tresultingAvailableModules: undefined,\n\t\t\tchildren: undefined,\n\t\t\tavailableSources: undefined,\n\t\t\tavailableChildren: undefined,\n\t\t\tpreOrderIndex: 0,\n\t\t\tpostOrderIndex: 0,\n\t\t\tchunkLoading:\n\t\t\t\tchunkGroup.options.chunkLoading !== undefined\n\t\t\t\t\t? chunkGroup.options.chunkLoading !== false\n\t\t\t\t\t: compilation.outputOptions.chunkLoading !== false,\n\t\t\tasyncChunks:\n\t\t\t\tchunkGroup.options.asyncChunks !== undefined\n\t\t\t\t\t? chunkGroup.options.asyncChunks\n\t\t\t\t\t: compilation.outputOptions.asyncChunks !== false\n\t\t};\n\t\tchunkGroup.index = nextChunkGroupIndex++;\n\t\tif (chunkGroup.getNumberOfParents() > 0) {\n\t\t\t// minAvailableModules for child entrypoints are unknown yet, set to undefined.\n\t\t\t// This means no module is added until other sets are merged into\n\t\t\t// this minAvailableModules (by the parent entrypoints)\n\t\t\tconst skippedItems = new Set(modules);\n\t\t\tchunkGroupInfo.skippedItems = skippedItems;\n\t\t\tchunkGroupsForCombining.add(chunkGroupInfo);\n\t\t} else {\n\t\t\t// The application may start here: We start with an empty list of available modules\n\t\t\tchunkGroupInfo.minAvailableModules = ZERO_BIGINT;\n\t\t\tconst chunk = chunkGroup.getEntrypointChunk();\n\t\t\tfor (const module of modules) {\n\t\t\t\tqueue.push({\n\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\tblock: module,\n\t\t\t\t\tmodule,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tchunkGroupInfoMap.set(chunkGroup, chunkGroupInfo);\n\t\tif (chunkGroup.name) {\n\t\t\tnamedChunkGroups.set(chunkGroup.name, chunkGroupInfo);\n\t\t}\n\t}\n\t// Fill availableSources with parent-child dependencies between entrypoints\n\tfor (const chunkGroupInfo of chunkGroupsForCombining) {\n\t\tconst { chunkGroup } = chunkGroupInfo;\n\t\tchunkGroupInfo.availableSources = new Set();\n\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\tconst parentChunkGroupInfo =\n\t\t\t\t/** @type {ChunkGroupInfo} */\n\t\t\t\t(chunkGroupInfoMap.get(parent));\n\t\t\tchunkGroupInfo.availableSources.add(parentChunkGroupInfo);\n\t\t\tif (parentChunkGroupInfo.availableChildren === undefined) {\n\t\t\t\tparentChunkGroupInfo.availableChildren = new Set();\n\t\t\t}\n\t\t\tparentChunkGroupInfo.availableChildren.add(chunkGroupInfo);\n\t\t}\n\t}\n\t// pop() is used to read from the queue\n\t// so it need to be reversed to be iterated in\n\t// correct order\n\tqueue.reverse();\n\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst outdatedChunkGroupInfo = new Set();\n\t/** @type {Set<[ChunkGroupInfo, QueueItem | null]>} */\n\tconst chunkGroupsForMerging = new Set();\n\t/** @type {QueueItem[]} */\n\tlet queueDelayed = [];\n\n\t/** @type {[Module, ModuleGraphConnection[]][]} */\n\tconst skipConnectionBuffer = [];\n\t/** @type {Module[]} */\n\tconst skipBuffer = [];\n\t/** @type {QueueItem[]} */\n\tconst queueBuffer = [];\n\n\t/** @type {Module} */\n\tlet module;\n\t/** @type {Chunk} */\n\tlet chunk;\n\t/** @type {ChunkGroup} */\n\tlet chunkGroup;\n\t/** @type {DependenciesBlock} */\n\tlet block;\n\t/** @type {ChunkGroupInfo} */\n\tlet chunkGroupInfo;\n\n\t// For each async Block in graph\n\t/**\n\t * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n\t * @returns {void}\n\t */\n\tconst iteratorBlock = b => {\n\t\t// 1. We create a chunk group with single chunk in it for this Block\n\t\t// but only once (blockChunkGroups map)\n\t\t/** @type {ChunkGroupInfo | undefined} */\n\t\tlet cgi = blockChunkGroups.get(b);\n\t\t/** @type {ChunkGroup | undefined} */\n\t\tlet c;\n\t\t/** @type {Entrypoint | undefined} */\n\t\tlet entrypoint;\n\t\tconst entryOptions = b.groupOptions && b.groupOptions.entryOptions;\n\t\tif (cgi === undefined) {\n\t\t\tconst chunkName = (b.groupOptions && b.groupOptions.name) || b.chunkName;\n\t\t\tif (entryOptions) {\n\t\t\t\tcgi = namedAsyncEntrypoints.get(/** @type {string} */ (chunkName));\n\t\t\t\tif (!cgi) {\n\t\t\t\t\tentrypoint = compilation.addAsyncEntrypoint(\n\t\t\t\t\t\tentryOptions,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t/** @type {DependencyLocation} */ (b.loc),\n\t\t\t\t\t\t/** @type {string} */ (b.request)\n\t\t\t\t\t);\n\t\t\t\t\tmaskByChunk.set(entrypoint.chunks[0], ZERO_BIGINT);\n\t\t\t\t\tentrypoint.index = nextChunkGroupIndex++;\n\t\t\t\t\tcgi = {\n\t\t\t\t\t\tchunkGroup: entrypoint,\n\t\t\t\t\t\tinitialized: false,\n\t\t\t\t\t\truntime: entrypoint.options.runtime || entrypoint.name,\n\t\t\t\t\t\tminAvailableModules: ZERO_BIGINT,\n\t\t\t\t\t\tavailableModulesToBeMerged: [],\n\t\t\t\t\t\tskippedItems: undefined,\n\t\t\t\t\t\tresultingAvailableModules: undefined,\n\t\t\t\t\t\tchildren: undefined,\n\t\t\t\t\t\tavailableSources: undefined,\n\t\t\t\t\t\tavailableChildren: undefined,\n\t\t\t\t\t\tpreOrderIndex: 0,\n\t\t\t\t\t\tpostOrderIndex: 0,\n\t\t\t\t\t\tchunkLoading:\n\t\t\t\t\t\t\tentryOptions.chunkLoading !== undefined\n\t\t\t\t\t\t\t\t? entryOptions.chunkLoading !== false\n\t\t\t\t\t\t\t\t: chunkGroupInfo.chunkLoading,\n\t\t\t\t\t\tasyncChunks:\n\t\t\t\t\t\t\tentryOptions.asyncChunks !== undefined\n\t\t\t\t\t\t\t\t? entryOptions.asyncChunks\n\t\t\t\t\t\t\t\t: chunkGroupInfo.asyncChunks\n\t\t\t\t\t};\n\t\t\t\t\tchunkGroupInfoMap.set(entrypoint, cgi);\n\n\t\t\t\t\tchunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\tnamedAsyncEntrypoints.set(chunkName, cgi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tentrypoint = /** @type {Entrypoint} */ (cgi.chunkGroup);\n\t\t\t\t\t// TODO merge entryOptions\n\t\t\t\t\tentrypoint.addOrigin(\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t/** @type {DependencyLocation} */ (b.loc),\n\t\t\t\t\t\t/** @type {string} */ (b.request)\n\t\t\t\t\t);\n\t\t\t\t\tchunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n\t\t\t\t}\n\n\t\t\t\t// 2. We enqueue the DependenciesBlock for traversal\n\t\t\t\tqueueDelayed.push({\n\t\t\t\t\taction: PROCESS_ENTRY_BLOCK,\n\t\t\t\t\tblock: b,\n\t\t\t\t\tmodule,\n\t\t\t\t\tchunk: entrypoint.chunks[0],\n\t\t\t\t\tchunkGroup: entrypoint,\n\t\t\t\t\tchunkGroupInfo: cgi\n\t\t\t\t});\n\t\t\t} else if (!chunkGroupInfo.asyncChunks || !chunkGroupInfo.chunkLoading) {\n\t\t\t\t// Just queue the block into the current chunk group\n\t\t\t\tqueue.push({\n\t\t\t\t\taction: PROCESS_BLOCK,\n\t\t\t\t\tblock: b,\n\t\t\t\t\tmodule,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcgi = chunkName ? namedChunkGroups.get(chunkName) : undefined;\n\t\t\t\tif (!cgi) {\n\t\t\t\t\tc = compilation.addChunkInGroup(\n\t\t\t\t\t\tb.groupOptions || b.chunkName,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t/** @type {DependencyLocation} */ (b.loc),\n\t\t\t\t\t\t/** @type {string} */ (b.request)\n\t\t\t\t\t);\n\t\t\t\t\tmaskByChunk.set(c.chunks[0], ZERO_BIGINT);\n\t\t\t\t\tc.index = nextChunkGroupIndex++;\n\t\t\t\t\tcgi = {\n\t\t\t\t\t\tinitialized: false,\n\t\t\t\t\t\tchunkGroup: c,\n\t\t\t\t\t\truntime: chunkGroupInfo.runtime,\n\t\t\t\t\t\tminAvailableModules: undefined,\n\t\t\t\t\t\tavailableModulesToBeMerged: [],\n\t\t\t\t\t\tskippedItems: undefined,\n\t\t\t\t\t\tresultingAvailableModules: undefined,\n\t\t\t\t\t\tchildren: undefined,\n\t\t\t\t\t\tavailableSources: undefined,\n\t\t\t\t\t\tavailableChildren: undefined,\n\t\t\t\t\t\tpreOrderIndex: 0,\n\t\t\t\t\t\tpostOrderIndex: 0,\n\t\t\t\t\t\tchunkLoading: chunkGroupInfo.chunkLoading,\n\t\t\t\t\t\tasyncChunks: chunkGroupInfo.asyncChunks\n\t\t\t\t\t};\n\t\t\t\t\tallCreatedChunkGroups.add(c);\n\t\t\t\t\tchunkGroupInfoMap.set(c, cgi);\n\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\tnamedChunkGroups.set(chunkName, cgi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tc = cgi.chunkGroup;\n\t\t\t\t\tif (c.isInitial()) {\n\t\t\t\t\t\tcompilation.errors.push(\n\t\t\t\t\t\t\tnew AsyncDependencyToInitialChunkError(\n\t\t\t\t\t\t\t\t/** @type {string} */ (chunkName),\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t/** @type {DependencyLocation} */ (b.loc)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tc = chunkGroup;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc.addOptions(b.groupOptions);\n\t\t\t\t\t}\n\t\t\t\t\tc.addOrigin(\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t/** @type {DependencyLocation} */ (b.loc),\n\t\t\t\t\t\t/** @type {string} */ (b.request)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tblockConnections.set(b, []);\n\t\t\t}\n\t\t\tblockChunkGroups.set(b, /** @type {ChunkGroupInfo} */ (cgi));\n\t\t} else if (entryOptions) {\n\t\t\tentrypoint = /** @type {Entrypoint} */ (cgi.chunkGroup);\n\t\t} else {\n\t\t\tc = cgi.chunkGroup;\n\t\t}\n\n\t\tif (c !== undefined) {\n\t\t\t// 2. We store the connection for the block\n\t\t\t// to connect it later if needed\n\t\t\t/** @type {BlockChunkGroupConnection[]} */\n\t\t\t(blockConnections.get(b)).push({\n\t\t\t\toriginChunkGroupInfo: chunkGroupInfo,\n\t\t\t\tchunkGroup: c\n\t\t\t});\n\n\t\t\t// 3. We enqueue the chunk group info creation/updating\n\t\t\tlet connectList = queueConnect.get(chunkGroupInfo);\n\t\t\tif (connectList === undefined) {\n\t\t\t\tconnectList = new Set();\n\t\t\t\tqueueConnect.set(chunkGroupInfo, connectList);\n\t\t\t}\n\t\t\tconnectList.add([\n\t\t\t\t/** @type {ChunkGroupInfo} */ (cgi),\n\t\t\t\t{\n\t\t\t\t\taction: PROCESS_BLOCK,\n\t\t\t\t\tblock: b,\n\t\t\t\t\tmodule,\n\t\t\t\t\tchunk: c.chunks[0],\n\t\t\t\t\tchunkGroup: c,\n\t\t\t\t\tchunkGroupInfo: /** @type {ChunkGroupInfo} */ (cgi)\n\t\t\t\t}\n\t\t\t]);\n\t\t} else if (entrypoint !== undefined) {\n\t\t\tchunkGroupInfo.chunkGroup.addAsyncEntrypoint(entrypoint);\n\t\t}\n\t};\n\n\t/**\n\t * @param {DependenciesBlock} block the block\n\t * @returns {void}\n\t */\n\tconst processBlock = block => {\n\t\tstatProcessedBlocks++;\n\t\t// get prepared block info\n\t\tconst blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n\n\t\tif (blockModules !== undefined) {\n\t\t\tconst minAvailableModules =\n\t\t\t\t/** @type {bigint} */\n\t\t\t\t(chunkGroupInfo.minAvailableModules);\n\t\t\t// Buffer items because order need to be reversed to get indices correct\n\t\t\t// Traverse all referenced modules\n\t\t\tfor (let i = 0, len = blockModules.length; i < len; i += 3) {\n\t\t\t\tconst refModule = /** @type {Module} */ (blockModules[i]);\n\t\t\t\t// For single comparisons this might be cheaper\n\t\t\t\tconst isModuleInChunk = chunkGraph.isModuleInChunk(refModule, chunk);\n\n\t\t\t\tif (isModuleInChunk) {\n\t\t\t\t\t// skip early if already connected\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst refOrdinal = /** @type {number} */ getModuleOrdinal(refModule);\n\t\t\t\tconst activeState = /** @type {ConnectionState} */ (\n\t\t\t\t\tblockModules[i + 1]\n\t\t\t\t);\n\t\t\t\tif (activeState !== true) {\n\t\t\t\t\tconst connections = /** @type {ModuleGraphConnection[]} */ (\n\t\t\t\t\t\tblockModules[i + 2]\n\t\t\t\t\t);\n\t\t\t\t\tskipConnectionBuffer.push([refModule, connections]);\n\t\t\t\t\t// We skip inactive connections\n\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t} else if (isOrdinalSetInMask(minAvailableModules, refOrdinal)) {\n\t\t\t\t\t// already in parent chunks, skip it for now\n\t\t\t\t\tskipBuffer.push(refModule);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// enqueue, then add and enter to be in the correct order\n\t\t\t\t// this is relevant with circular dependencies\n\t\t\t\tqueueBuffer.push({\n\t\t\t\t\taction: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n\t\t\t\t\tblock: refModule,\n\t\t\t\t\tmodule: refModule,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Add buffered items in reverse order\n\t\t\tif (skipConnectionBuffer.length > 0) {\n\t\t\t\tlet { skippedModuleConnections } = chunkGroupInfo;\n\t\t\t\tif (skippedModuleConnections === undefined) {\n\t\t\t\t\tchunkGroupInfo.skippedModuleConnections = skippedModuleConnections =\n\t\t\t\t\t\tnew Set();\n\t\t\t\t}\n\t\t\t\tfor (let i = skipConnectionBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\tskippedModuleConnections.add(skipConnectionBuffer[i]);\n\t\t\t\t}\n\t\t\t\tskipConnectionBuffer.length = 0;\n\t\t\t}\n\t\t\tif (skipBuffer.length > 0) {\n\t\t\t\tlet { skippedItems } = chunkGroupInfo;\n\t\t\t\tif (skippedItems === undefined) {\n\t\t\t\t\tchunkGroupInfo.skippedItems = skippedItems = new Set();\n\t\t\t\t}\n\t\t\t\tfor (let i = skipBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\tskippedItems.add(skipBuffer[i]);\n\t\t\t\t}\n\t\t\t\tskipBuffer.length = 0;\n\t\t\t}\n\t\t\tif (queueBuffer.length > 0) {\n\t\t\t\tfor (let i = queueBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\tqueue.push(queueBuffer[i]);\n\t\t\t\t}\n\t\t\t\tqueueBuffer.length = 0;\n\t\t\t}\n\t\t}\n\n\t\t// Traverse all Blocks\n\t\tfor (const b of block.blocks) {\n\t\t\titeratorBlock(b);\n\t\t}\n\n\t\tif (block.blocks.length > 0 && module !== block) {\n\t\t\tblocksWithNestedBlocks.add(block);\n\t\t}\n\t};\n\n\t/**\n\t * @param {DependenciesBlock} block the block\n\t * @returns {void}\n\t */\n\tconst processEntryBlock = block => {\n\t\tstatProcessedBlocks++;\n\t\t// get prepared block info\n\t\tconst blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n\n\t\tif (blockModules !== undefined) {\n\t\t\t// Traverse all referenced modules in reverse order\n\t\t\tfor (let i = blockModules.length - 3; i >= 0; i -= 3) {\n\t\t\t\tconst refModule = /** @type {Module} */ (blockModules[i]);\n\t\t\t\tconst activeState = /** @type {ConnectionState} */ (\n\t\t\t\t\tblockModules[i + 1]\n\t\t\t\t);\n\t\t\t\t// enqueue, then add and enter to be in the correct order\n\t\t\t\t// this is relevant with circular dependencies\n\t\t\t\tqueue.push({\n\t\t\t\t\taction:\n\t\t\t\t\t\tactiveState === true ? ADD_AND_ENTER_ENTRY_MODULE : PROCESS_BLOCK,\n\t\t\t\t\tblock: refModule,\n\t\t\t\t\tmodule: refModule,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Traverse all Blocks\n\t\tfor (const b of block.blocks) {\n\t\t\titeratorBlock(b);\n\t\t}\n\n\t\tif (block.blocks.length > 0 && module !== block) {\n\t\t\tblocksWithNestedBlocks.add(block);\n\t\t}\n\t};\n\n\tconst processQueue = () => {\n\t\twhile (queue.length) {\n\t\t\tstatProcessedQueueItems++;\n\t\t\tconst queueItem = /** @type {QueueItem} */ (queue.pop());\n\t\t\tmodule = queueItem.module;\n\t\t\tblock = queueItem.block;\n\t\t\tchunk = queueItem.chunk;\n\t\t\tchunkGroup = queueItem.chunkGroup;\n\t\t\tchunkGroupInfo = queueItem.chunkGroupInfo;\n\n\t\t\tswitch (queueItem.action) {\n\t\t\t\tcase ADD_AND_ENTER_ENTRY_MODULE:\n\t\t\t\t\tchunkGraph.connectChunkAndEntryModule(\n\t\t\t\t\t\tchunk,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t/** @type {Entrypoint} */ (chunkGroup)\n\t\t\t\t\t);\n\t\t\t\t// fallthrough\n\t\t\t\tcase ADD_AND_ENTER_MODULE: {\n\t\t\t\t\tconst isModuleInChunk = chunkGraph.isModuleInChunk(module, chunk);\n\n\t\t\t\t\tif (isModuleInChunk) {\n\t\t\t\t\t\t// already connected, skip it\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// We connect Module and Chunk\n\t\t\t\t\tchunkGraph.connectChunkAndModule(chunk, module);\n\t\t\t\t\tconst moduleOrdinal = getModuleOrdinal(module);\n\t\t\t\t\tlet chunkMask = /** @type {bigint} */ (maskByChunk.get(chunk));\n\t\t\t\t\tchunkMask |= ONE_BIGINT << BigInt(moduleOrdinal);\n\t\t\t\t\tmaskByChunk.set(chunk, chunkMask);\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase ENTER_MODULE: {\n\t\t\t\t\tconst index = chunkGroup.getModulePreOrderIndex(module);\n\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\tchunkGroup.setModulePreOrderIndex(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tchunkGroupInfo.preOrderIndex++\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tmoduleGraph.setPreOrderIndexIfUnset(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tnextFreeModulePreOrderIndex\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tnextFreeModulePreOrderIndex++;\n\t\t\t\t\t}\n\n\t\t\t\t\t// reuse queueItem\n\t\t\t\t\tqueueItem.action = LEAVE_MODULE;\n\t\t\t\t\tqueue.push(queueItem);\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase PROCESS_BLOCK: {\n\t\t\t\t\tprocessBlock(block);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase PROCESS_ENTRY_BLOCK: {\n\t\t\t\t\tprocessEntryBlock(block);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase LEAVE_MODULE: {\n\t\t\t\t\tconst index = chunkGroup.getModulePostOrderIndex(module);\n\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\tchunkGroup.setModulePostOrderIndex(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tchunkGroupInfo.postOrderIndex++\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tmoduleGraph.setPostOrderIndexIfUnset(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tnextFreeModulePostOrderIndex\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tnextFreeModulePostOrderIndex++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @param {ChunkGroupInfo} chunkGroupInfo The info object for the chunk group\n\t * @returns {bigint} The mask of available modules after the chunk group\n\t */\n\tconst calculateResultingAvailableModules = chunkGroupInfo => {\n\t\tif (chunkGroupInfo.resultingAvailableModules !== undefined)\n\t\t\treturn chunkGroupInfo.resultingAvailableModules;\n\n\t\tlet resultingAvailableModules = /** @type {bigint} */ (\n\t\t\tchunkGroupInfo.minAvailableModules\n\t\t);\n\n\t\t// add the modules from the chunk group to the set\n\t\tfor (const chunk of chunkGroupInfo.chunkGroup.chunks) {\n\t\t\tconst mask = /** @type {bigint} */ (maskByChunk.get(chunk));\n\t\t\tresultingAvailableModules |= mask;\n\t\t}\n\n\t\treturn (chunkGroupInfo.resultingAvailableModules =\n\t\t\tresultingAvailableModules);\n\t};\n\n\tconst processConnectQueue = () => {\n\t\t// Figure out new parents for chunk groups\n\t\t// to get new available modules for these children\n\t\tfor (const [chunkGroupInfo, targets] of queueConnect) {\n\t\t\t// 1. Add new targets to the list of children\n\t\t\tif (chunkGroupInfo.children === undefined) {\n\t\t\t\tchunkGroupInfo.children = new Set();\n\t\t\t}\n\t\t\tfor (const [target] of targets) {\n\t\t\t\tchunkGroupInfo.children.add(target);\n\t\t\t}\n\n\t\t\t// 2. Calculate resulting available modules\n\t\t\tconst resultingAvailableModules =\n\t\t\t\tcalculateResultingAvailableModules(chunkGroupInfo);\n\n\t\t\tconst runtime = chunkGroupInfo.runtime;\n\n\t\t\t// 3. Update chunk group info\n\t\t\tfor (const [target, processBlock] of targets) {\n\t\t\t\ttarget.availableModulesToBeMerged.push(resultingAvailableModules);\n\t\t\t\tchunkGroupsForMerging.add([target, processBlock]);\n\t\t\t\tconst oldRuntime = target.runtime;\n\t\t\t\tconst newRuntime = mergeRuntime(oldRuntime, runtime);\n\t\t\t\tif (oldRuntime !== newRuntime) {\n\t\t\t\t\ttarget.runtime = newRuntime;\n\t\t\t\t\toutdatedChunkGroupInfo.add(target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatConnectedChunkGroups += targets.size;\n\t\t}\n\t\tqueueConnect.clear();\n\t};\n\n\tconst processChunkGroupsForMerging = () => {\n\t\tstatProcessedChunkGroupsForMerging += chunkGroupsForMerging.size;\n\n\t\t// Execute the merge\n\t\tfor (const [info, processBlock] of chunkGroupsForMerging) {\n\t\t\tconst availableModulesToBeMerged = info.availableModulesToBeMerged;\n\t\t\tconst cachedMinAvailableModules = info.minAvailableModules;\n\t\t\tlet minAvailableModules = cachedMinAvailableModules;\n\n\t\t\tstatMergedAvailableModuleSets += availableModulesToBeMerged.length;\n\n\t\t\tfor (const availableModules of availableModulesToBeMerged) {\n\t\t\t\tif (minAvailableModules === undefined) {\n\t\t\t\t\tminAvailableModules = availableModules;\n\t\t\t\t} else {\n\t\t\t\t\tminAvailableModules &= availableModules;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst changed = minAvailableModules !== cachedMinAvailableModules;\n\n\t\t\tavailableModulesToBeMerged.length = 0;\n\t\t\tif (changed) {\n\t\t\t\tinfo.minAvailableModules = minAvailableModules;\n\t\t\t\tinfo.resultingAvailableModules = undefined;\n\t\t\t\toutdatedChunkGroupInfo.add(info);\n\t\t\t}\n\n\t\t\tif (processBlock) {\n\t\t\t\tlet blocks = blocksByChunkGroups.get(info);\n\t\t\t\tif (!blocks) {\n\t\t\t\t\tblocksByChunkGroups.set(info, (blocks = new Set()));\n\t\t\t\t}\n\n\t\t\t\t// Whether to walk block depends on minAvailableModules and input block.\n\t\t\t\t// We can treat creating chunk group as a function with 2 input, entry block and minAvailableModules\n\t\t\t\t// If input is the same, we can skip re-walk\n\t\t\t\tlet needWalkBlock = !info.initialized || changed;\n\t\t\t\tif (!blocks.has(processBlock.block)) {\n\t\t\t\t\tneedWalkBlock = true;\n\t\t\t\t\tblocks.add(processBlock.block);\n\t\t\t\t}\n\n\t\t\t\tif (needWalkBlock) {\n\t\t\t\t\tinfo.initialized = true;\n\t\t\t\t\tqueueDelayed.push(processBlock);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchunkGroupsForMerging.clear();\n\t};\n\n\tconst processChunkGroupsForCombining = () => {\n\t\tfor (const info of chunkGroupsForCombining) {\n\t\t\tfor (const source of /** @type {Set<ChunkGroupInfo>} */ (\n\t\t\t\tinfo.availableSources\n\t\t\t)) {\n\t\t\t\tif (source.minAvailableModules === undefined) {\n\t\t\t\t\tchunkGroupsForCombining.delete(info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const info of chunkGroupsForCombining) {\n\t\t\tlet availableModules = ZERO_BIGINT;\n\t\t\t// combine minAvailableModules from all resultingAvailableModules\n\t\t\tfor (const source of /** @type {Set<ChunkGroupInfo>} */ (\n\t\t\t\tinfo.availableSources\n\t\t\t)) {\n\t\t\t\tconst resultingAvailableModules =\n\t\t\t\t\tcalculateResultingAvailableModules(source);\n\t\t\t\tavailableModules |= resultingAvailableModules;\n\t\t\t}\n\t\t\tinfo.minAvailableModules = availableModules;\n\t\t\tinfo.resultingAvailableModules = undefined;\n\t\t\toutdatedChunkGroupInfo.add(info);\n\t\t}\n\t\tchunkGroupsForCombining.clear();\n\t};\n\n\tconst processOutdatedChunkGroupInfo = () => {\n\t\tstatChunkGroupInfoUpdated += outdatedChunkGroupInfo.size;\n\t\t// Revisit skipped elements\n\t\tfor (const info of outdatedChunkGroupInfo) {\n\t\t\t// 1. Reconsider skipped items\n\t\t\tif (info.skippedItems !== undefined) {\n\t\t\t\tconst minAvailableModules =\n\t\t\t\t\t/** @type {bigint} */\n\t\t\t\t\t(info.minAvailableModules);\n\t\t\t\tfor (const module of info.skippedItems) {\n\t\t\t\t\tconst ordinal = getModuleOrdinal(module);\n\t\t\t\t\tif (!isOrdinalSetInMask(minAvailableModules, ordinal)) {\n\t\t\t\t\t\tqueue.push({\n\t\t\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\t\t\tblock: module,\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tchunk: info.chunkGroup.chunks[0],\n\t\t\t\t\t\t\tchunkGroup: info.chunkGroup,\n\t\t\t\t\t\t\tchunkGroupInfo: info\n\t\t\t\t\t\t});\n\t\t\t\t\t\tinfo.skippedItems.delete(module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 2. Reconsider skipped connections\n\t\t\tif (info.skippedModuleConnections !== undefined) {\n\t\t\t\tconst minAvailableModules =\n\t\t\t\t\t/** @type {bigint} */\n\t\t\t\t\t(info.minAvailableModules);\n\t\t\t\tfor (const entry of info.skippedModuleConnections) {\n\t\t\t\t\tconst [module, connections] = entry;\n\t\t\t\t\tconst activeState = getActiveStateOfConnections(\n\t\t\t\t\t\tconnections,\n\t\t\t\t\t\tinfo.runtime\n\t\t\t\t\t);\n\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t\tif (activeState === true) {\n\t\t\t\t\t\tconst ordinal = getModuleOrdinal(module);\n\t\t\t\t\t\tinfo.skippedModuleConnections.delete(entry);\n\t\t\t\t\t\tif (isOrdinalSetInMask(minAvailableModules, ordinal)) {\n\t\t\t\t\t\t\t/** @type {NonNullable<ChunkGroupInfo[\"skippedItems\"]>} */\n\t\t\t\t\t\t\t(info.skippedItems).add(module);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\taction: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n\t\t\t\t\t\tblock: module,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tchunk: info.chunkGroup.chunks[0],\n\t\t\t\t\t\tchunkGroup: info.chunkGroup,\n\t\t\t\t\t\tchunkGroupInfo: info\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 2. Reconsider children chunk groups\n\t\t\tif (info.children !== undefined) {\n\t\t\t\tstatChildChunkGroupsReconnected += info.children.size;\n\t\t\t\tfor (const cgi of info.children) {\n\t\t\t\t\tlet connectList = queueConnect.get(info);\n\t\t\t\t\tif (connectList === undefined) {\n\t\t\t\t\t\tconnectList = new Set();\n\t\t\t\t\t\tqueueConnect.set(info, connectList);\n\t\t\t\t\t}\n\t\t\t\t\tconnectList.add([cgi, null]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 3. Reconsider chunk groups for combining\n\t\t\tif (info.availableChildren !== undefined) {\n\t\t\t\tfor (const cgi of info.availableChildren) {\n\t\t\t\t\tchunkGroupsForCombining.add(cgi);\n\t\t\t\t}\n\t\t\t}\n\t\t\toutdatedOrderIndexChunkGroups.add(info);\n\t\t}\n\t\toutdatedChunkGroupInfo.clear();\n\t};\n\n\t// Iterative traversal of the Module graph\n\t// Recursive would be simpler to write but could result in Stack Overflows\n\twhile (queue.length || queueConnect.size) {\n\t\tlogger.time(\"visitModules: visiting\");\n\t\tprocessQueue();\n\t\tlogger.timeAggregateEnd(\"visitModules: prepare\");\n\t\tlogger.timeEnd(\"visitModules: visiting\");\n\n\t\tif (chunkGroupsForCombining.size > 0) {\n\t\t\tlogger.time(\"visitModules: combine available modules\");\n\t\t\tprocessChunkGroupsForCombining();\n\t\t\tlogger.timeEnd(\"visitModules: combine available modules\");\n\t\t}\n\n\t\tif (queueConnect.size > 0) {\n\t\t\tlogger.time(\"visitModules: calculating available modules\");\n\t\t\tprocessConnectQueue();\n\t\t\tlogger.timeEnd(\"visitModules: calculating available modules\");\n\n\t\t\tif (chunkGroupsForMerging.size > 0) {\n\t\t\t\tlogger.time(\"visitModules: merging available modules\");\n\t\t\t\tprocessChunkGroupsForMerging();\n\t\t\t\tlogger.timeEnd(\"visitModules: merging available modules\");\n\t\t\t}\n\t\t}\n\n\t\tif (outdatedChunkGroupInfo.size > 0) {\n\t\t\tlogger.time(\"visitModules: check modules for revisit\");\n\t\t\tprocessOutdatedChunkGroupInfo();\n\t\t\tlogger.timeEnd(\"visitModules: check modules for revisit\");\n\t\t}\n\n\t\t// Run queueDelayed when all items of the queue are processed\n\t\t// This is important to get the global indexing correct\n\t\t// Async blocks should be processed after all sync blocks are processed\n\t\tif (queue.length === 0) {\n\t\t\tconst tempQueue = queue;\n\t\t\tqueue = queueDelayed.reverse();\n\t\t\tqueueDelayed = tempQueue;\n\t\t}\n\t}\n\n\tfor (const info of outdatedOrderIndexChunkGroups) {\n\t\tconst { chunkGroup, runtime } = info;\n\n\t\tconst blocks = blocksByChunkGroups.get(info);\n\n\t\tif (!blocks) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (const block of blocks) {\n\t\t\tlet preOrderIndex = 0;\n\t\t\tlet postOrderIndex = 0;\n\t\t\t/**\n\t\t\t * @param {DependenciesBlock} current current\n\t\t\t * @param {BlocksWithNestedBlocks} visited visited dependencies blocks\n\t\t\t */\n\t\t\tconst process = (current, visited) => {\n\t\t\t\tconst blockModules = getBlockModules(current, runtime);\n\t\t\t\tfor (let i = 0, len = blockModules.length; i < len; i += 3) {\n\t\t\t\t\tconst activeState = /** @type {ConnectionState} */ (\n\t\t\t\t\t\tblockModules[i + 1]\n\t\t\t\t\t);\n\t\t\t\t\tif (activeState === false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst refModule = /** @type {Module} */ (blockModules[i]);\n\t\t\t\t\tif (visited.has(refModule)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvisited.add(refModule);\n\n\t\t\t\t\tif (refModule) {\n\t\t\t\t\t\tchunkGroup.setModulePreOrderIndex(refModule, preOrderIndex++);\n\t\t\t\t\t\tprocess(refModule, visited);\n\t\t\t\t\t\tchunkGroup.setModulePostOrderIndex(refModule, postOrderIndex++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tprocess(block, new Set());\n\t\t}\n\t}\n\toutdatedOrderIndexChunkGroups.clear();\n\tordinalByModule.clear();\n\n\tlogger.log(\n\t\t`${statProcessedQueueItems} queue items processed (${statProcessedBlocks} blocks)`\n\t);\n\tlogger.log(`${statConnectedChunkGroups} chunk groups connected`);\n\tlogger.log(\n\t\t`${statProcessedChunkGroupsForMerging} chunk groups processed for merging (${statMergedAvailableModuleSets} module sets, ${statForkedAvailableModules} forked, ${statForkedAvailableModulesCount} + ${statForkedAvailableModulesCountPlus} modules forked, ${statForkedMergedModulesCount} + ${statForkedMergedModulesCountPlus} modules merged into fork, ${statForkedResultModulesCount} resulting modules)`\n\t);\n\tlogger.log(\n\t\t`${statChunkGroupInfoUpdated} chunk group info updated (${statChildChunkGroupsReconnected} already connected chunk groups reconnected)`\n\t);\n};\n\n/**\n * @param {Compilation} compilation the compilation\n * @param {BlocksWithNestedBlocks} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {BlockConnections} blockConnections connection for blocks\n * @param {MaskByChunk} maskByChunk mapping from chunk to module mask\n */\nconst connectChunkGroups = (\n\tcompilation,\n\tblocksWithNestedBlocks,\n\tblockConnections,\n\tmaskByChunk\n) => {\n\tconst { chunkGraph } = compilation;\n\n\t/**\n\t * Helper function to check if all modules of a chunk are available\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n\t * @param {bigint} availableModules the comparator set\n\t * @returns {boolean} return true if all modules of a chunk are available\n\t */\n\tconst areModulesAvailable = (chunkGroup, availableModules) => {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tconst chunkMask = /** @type {bigint} */ (maskByChunk.get(chunk));\n\t\t\tif ((chunkMask & availableModules) !== chunkMask) return false;\n\t\t}\n\t\treturn true;\n\t};\n\n\t// For each edge in the basic chunk graph\n\tfor (const [block, connections] of blockConnections) {\n\t\t// 1. Check if connection is needed\n\t\t// When none of the dependencies need to be connected\n\t\t// we can skip all of them\n\t\t// It's not possible to filter each item so it doesn't create inconsistent\n\t\t// connections and modules can only create one version\n\t\t// TODO maybe decide this per runtime\n\t\tif (\n\t\t\t// TODO is this needed?\n\t\t\t!blocksWithNestedBlocks.has(block) &&\n\t\t\tconnections.every(({ chunkGroup, originChunkGroupInfo }) =>\n\t\t\t\tareModulesAvailable(\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\t/** @type {bigint} */ (originChunkGroupInfo.resultingAvailableModules)\n\t\t\t\t)\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// 2. Foreach edge\n\t\tfor (let i = 0; i < connections.length; i++) {\n\t\t\tconst { chunkGroup, originChunkGroupInfo } = connections[i];\n\n\t\t\t// 3. Connect block with chunk\n\t\t\tchunkGraph.connectBlockAndChunkGroup(block, chunkGroup);\n\n\t\t\t// 4. Connect chunk with parent\n\t\t\tconnectChunkGroupParentAndChild(\n\t\t\t\toriginChunkGroupInfo.chunkGroup,\n\t\t\t\tchunkGroup\n\t\t\t);\n\t\t}\n\t}\n};\n\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n\tconst { chunkGraph } = compilation;\n\n\tfor (const chunkGroup of allCreatedChunkGroups) {\n\t\tif (chunkGroup.getNumberOfParents() === 0) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tcompilation.chunks.delete(chunk);\n\t\t\t\tchunkGraph.disconnectChunk(chunk);\n\t\t\t}\n\t\t\tchunkGraph.disconnectChunkGroup(chunkGroup);\n\t\t\tchunkGroup.remove();\n\t\t}\n\t}\n};\n\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {InputEntrypointsAndModules} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @returns {void}\n */\nconst buildChunkGraph = (compilation, inputEntrypointsAndModules) => {\n\tconst logger = compilation.getLogger(\"webpack.buildChunkGraph\");\n\n\t// SHARED STATE\n\n\t/** @type {BlockConnections} */\n\tconst blockConnections = new Map();\n\n\t/** @type {AllCreatedChunkGroups} */\n\tconst allCreatedChunkGroups = new Set();\n\n\t/** @type {ChunkGroupInfoMap} */\n\tconst chunkGroupInfoMap = new Map();\n\n\t/** @type {BlocksWithNestedBlocks} */\n\tconst blocksWithNestedBlocks = new Set();\n\n\t/** @type {MaskByChunk} */\n\tconst maskByChunk = new Map();\n\n\t// PART ONE\n\n\tlogger.time(\"visitModules\");\n\tvisitModules(\n\t\tlogger,\n\t\tcompilation,\n\t\tinputEntrypointsAndModules,\n\t\tchunkGroupInfoMap,\n\t\tblockConnections,\n\t\tblocksWithNestedBlocks,\n\t\tallCreatedChunkGroups,\n\t\tmaskByChunk\n\t);\n\tlogger.timeEnd(\"visitModules\");\n\n\t// PART TWO\n\n\tlogger.time(\"connectChunkGroups\");\n\tconnectChunkGroups(\n\t\tcompilation,\n\t\tblocksWithNestedBlocks,\n\t\tblockConnections,\n\t\tmaskByChunk\n\t);\n\tlogger.timeEnd(\"connectChunkGroups\");\n\n\tfor (const [chunkGroup, chunkGroupInfo] of chunkGroupInfoMap) {\n\t\tfor (const chunk of chunkGroup.chunks)\n\t\t\tchunk.runtime = mergeRuntime(chunk.runtime, chunkGroupInfo.runtime);\n\t}\n\n\t// Cleanup work\n\n\tlogger.time(\"cleanup\");\n\tcleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n\tlogger.timeEnd(\"cleanup\");\n};\n\nmodule.exports = buildChunkGraph;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}