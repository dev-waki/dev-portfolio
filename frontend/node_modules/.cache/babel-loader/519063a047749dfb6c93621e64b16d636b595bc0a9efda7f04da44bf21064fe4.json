{"ast":null,"code":"// Copyright 2012 The Obvious Corporation.\n\n/*\n * bufs: Buffer utilities.\n */\n\n/*\n * Module variables\n */\n\n/** Pool of buffers, where `bufPool[x].length === x`. */\nvar bufPool = [];\n/** Maximum length of kept temporary buffers. */\n\nvar TEMP_BUF_MAXIMUM_LENGTH = 20;\n/** Minimum exactly-representable 64-bit int. */\n\nvar MIN_EXACT_INT64 = -0x8000000000000000;\n/** Maximum exactly-representable 64-bit int. */\n\nvar MAX_EXACT_INT64 = 0x7ffffffffffffc00;\n/** Maximum exactly-representable 64-bit uint. */\n\nvar MAX_EXACT_UINT64 = 0xfffffffffffff800;\n/**\n * The int value consisting just of a 1 in bit #32 (that is, one more\n * than the maximum 32-bit unsigned value).\n */\n\nvar BIT_32 = 0x100000000;\n/**\n * The int value consisting just of a 1 in bit #64 (that is, one more\n * than the maximum 64-bit unsigned value).\n */\n\nvar BIT_64 = 0x10000000000000000;\n/*\n * Helper functions\n */\n\n/**\n * Masks off all but the lowest bit set of the given number.\n */\n\nfunction lowestBit(num) {\n  return num & -num;\n}\n/**\n * Gets whether trying to add the second number to the first is lossy\n * (inexact). The first number is meant to be an accumulated result.\n */\n\nfunction isLossyToAdd(accum, num) {\n  if (num === 0) {\n    return false;\n  }\n  var lowBit = lowestBit(num);\n  var added = accum + lowBit;\n  if (added === accum) {\n    return true;\n  }\n  if (added - lowBit !== accum) {\n    return true;\n  }\n  return false;\n}\n/*\n * Exported functions\n */\n\n/**\n * Allocates a buffer of the given length, which is initialized\n * with all zeroes. This returns a buffer from the pool if it is\n * available, or a freshly-allocated buffer if not.\n */\n\nexport function alloc(length) {\n  var result = bufPool[length];\n  if (result) {\n    bufPool[length] = undefined;\n  } else {\n    result = new Uint8Array(length);\n  }\n  result.fill(0);\n  return result;\n}\n/**\n * Releases a buffer back to the pool.\n */\n\nexport function free(buffer) {\n  var length = buffer.length;\n  if (length < TEMP_BUF_MAXIMUM_LENGTH) {\n    bufPool[length] = buffer;\n  }\n}\n/**\n * Resizes a buffer, returning a new buffer. Returns the argument if\n * the length wouldn't actually change. This function is only safe to\n * use if the given buffer was allocated within this module (since\n * otherwise the buffer might possibly be shared externally).\n */\n\nexport function resize(buffer, length) {\n  if (length === buffer.length) {\n    return buffer;\n  }\n  var newBuf = alloc(length);\n  for (var i = 0; i <= buffer.length; i++) {\n    newBuf[i] = buffer[i];\n  }\n  free(buffer);\n  return newBuf;\n}\n/**\n * Reads an arbitrary signed int from a buffer.\n */\n\nexport function readInt(buffer) {\n  var length = buffer.length;\n  var positive = buffer[length - 1] < 0x80;\n  var result = positive ? 0 : -1;\n  var lossy = false; // Note: We can't use bit manipulation here, since that stops\n  // working if the result won't fit in a 32-bit int.\n\n  if (length < 7) {\n    // Common case which can't possibly be lossy (because the result has\n    // no more than 48 bits, and loss only happens with 54 or more).\n    for (var i = length - 1; i >= 0; i--) {\n      result = result * 0x100 + buffer[i];\n    }\n  } else {\n    for (var _i = length - 1; _i >= 0; _i--) {\n      var one = buffer[_i];\n      result *= 0x100;\n      if (isLossyToAdd(result, one)) {\n        lossy = true;\n      }\n      result += one;\n    }\n  }\n  return {\n    value: result,\n    lossy: lossy\n  };\n}\n/**\n * Reads an arbitrary unsigned int from a buffer.\n */\n\nexport function readUInt(buffer) {\n  var length = buffer.length;\n  var result = 0;\n  var lossy = false; // Note: See above in re bit manipulation.\n\n  if (length < 7) {\n    // Common case which can't possibly be lossy (see above).\n    for (var i = length - 1; i >= 0; i--) {\n      result = result * 0x100 + buffer[i];\n    }\n  } else {\n    for (var _i2 = length - 1; _i2 >= 0; _i2--) {\n      var one = buffer[_i2];\n      result *= 0x100;\n      if (isLossyToAdd(result, one)) {\n        lossy = true;\n      }\n      result += one;\n    }\n  }\n  return {\n    value: result,\n    lossy: lossy\n  };\n}\n/**\n * Writes a little-endian 64-bit signed int into a buffer.\n */\n\nexport function writeInt64(value, buffer) {\n  if (value < MIN_EXACT_INT64 || value > MAX_EXACT_INT64) {\n    throw new Error(\"Value out of range.\");\n  }\n  if (value < 0) {\n    value += BIT_64;\n  }\n  writeUInt64(value, buffer);\n}\n/**\n * Writes a little-endian 64-bit unsigned int into a buffer.\n */\n\nexport function writeUInt64(value, buffer) {\n  if (value < 0 || value > MAX_EXACT_UINT64) {\n    throw new Error(\"Value out of range.\");\n  }\n  var lowWord = value % BIT_32;\n  var highWord = Math.floor(value / BIT_32);\n  buffer[0] = lowWord & 0xff;\n  buffer[1] = lowWord >> 8 & 0xff;\n  buffer[2] = lowWord >> 16 & 0xff;\n  buffer[3] = lowWord >> 24 & 0xff;\n  buffer[4] = highWord & 0xff;\n  buffer[5] = highWord >> 8 & 0xff;\n  buffer[6] = highWord >> 16 & 0xff;\n  buffer[7] = highWord >> 24 & 0xff;\n}","map":{"version":3,"names":["bufPool","TEMP_BUF_MAXIMUM_LENGTH","MIN_EXACT_INT64","MAX_EXACT_INT64","MAX_EXACT_UINT64","BIT_32","BIT_64","lowestBit","num","isLossyToAdd","accum","lowBit","added","alloc","length","result","undefined","Uint8Array","fill","free","buffer","resize","newBuf","i","readInt","positive","lossy","_i","one","value","readUInt","_i2","writeInt64","Error","writeUInt64","lowWord","highWord","Math","floor"],"sources":["/home/wickliff/Desktop/dev-waki/portfolio2/node_modules/@webassemblyjs/leb128/esm/bufs.js"],"sourcesContent":["// Copyright 2012 The Obvious Corporation.\n\n/*\n * bufs: Buffer utilities.\n */\n\n/*\n * Module variables\n */\n\n/** Pool of buffers, where `bufPool[x].length === x`. */\nvar bufPool = [];\n/** Maximum length of kept temporary buffers. */\n\nvar TEMP_BUF_MAXIMUM_LENGTH = 20;\n/** Minimum exactly-representable 64-bit int. */\n\nvar MIN_EXACT_INT64 = -0x8000000000000000;\n/** Maximum exactly-representable 64-bit int. */\n\nvar MAX_EXACT_INT64 = 0x7ffffffffffffc00;\n/** Maximum exactly-representable 64-bit uint. */\n\nvar MAX_EXACT_UINT64 = 0xfffffffffffff800;\n/**\n * The int value consisting just of a 1 in bit #32 (that is, one more\n * than the maximum 32-bit unsigned value).\n */\n\nvar BIT_32 = 0x100000000;\n/**\n * The int value consisting just of a 1 in bit #64 (that is, one more\n * than the maximum 64-bit unsigned value).\n */\n\nvar BIT_64 = 0x10000000000000000;\n/*\n * Helper functions\n */\n\n/**\n * Masks off all but the lowest bit set of the given number.\n */\n\nfunction lowestBit(num) {\n  return num & -num;\n}\n/**\n * Gets whether trying to add the second number to the first is lossy\n * (inexact). The first number is meant to be an accumulated result.\n */\n\n\nfunction isLossyToAdd(accum, num) {\n  if (num === 0) {\n    return false;\n  }\n\n  var lowBit = lowestBit(num);\n  var added = accum + lowBit;\n\n  if (added === accum) {\n    return true;\n  }\n\n  if (added - lowBit !== accum) {\n    return true;\n  }\n\n  return false;\n}\n/*\n * Exported functions\n */\n\n/**\n * Allocates a buffer of the given length, which is initialized\n * with all zeroes. This returns a buffer from the pool if it is\n * available, or a freshly-allocated buffer if not.\n */\n\n\nexport function alloc(length) {\n  var result = bufPool[length];\n\n  if (result) {\n    bufPool[length] = undefined;\n  } else {\n    result = new Uint8Array(length);\n  }\n\n  result.fill(0);\n  return result;\n}\n/**\n * Releases a buffer back to the pool.\n */\n\nexport function free(buffer) {\n  var length = buffer.length;\n\n  if (length < TEMP_BUF_MAXIMUM_LENGTH) {\n    bufPool[length] = buffer;\n  }\n}\n/**\n * Resizes a buffer, returning a new buffer. Returns the argument if\n * the length wouldn't actually change. This function is only safe to\n * use if the given buffer was allocated within this module (since\n * otherwise the buffer might possibly be shared externally).\n */\n\nexport function resize(buffer, length) {\n  if (length === buffer.length) {\n    return buffer;\n  }\n\n  var newBuf = alloc(length);\n\n  for (var i = 0; i <= buffer.length; i++) {\n    newBuf[i] = buffer[i];\n  }\n\n  free(buffer);\n  return newBuf;\n}\n/**\n * Reads an arbitrary signed int from a buffer.\n */\n\nexport function readInt(buffer) {\n  var length = buffer.length;\n  var positive = buffer[length - 1] < 0x80;\n  var result = positive ? 0 : -1;\n  var lossy = false; // Note: We can't use bit manipulation here, since that stops\n  // working if the result won't fit in a 32-bit int.\n\n  if (length < 7) {\n    // Common case which can't possibly be lossy (because the result has\n    // no more than 48 bits, and loss only happens with 54 or more).\n    for (var i = length - 1; i >= 0; i--) {\n      result = result * 0x100 + buffer[i];\n    }\n  } else {\n    for (var _i = length - 1; _i >= 0; _i--) {\n      var one = buffer[_i];\n      result *= 0x100;\n\n      if (isLossyToAdd(result, one)) {\n        lossy = true;\n      }\n\n      result += one;\n    }\n  }\n\n  return {\n    value: result,\n    lossy: lossy\n  };\n}\n/**\n * Reads an arbitrary unsigned int from a buffer.\n */\n\nexport function readUInt(buffer) {\n  var length = buffer.length;\n  var result = 0;\n  var lossy = false; // Note: See above in re bit manipulation.\n\n  if (length < 7) {\n    // Common case which can't possibly be lossy (see above).\n    for (var i = length - 1; i >= 0; i--) {\n      result = result * 0x100 + buffer[i];\n    }\n  } else {\n    for (var _i2 = length - 1; _i2 >= 0; _i2--) {\n      var one = buffer[_i2];\n      result *= 0x100;\n\n      if (isLossyToAdd(result, one)) {\n        lossy = true;\n      }\n\n      result += one;\n    }\n  }\n\n  return {\n    value: result,\n    lossy: lossy\n  };\n}\n/**\n * Writes a little-endian 64-bit signed int into a buffer.\n */\n\nexport function writeInt64(value, buffer) {\n  if (value < MIN_EXACT_INT64 || value > MAX_EXACT_INT64) {\n    throw new Error(\"Value out of range.\");\n  }\n\n  if (value < 0) {\n    value += BIT_64;\n  }\n\n  writeUInt64(value, buffer);\n}\n/**\n * Writes a little-endian 64-bit unsigned int into a buffer.\n */\n\nexport function writeUInt64(value, buffer) {\n  if (value < 0 || value > MAX_EXACT_UINT64) {\n    throw new Error(\"Value out of range.\");\n  }\n\n  var lowWord = value % BIT_32;\n  var highWord = Math.floor(value / BIT_32);\n  buffer[0] = lowWord & 0xff;\n  buffer[1] = lowWord >> 8 & 0xff;\n  buffer[2] = lowWord >> 16 & 0xff;\n  buffer[3] = lowWord >> 24 & 0xff;\n  buffer[4] = highWord & 0xff;\n  buffer[5] = highWord >> 8 & 0xff;\n  buffer[6] = highWord >> 16 & 0xff;\n  buffer[7] = highWord >> 24 & 0xff;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}